===============
Unwrapping Echo
===============

.. default-domain:: bash

.. file:: uwecho.bsh

Unwrapping echo

.. function:: uwecho

:Arguments: [``$1``...] - Args to echo
:Output: *stdout* - Echo's strings with lines unindented

Unwrapping echo

When doing many multiline echo's, mixed indentation becomes hard to read:

.. code-block:: bash

   $   echo "This
   > is
   >   a
   >   test"

uwecho will determine how many spaces up to the quote on the first line, and remove that many spaces if they are leading in all the subsequent lines


.. code-block:: bash

   $   uwecho "This
   >           is
   >             a
   >             test"

Much easier to read. Even handles:

.. code-block:: bash

   $   uwecho "  This
   >           is
   >             a test"

One odd side-effect is this looks a little weird:

.. code-block:: bash

   $   uwecho 'Use "quote" and get: '"${Variable}"'
               '"${Another_variable}"' goes here
               * <-- This is where the indent is'

The second line looks like it has one too many spaces when, in fact, it has the right number of spaces.

.. note::

   - This only works when called directly from a script saved in a file. Will not work in a script that is piped in or on an interactive command line.
   - Will not work correctly if you are using ``$'\n'`` or similar methods to add a newline without an actual newline.
   - Will not work correctly if you use hard tab in your indents. Use here doc if you want to use hard tabs
   - Not smart enough to work unless line starts with spaces and ``uwecho``. No inline environment variables setting, or execution of wrappers, etc...
   - Does not work if you cd after the script is started, unless you use the full path name to call the script
   - Does not work reliably in $() or ` ` or any process subprocess

   .. code-block:: bash

      # Interactive can sometimes work, but is still discouraged.
      $ cat foo.bsh
      foo()
      {
        uwecho "foo
                bar"
      }
      bar(){ foo; }
      bar

      # Always works
      $ bash foo.bsh

      # Will not work, foo is being called directly in interactive mode
      # (internal bar call does work in bash 4.1 and newer)
      $ source foo.bsh; foo

      # Will not work, bar is being called directly in interactive mode
      # (internal bar call does work in bash 4.1 and newer)
      $ source foo.bsh; bar

      # Does work in bash 4.1 or newer
      $ source foo.bsh; source <(echo foo)

