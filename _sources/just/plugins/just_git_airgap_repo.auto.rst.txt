.. default-domain:: bash

===========================================
J.U.S.T. Mirror to an Air-gapped Repository
===========================================

.. file:: just_git_airgap_repo.bsh

While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.

.. rubric:: Example

Assume we have a project called project_repo stored at ``https://git-server.com/projectA/project_repo.git`` and vsi_common is a submodule of it.

This repository is recursively cloned to /src; it looks like

.. code-block:: bash

     project_repo/
       .gitmodules
       Justfile
       setup.env
       external/vsi_common/               # submodule
       external/vsi_common/docker/recipes # sub-submodule

Before this repository can be mirrored (which is not the same thing as a clone) and pushed to a new air-gapped git server, first, a little setup is necessary. This is because, after the air-gapped repository is (shallow) cloned, the submodules must be re-configured before they can be updated (recursively). This is handled by the ``git_airgap-submodule-update`` ``just`` target. However, this obviously cannot be called until the vsi_common submodule is itself initialized and updated. To accomplish this, a small function, :func:`git_airgap_submodule_helper.bsh git_airgap_submodule_update`, is orphan committed to the air-gapped repository so that it is available for this task.

As no ``just`` functions can be called yet, this function must be called in the file specified by :envvar:`JUST_SETUP_SCRIPT` (typically called setup.env). For example, the setup.env script, which typically looks like:

.. code-block:: bash

   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"

would become:

.. code-block:: bash

   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
   if [ ! -f "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh" ]; then
     echo "'just' could not be loaded. Trying to setup the repository as an"
     echo "air-gapped repository"
     # source the contents of repo_map.env (in a bash 3.2 compatible way)
     source /dev/stdin <<< \
         "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null || :)"
     if ! declare -Fx git_airgap_submodule_update; then
       echo "ERROR the vsi_common submodule could not be found!"
       return 1
     fi
     git_airgap_submodule_update external/vsi_common
   fi
   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"

This repository is now setup and can be mirrored and pushed to a new air-gapped git server:

#. ``just git export-repo-guided`` - This target asks a series of questions and then mirrors the repository and its submodules (recursively). For this example, when prompted, we will, "Create a new mirror from a remote's URL", and save the the mirrored repositories to the output directory, ``{output_dir}``. In this case, because there is only a single remote, ``origin``, and a single branch, ``master``, they are chosen automatically.

.. note::
  The mirror is created from (the URL of) the remote---not directly from this clone itself.

2. Transfer the archive at ``{output_dir}/transfer_{date}.tgz`` to your destination.
#. On the destination, create a directory, e.g., ``{transfer_dir}``, and move the archive into it
#. Extract the archive (the archive will extract directly into this directory)

  a) In ``{transfer_dir}``, edit ``repo_map.env`` and set the :var:`just_git_airgap_repo.bsh create_repo_map JUST_GIT_AIRGAP_MIRROR_URL` environment variable. For example,

    - ``JUST_GIT_AIRGAP_MIRROR_URL=https://git-airgap.com/projectA``

5. Initialize bare repositories on the air-gapped git server for the project_repo and its submodules. The list of all submodules can be found in the ``repo_map.env`` file, which maps between the submodule's path and its new URL. In this example, these should be located at

  - ``https://git-airgap.com/projectA/project_repo.git``
  - ``https://git-airgap.com/projectA/vsi_common.git``
  - ``https://git-airgap.com/projectA/recipes.git``

6. ``source setup.env``
#. ``just git import-repo`` - Push the mirrored repository and all its submodules to the new git server as defined by repo_map.env

1. Subsequent updates can be pushed to the repositories using much the same process, although with a few variations:

  #. In step 1, when prompted, choose "Base the archive off an existing airgap mirror"; in this example, ``{output_dir}``.

    - In addition to another full archive, an incremental archive, ``transfer_{date}_transfer_{previous_date}.tgz``, is also created (if supported). This incremental archive may be significantly smaller than the full archive.
    - In step 2, if the incremental archive is transferred to the destination, then
      - In step 3, move the archive into the same directory as before; in this example, ``{transfer_dir}``.
      - In step 4, extract this incremental archive on top of the existing mirror.
    - In step 2, if instead the full archive is transferred, then
      - In step 3, the same directory, ``{transfer_dir}``, can be re-used, although it doesn't have to be.

 #. In step 5, unless there is a new submodule being mirrored, the repositories are already configured.

A developer can then run:

#. ``git clone https://git-airgap.com/projectA/project_repo.git`` - Note: non-recursive
#. ``source setup.env``
#. ``just git airgap-submodule-update`` - Clone submodules recursively from the new mirror

.. note::

  If a new submodule is added to the repository then ``just git airgap-submodule-update`` must be re-run instead of the standard git command, ``git submodule update``, which will fail because the location of the submodules as defined in the .gitmodules file is not correct here---instead, the submodule must first be re-configured to point to the URL specified by repo_map.env. (This command is essentially doing a custom ``git submodule sync`` and ``git submodule update``. Accordingly, it must also be run if the URL of the submodule is changed, which could happen, e.g., if the location of the airgap'ed server changed. Note that in this case, an updated ``repo_map.env`` file would need to be committed to the old airgap'ed server.)

  Limitations - There are a few limitations with a mirrored repository:

  1. While the mirrored repository is a proper git repository, care must be taken to ensure subsequent (incremental) mirrors are successful: specifically, the transferred branches must remain read-only. However, additional branches/tags can be created as long as their names won't clash with those from the host repository.

  #. :func:`git_mirror git_mirror_main`, and by extension this plugin, does not mirror all submodules that have ever been part of the repo, only those from a specific branch/SHA/tag you specify (master by default). Consequently, checking out another version of the repository with a different version of the .gitmodules file in which a submodule has been deleted or renamed may cause the ``git_airgap-submodule-update`` to fail because the submodule's remote URL could not be re-configured to point to the mirror.

.. seealso::

  :func:`git_mirror git_mirror_main`, :func:`git_mirror git_push_main`, and :func:`git_mirror git_clone_main`

.. function:: log_unpushed_commits

List all unpushed commits to stdout

List all commits on branches/tags that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch

:Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
            - [``$2...``] - A branch/tag to filter by (or multiple branches/tags); e.g., master. If unset, then don't filter

:Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout

.. seealso::

  :func:`log_outgoing_commits`

.. function:: git_tracking_branch

Get the corresponding remote-tracking branch for a local-tracking branch

:Arguments: - ``$1`` - A local-tracking branch; e.g., master

:Output: - ``*stdout*`` - The corresponding remote-tracking branch, or the empty string if there is no tracking branch

.. note::

  - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with ``git push`` or ``git branch``.
  - A branch cannot track multiple remotes.

.. function:: git_tracking_branches

Find all local- and corresponding remote-tracking branches

:Arguments: - [``$1...``] - The name of a remote to filter by (or multiple remotes); e.g., origin. If unset, then don't filter

:Output: - ``just_git_tracking_branches`` - An array of local-tracking branch names
         - ``just_git_remote_tracking_branches`` - A corresponding array of remote-tracking branch names

.. note::

  - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with ``git push`` or ``git branch``.
  - A branch cannot track multiple remotes.

.. function:: log_outgoing_commits

List all unpushed commits for a tracking branch to stdout

:Arguments: - ``$1...`` - A local-tracking branch (or multiple branches); e.g., master

:Output: - ``*stdout*`` - Print all unpushed commits for the tracking branch to stdout

.. seealso::

  :func:`log_all_outgoing_commits` and :func:`log_unpushed_commits`

.. function:: log_all_outgoing_commits

List all unpushed commits for tracking branches to stdout

:Arguments: - [``$1...``] - The name of a remote to filter by (or multiple remotes); e.g., origin. If unset, then don't filter

:Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout

.. seealso::

  :func:`log_outgoing_commits` and :func:`log_unpushed_commits`

.. function:: convert_git_remote_http_to_git

Change the remote url of a git repo to use the git@ syntax instead of https

In a git repository (or submodule), if the (last) URL of the remote is specified using the the ``https://`` protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to a private remote server easier. Assume a very basic url format: ``https://git-server.com/co/project.git`` without port, query, or fragment sections. Warn if these exist. Do nothing if a pushurl is already configured

:Arguments: - [``$1``] - The name of a remote to convert. Default: origin

.. note::

  This does not change a submodule's tracked URL (i.e., the URL in the .gitmodules file) nor a submodule's URL (i.e., .git/config:submodule), only the URL of the remote in .git/\*\*/config (e.g., .git/modules/docker/recipes/config:remote)

.. function:: is_submodule

:Output: - Returns ``0`` if the PWD is in a submodule, ``1`` for it is not

.. function:: git_project_root_dir

:Output: ``*stdout*`` - The absolute path to the root of the topmost superproject’s working tree.

.. rubric:: Example

If the vsi_common repository is cloned (recursively) at ``/src``, and then :func:`git_project_root_dir` will output ``/src/vsi_common``. This is true regardless of where in the work-tree the function is run from, including from within submodules, sub-submodules, etc.

.. function:: git_project_git_dir

:Output: ``*stdout*`` - The absolute path to the git directory of the topmost superproject.

If the vsi_common repository is cloned (recursively) at ``/src``, and then :func:`git_project_git_dir` will output ``/src/vsi_common/.git``. This is true regardless of where in the work-tree the function is run from, including from within submodules, sub-submodules, etc.

.. function:: git_submodule_summary_recursive

Recursively log the commits differing between each submodule's tracked commit and its current working tree

.. seealso::

  :func:`git_submodule_summary`

.. function:: git_submodule_summary

Log the commits differing between each submodule's tracked commit and its current working tree

Using ``git diff --submodule=log``, compare the working tree of each submodule to the version committed to HEAD of the super project, and list any commits that are missing and/or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project. Of course, the commit graph could diverge in more complicated ways.

:Output: - ``*stdout*`` - Each submodule's differences in terms of commits

.. note::

  This function iterates through each submodule in a depth-first traversal

.. seealso::

  https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt

.. seealso::

  :func:`git_submodule_summary_recursive`

.. function:: git_submodule_displaypaths_recursive

Recursively get the displaypath to each submodule

.. seealso::

  :func:`git_submodule_displaypaths`

.. function:: git_submodule_displaypaths

Get the displaypath to each submodule

Get what git refers to as the displaypath of the submodule: the relative path from the current working directory to the root of the containing repository and then to each submodule. This path is defined by the git-specified environment variable, displaypath (or prefix depending on git version).

:Output: *stdout* - The displaypath to each submodule (recursively); e.g., docker/recipes

.. note::

  Submodule paths are not the same thing as submodule names.

.. note::

  This function iterates through each submodule in the same order as :func:`git_submodule_urls`, :func:`git_submodule_names` and :func:`git_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated.

.. seealso::

  :func:`git_submodule_displaypaths_recursive` and :func:`git_submodule_urls`

.. function:: git_submodule_urls_recursive

Recursively get all submodule URLs

.. seealso::

  :func:`git_submodule_urls`

.. function:: git_submodule_urls

Get all submodule URLs

Get the (last) URL for each submodule (recursively) from its .git/\*\*/config file (e.g., .git/modules/docker/recipes/config) for the specified remote (origin by default). Note: Since git 1.8, a remote can have multiple associated URLs (and pushurls) (see .git/config).

:Arguments: [``$1``] - The name of a remote. Note: this same remote must exist in all submodules. Default: origin
:Output: *stdout* - The URL of each submodule (recursively); e.g., https://github.com/VisionSystemsInc/docker_recipes.git

.. note::

   The ultimate source-of-truth of a submodule's URL is in its .gitmodules file. If the URL is updated in this file, then the repository's and submodule's configurations will be out-of-date. ``git submodule sync`` will update these configurations using the .gitmodules file and the default remote of the current branch, if set; otherwise origin. :func:`git_submodule_sync` will do the same but using the specified remote.

.. note::

  This function iterates through each submodule in the same order as :func:`git_submodule_displaypaths`, :func:`git_submodule_names` and :func:`git_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated. Cf. :func:`git_mirror get_config_submodule_names`, which will (non-recursively) list submodules that have only been init'd. The associated URL can then be queried for a given submodule name with ``git config --get submodule.<name>.url`` as :func:`git_mirror clone_submodules` does.

.. seealso::

  :func:`git_submodule_urls_recursive` and :func:`git_submodule_displaypaths`

.. function:: git_submodule_names_recursive

Recursively get the name of each submodule

.. seealso::

  :func:`git_submodule_names`

.. function:: git_submodule_names

Get the name of each submodule

Get the name of the submodule as defined in the .gitmodules file. This name is, by default, the same as the path to the submodule; however, this is not necessarily the case.

:Output: *stdout* - The name of each submodule (recursively); e.g., docker/recipes

.. note::

  Submodule names are not the same thing as submodule paths.

.. note::

  This function iterates through each submodule in the same order as :func:`git_submodule_displaypaths`, :func:`git_submodule_urls` and :func:`git_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated. Cf. :func:`git_mirror get_config_submodule_names` (it queries the current repository's submodule names from its configuration), which will list submodules that have been init'd but not updated, and :func:`just_git_functions.bsh submodule-helper-list`, which will list all submodules, even those not init'd (it queries the current repository's submodule names and paths from the .gitmodules file). Although these functions are not recursive, they both are used to recurse manually through all the submodules (albeit, in a different order than this function).

.. seealso::

  :func:`git_submodule_names_recursive` and :func:`git_submodule_toplevels`

.. function:: git_submodule_toplevels_recursive

Recursively get the path to the top-level directory of each submodule

.. seealso::

  :func:`git_submodule_toplevels`


.. function:: git_submodule_toplevels

Get the path to the top-level directory of each submodule

Get the path to what git refers to as the top-level directory of the submodule; i.e., the absolute path to the top-level of the immediate superproject. For example, the vsi_common repository has a submodule at ``docker/recipes``. If the repository is cloned in ``/src``, then the top-level directory for the submodule docker/recipes is ``/src/vsi_common``.

This function, along with :func:`git_submodule_names`, could be used to, for example, cd to the top-level of each immediate superproject and then query the repository's submodule configuration using ``git config submodule.<name>.<key>``; e.g., ``git config submodule.docker/recipes.url``.

:Output: *stdout* - The top-level directory of each submodule (recursively); e.g., /src/vsi_common

.. note::

  This function iterates through each submodule in the same order as :func:`git_submodule_displaypaths`, :func:`git_submodule_urls` and :func:`git_submodule_names` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated.

.. seealso::

  :func:`git_submodule_toplevels_recursive` and :func:`git_submodule_names`

.. function:: create_repo_map

Create the contents of the repo_map.env file

Create the repository mapping such that, once the :var:`JUST_GIT_AIRGAP_MIRROR_URL` variable is defined, it can be sourced by :func:`git_mirror git_push_main` and :func:`git_mirror git_clone_main`.

:Argument: ``$1`` - The project's repository name (e.g., vsi_common)

:Parameters: [``ASSOCIATIVE_REPO_MAP``] - Set to a value to create the repo map as an associative-array, ``repos``, as opposed to two partitioned arrays (which is bash 3.2 compatible): ``repo_urls`` and ``repo_paths``. (Default: unset; i.e., partitioned)

:Output: *stdout* - The contents of the repo_map.env file, the file that maps between the submodule's path and its new URL. For example,

.. code-block:: bash

   # The urls are specified with the variable JUST_GIT_AIRGAP_MIRROR_URL,
   # which must be set to the mirrored repositories' new location on the
   # air-gapped git server. Delay setting this variable until the archive has
   # been moved to the destination in case the information must be controlled
   JUST_GIT_AIRGAP_MIRROR_URL=

   repo_paths=(
     ./
     ./docker/recipes
   )
   repo_urls=(
     "${JUST_GIT_AIRGAP_MIRROR_URL}/vsi_common.git"
     "${JUST_GIT_AIRGAP_MIRROR_URL}/recipes.git"
   )

If, for example, :var:`JUST_GIT_AIRGAP_MIRROR_URL` was set to ``https://git-server/projectA``, these urls would expand to:

  - ``https://git-server/projectA/vsi_common.git``
  - ``https://git-server/projectA/recipes.git``

.. note::

  The user can override this function if it does not suit her needs

.. var:: JUST_GIT_AIRGAP_MIRROR_URL

A variable used in the repo_map.env file created by :func:`create_repo_map` to specify the mirrored repositories' new location on the air-gapped git server

.. function:: orphan_commit_repo_map

Orphan commit the repo_map.env file

Given a repository mapping like the one produced by :func:`create_repo_map`, make an orphan commit in the repository (on a branch named __just_git_mirror_info_file by default) to a file named repo_map.env.

:Arguments: - ``$1`` - The contents of the repo_map.env file; i.e., the file that maps between the submodule's path and its new URL
            - [``$2``] - The name of the branch on which to make the orphan commit. Default: __just_git_mirror_info_file

.. function:: add_import-repo_just_project

Create a simple just project in the prep_dir

This function creates a simple just project (a README.md, setup.env, and Justfile that includes this plugin) in the air-gapped mirror cache (the prep_dir) created by the ``git_export-repo`` ``just`` target. This just project can be used to push (aka import) the mirrored repositories to their respective air-gapped git server by using the ``git_import-repo`` ``just`` target.

:Arguments: ``$1`` - The output directory (prep_dir) that caches the mirrored repositories and archive to be transferred

:Output: ``${1}/{README.md,setup.env,Justfile}``

.. function:: submodule-helper-relative-url

Essentially ``git submodule--helper relative-url`` (if it existed)

Resolve a submodule's relative URL based on the parent URL. This function works by creating a dummy git repository and submodule and then running ``git submodule init`` (which runs a process similar to ``git submodule sync``), after which, the resolved URL can be queried with ``git config submodule.submod.url``. We do this to avoid modifying the existing repository's git configuration (e.g., ``git config submodule.docker/recipes.url``).

:Arguments: * ``$1`` - URL of the parent repository; e.g., ``git config remote.origin.url``
            * ``$2`` - A relative submodule URL---typically from the .gitmodules file; e.g., ``git config -f .gitmodules submodule.docker/recipes.url``
            * [``$3``] - Up path: path from the submodule to the parent repository; e.g., ``../../``. Must have a trailing slash. (Not strictly necessary if ``$1`` is an absolute path)

:Output: *stdout* - Resolved URL

.. note::

  This is essentially a bash port of the function `relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L117>`_ (called from `resolve_relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L180>`_, aka ``git submodule--helper resolve-relative-url``, which itself is called from `cmd_sync() <https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L1014>`_, aka ``git submodule sync``. ``git submodule--helper resolve-relative-url``, which is available in git 2.9 and after, does not allow us to specify (directly) the remote URL from which to resolve a relative URL: it resolves relative URLs based on the remote URL, ``git config remote.${remote_name}.url``, where remote_name is the default remote of the current branch, if set; otherwise origin.

.. function:: git_submodule_sync_recursive

``git submodule sync --recursive`` but using a specific remote (``just_upstream`` by default)

.. seealso::

  :func:`git_submodule_sync`

.. function:: git_submodule_sync

``git submodule sync`` but using a specific remote (``just_upstream`` by default)

Like ``git submodule sync``, synchronize the configured URL of each submodule in a repository (recursively) to the value specified in .gitmodules; however, instead of overwriting the default remote (origin), update the remote specified by JUST_GIT_UPSTREAM (``just_upstream`` by default).

:Arguments: [``$1``] - The project-repository's remote. Default: origin
            [``$2...``] - The submodule path to sync (or multiple submodules). Default: all submodules of the current repository (non-recursively)
:Parameters: - [``JUST_GIT_UPSTREAM``] - The submodules' remote to sync. When updating the URL in the submodules' configuration, use this remote. Default: ``just_upstream``

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated.

.. note::

  Creates the just_upstream remote just like, and using the same procedure as, :func:`just_git_functions.bsh safe_git_submodule_update`; however, importantly, it does not try to update the submodule to the expected SHA.

.. seealso::

  :func:`git_submodule_sync_recursive`

.. function:: git_submodule_is_published_recursive

Ensure all submodules have pushed the necessary changes to their public repo

Check each submodule (recursively) to see if the SHA tracked by its parent repository has been pushed to the URL tracked by the parent repository (per its .gitmodules file). Must be run from the root of a repository.

:Arguments: [``$1``] - The project-repository's remote. Default: origin
:Parameters: - [``JUST_GIT_UPSTREAM``] - The submodule's remote to sync. When fetching, use this remote's URL. Default: ``just_upstream``

:Output: Return 0 if, for each submodule (recursively), the changes tracked by the parent repository have been made public; otherwise, return 1

.. note::

  Creates a JUST_GIT_UPSTREAM remote. See :func:`git_submodule_sync`.

.. note::

  Cf. ``git push --recurse-submodules=check`` (available since git 1.8.0) will check for unpushed commits in a submodule for its current committed state in the parent project. However, this only seems to work if it is used with a set of outgoing commits that contains a change to a submodule. And, despite its name, it does not seem to recurse into submodules.

.. function:: relocate_git_defaultify

Git relocate plugin for just

