.. default-domain:: bash

===========================================
J.U.S.T. Mirror to an Air-gapped Repository
===========================================

.. file:: just_git_airgap_repo.bsh

While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.

.. rubric:: Example

Assume we have a project called simple_repo stored at ``https://git-server.com/projectA/simple_repo.git`` and vsi_common is a submodule of it.

This repository is recursively cloned to /src; it looks like

.. code-block:: bash

   /src/
     simple_repo/
       .gitmodules
       Justfile
       setup.env
       external/vsi_common/               # submodule
       external/vsi_common/docker/recipes # sub-submodule

Before this repository can be mirrored (which is not the same thing as a clone) and pushed to a new air-gapped git server, first, a little setup is necessary. This is because, after the air-gapped repository is (shallow) cloned, the submodules must be re-configured before they can be updated (recursively). This is handled by the ``git_clone-airgap-repo`` ``just`` target. However, this obviously cannot be called until the vsi_common submodule is itself initialized and updated. To accomplish this, a small function, :func:`git_airgap_submodule_helper.bsh git_airgap_submodule_update`, is orphan committed to the air-gapped repository so that it is available for this task.

As no ``just`` functions can be called yet, this function must be called in the file specified by :envvar:`JUST_SETUP_SCRIPT` (typically called setup.env). For example, the setup.env script, which typically looks like:

.. code-block:: bash

   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"

would become:

.. code-block:: bash

   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
   if [ ! -f "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh" ]; then
     echo "'just' could not be loaded. Trying to setup the repository as an"
     echo "air-gapped repository"
     # source the contents of repo_map.env (in a bash 3.2 compatible way)
     source /dev/stdin <<< \
         "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null || :)"
     if ! declare -Fx git_airgap_submodule_update; then
       echo "ERROR the vsi_common submodule could not be found!"
       return 1
     fi
     git_airgap_submodule_update external/vsi_common
   fi
   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"

This repository is now setup and can be mirrored and pushed to a new air-gapped git server:

#. ``just git export-repo-guided`` - This target asks a series of questions and then mirrors the repository and its submodules (recursively). In this case, there is only a single remote, ``origin``, and a single branch, ``master``; these are chosen automatically. We will save the the mirrored repositories to the output directory, ``/mirrors``.

.. note::
  The mirror is created from (the URL of) the remote---not directly from this clone itself.

2. Transfer ``/mirrors/transfer_{date}.tgz`` to your destination.
#. On the destination, create a directory, e.g., ``/airgap``, and move the archive into it
#. Extract the archive (the archive will extract directly into this directory)

  a) In ``/airgap``, edit ``repo_map.env`` and set the :var:`just_git_airgap_repo.bsh create_repo_map JUST_GIT_AIRGAP_MIRROR_URL` environment variable. For example,

    - ``JUST_GIT_AIRGAP_MIRROR_URL=https://git-airgap.com/projectA``

5. If not already, initialize bare repositories on the air-gapped git server for simple_repo and its submodules. In this example, these should be located at

  - ``https://git-airgap.com/projectA/simple_repo.git``
  - ``https://git-airgap.com/projectA/vsi_common.git``
  - ``https://git-airgap.com/projectA/recipes.git``

6. ``source setup.env``
#. ``just git import-repo`` - Push the mirrored repository and all its submodules to the new git server as defined by repo_map.env
#. Incremental updates can be pushed to the repositories using much the same process.

A developer can then run:

#. ``git clone https://git-airgap.com/projectA/simple_repo.git`` - Note: non-recursive
#. ``source setup.env``
#. ``just git clone-airgap-repo`` - Clone submodules recursively from the new mirror

.. seealso::

  :func:`git_mirror git_mirror_main`, :func:`git_mirror git_push_main`, and :func:`git_mirror git_clone_main`

.. rubric:: Bugs

The airgap'ed repository will not support ``git submodule sync`` because the value in the .gitmodules file has been re-configured

.. envvar:: GIT

Name/path of git executable

Instead of hard-coding "git" everywhere, use the variable :envvar:`GIT` so that when the need comes, it is easier to switch which executable gets called. Set to empty string to have any calls to git skipped.

All :func:`relocate_git_defaultify` targets will be skipped if the value of :envvar:`GIT` is not found or empty.

.. note::

  When using the GIT env variable in this file, do not surround it with quotes as you normally would. Although this prevents using a path to ``git`` with a space in it, in exchange, it may be possible (eventually) to enable a dry-run-ish capability if GIT is set to ``echo git``.

.. function:: log_unpushed_commits

List all unpushed commits to stdout

List all commits on branches/tags that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch

:Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
            - [``$2``] - A branch's/tag's name to filter by; e.g., master. If unset, then don't filter

:Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout

.. seealso::

  :func:`log_outgoing_commits`

.. function:: get_tracking_branches

Find remote- and corresponding local-tracking branches

:Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
            - [``$2``] - A branch's name to filter by; e.g., master. If unset, then don't filter by branch name

:Output: - ``just_git_tracking_branches`` - An array of local-tracking branch names
         - ``just_git_remote_tracking_branches`` - A corresponding array of remote-tracking branch names
         - [``*stdout*``] - If ``$2`` is specified, print the respective remote-tracking branch, or the empty string if there is no tracking branch

.. note::

  If any arguments are supplied, then the remote-tracking branch will be printed to ``*stdout*``, otherwise, the tracking branches and corresponding remote-tracking branches will be saved to the output variables, ``just_git_tracking_branches`` and ``just_git_remote_tracking_branches``.

.. note::

  A branch cannot track multiple remotes.

.. note::

  - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with ``git push`` or ``git branch``.
  - A branch cannot track multiple remotes.

.. function:: log_outgoing_commits

List all unpushed commits for tracking branches to stdout

:Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
            - [``$2``] - A local-tracking branch's name to filter by; e.g., master. If unset, then don't filter by branch name

:Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout

.. seealso::

  :func:`log_unpushed_commits`

.. function:: convert_git_remote_http_to_git

Change the remote url of a git repo to use the git@ syntax instead of https

In a git repository (or submodule), if the (last) URL of the remote is specified using the the ``https://`` protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to a private remote server easier. Assume a very basic url format: ``https://git-server.com/co/project.git`` without port, query, or fragment sections. Warn if these exist. Do nothing if a pushurl is already configured

:Arguments: - [``$1``] - The name of a remote to convert. Default: origin

.. note::

  This does not change a submodule's tracked URL (i.e., the URL in the .gitmodules file) nor a submodule's URL (i.e., .git/config:submodule), only the URL of the remote in .git/\*\*/config (e.g., .git/modules/docker/recipes/config:remote)

.. function:: is_submodule

:Output: - Returns ``0`` if the PWD is in a submodule, ``1`` for it is not

.. function:: git_project_root_dir

:Output: ``*stdout*`` - The absolute path to the root of the topmost superprojectâ€™s working tree.

.. rubric:: Example

If the vsi_common repository is cloned (recursively) at ``/src``, and then :func:`git_project_root_dir` will output ``/src/vsi_common``. This is true regardless of where in the work-tree the function is run from, including from within submodules, sub-submodules, etc.

.. function:: git_project_git_dir

:Output: ``*stdout*`` - The absolute path to the git directory of the topmost superproject.

If the vsi_common repository is cloned (recursively) at ``/src``, and then :func:`git_project_git_dir` will output ``/src/vsi_common/.git``. This is true regardless of where in the work-tree the function is run from, including from within submodules, sub-submodules, etc.

.. function:: submodule_summary

Log the commits differing between each submodule's tracked commit and its current working tree

Using ``git diff --submodule=log``, compare the working tree of each submodule to the version committed to HEAD of the super project, and list any commits that are missing and/or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project. Of course, the commit graph could diverge in more complicated ways.

:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset
:Output: - ``*stdout*`` - Each submodule's differences in terms of commits

.. seealso::

  https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt

.. note::

  This function iterates through each submodule in a depth-first traversal

.. function:: get_submodule_displaypaths

Get the displaypath to each submodule

Get what git refers to as the displaypath of the submodule: the relative path from the current working directory to the root of the containing repository and then to each submodule. This path is defined by the git-specified environment variable, displaypath (or prefix depending on git version).

:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset
:Output: *stdout* - The displaypath to each submodule (recursively); e.g., docker/recipes

.. note::

  Submodule paths are not the same thing as submodule names.

.. note::

  This function iterates through each submodule in the same order as :func:`get_submodule_urls`, :func:`get_submodule_names` and :func:`get_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated.

.. seealso::

  :func:`get_submodule_urls`

.. function:: get_submodule_urls

Get all submodule URLs

Get the (last) URL for each submodule (recursively) from its .git/\*\*/config file (e.g., .git/modules/docker/recipes/config) for the specified remote (origin by default). Note: Since git 1.8, a remote can have multiple associated URLs (and pushurls) (see .git/config).

:Arguments: [``$1``] - The name of a remote. Note: this same remote must exist in all submodules. Default: origin
:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset
:Output: *stdout* - The URL of each submodule (recursively); e.g., https://github.com/VisionSystemsInc/docker_recipes.git

.. note::

   The ultimate source-of-truth of a submodule's URL is in its .gitmodules file. If the URL is updated in this file, then the repository's and submodule's configurations will be out-of-date. ``git submodule sync`` will update these configurations using the .gitmodules file and the default remote of the current branch, if set; otherwise origin. :func:`git_sync_submodules` will do the same but using the specified remote.

.. note::

  This function iterates through each submodule in the same order as :func:`get_submodule_displaypaths`, :func:`get_submodule_names` and :func:`get_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated. Cf. :func:`git_mirror get_config_submodule_names`, which will (non-recursively) list submodules that have only been init'd. The associated URL can then be queried for a given submodule name with ``git config --get submodule.<name>.url`` as :func:`git_mirror clone_submodules` does.

.. seealso::

  :func:`get_submodule_displaypaths`

.. function:: get_submodule_names

Get the name of each submodule

Get the name of the submodule as defined in the .gitmodules file. This name is, by default, the same as the path to the submodule; however, this is not necessarily the case.

:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset
:Output: *stdout* - The name of each submodule (recursively); e.g., docker/recipes

.. note::

  Submodule names are not the same thing as submodule paths.

.. note::

  This function iterates through each submodule in the same order as :func:`get_submodule_displaypaths`, :func:`get_submodule_urls` and :func:`get_submodule_toplevels` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated. Cf. :func:`git_mirror get_config_submodule_names` (it queries the current repository's submodule names from its configuration), which will list submodules that have been init'd but not updated, and :func:`just_git_functions.bsh submodule-helper-list`, which will list all submodules, even those not init'd (it queries the current repository's submodule names and paths from the .gitmodules file). Although these functions are not recursive, they both are used to recurse manually through all the submodules (albeit, in a different order than this function).

.. seealso::

  :func:`get_submodule_toplevels`

.. function:: get_submodule_toplevels

Get the path to the top-level directory of each submodule

Get the path to what git refers to as the top-level directory of the submodule; i.e., the absolute path to the top-level of the immediate superproject. For example, the vsi_common repository has a submodule at ``docker/recipes``. If the repository is cloned in ``/src``, then the top-level directory for the submodule docker/recipes is ``/src/vsi_common``.

This function, along with :func:`get_submodule_names`, could be used to, for example, cd to the top-level of each immediate superproject and then query the repository's submodule configuration using ``git config submodule.<name>.<key>``; e.g., ``git config submodule.docker/recipes.url``.

:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset
:Output: *stdout* - The top-level directory of each submodule (recursively); e.g., /src/vsi_common

.. note::

  This function iterates through each submodule in the same order as :func:`get_submodule_displaypaths`, :func:`get_submodule_urls` and :func:`get_submodule_names` (i.e., a depth-first traversal)

.. note::

  Because this function uses ``git submodule foreach``, it skips submodules that have been init'd but not updated.

.. seealso::

  :func:`get_submodule_names`

.. function:: create_repo_map

Create the contents of the repo_map.env file

Create the repository mapping such that, once the :var:`JUST_GIT_AIRGAP_MIRROR_URL` variable is defined, it can be sourced by :func:`git_mirror git_push_main` and :func:`git_mirror git_clone_main`.

:Argument: ``$1`` - The project's repository name (e.g., vsi_common)

:Parameters: [``ASSOCIATIVE_REPO_MAP``] - Set to a value to create the repo map as an associative-array, ``repos``, as opposed to two partitioned arrays (which is bash 3.2 compatible): ``repo_urls`` and ``repo_paths``. (Default: unset; i.e., partitioned)

:Output: *stdout* - The contents of the repo_map.env file. For example,

.. code-block:: bash

   # The urls are specified with the variable JUST_GIT_AIRGAP_MIRROR_URL,
   # which must be set to the mirrored repositories' new location on the
   # air-gapped git server. Delay setting this variable until the archive has
   # been moved to the destination in case the information must be controlled
   JUST_GIT_AIRGAP_MIRROR_URL=

   repo_paths=(
     ./
     ./docker/recipes
   )
   repo_urls=(
     "${JUST_GIT_AIRGAP_MIRROR_URL}/vsi_common.git"
     "${JUST_GIT_AIRGAP_MIRROR_URL}/recipes.git"
   )

If, for example, :var:`JUST_GIT_AIRGAP_MIRROR_URL` was set to ``https://git-server/projectA``, these urls would expand to:

  - ``https://git-server/projectA/vsi_common.git``
  - ``https://git-server/projectA/recipes.git``

.. note::

  The user can override this function if it does not suit her needs

.. var:: JUST_GIT_AIRGAP_MIRROR_URL

A variable used in the repo_map.env file created by :func:`create_repo_map` to specify the mirrored repositories' new location on the air-gapped git server

.. function:: orphan_commit_repo_map

Orphan commit the repo_map.env file

Given a repository mapping like the one produced by :func:`create_repo_map`, make an orphan commit in the repository (on a branch named __just_git_mirror_info_file by default) to a file named repo_map.env.

:Arguments: - ``$1`` - The contents of the repo_map.env file; i.e., the file that maps between the submodule's path and its new URL
            - [``$2``] - The name of the branch on which to make the orphan commit. Default: __just_git_mirror_info_file

.. function:: add_import-repo_just_project

Create a simple just project in the prep_dir

This function creates a simple just project (a README.md, setup.env, and Justfile that includes this plugin) in the air-gapped mirror cache (the prep_dir) created by the ``git_export-repo`` ``just`` target. This just project can be used to push (aka import) the mirrored repositories to their respective air-gapped git server by using the ``git_import-repo`` ``just`` target.

:Arguments: ``$1`` - The output directory (prep_dir) that caches the mirrored repositories and archive to be transferred

:Output: ``${1}/{README.md,setup.env,Justfile}``

.. function:: submodule-helper-relative-url

Essentially ``git submodule--helper relative-url`` (if it existed)

Resolve a submodule's relative URL based on the parent URL. This function works by creating a dummy git repository and submodule and then running ``git submodule init`` (which runs a process similar to ``git submodule sync``), after which, the resolved URL can be queried with ``git config submodule.submod.url``. We do this to avoid modifying the existing repository's git configuration (e.g., ``git config submodule.docker/recipes.url``).

:Arguments: * ``$1`` - URL of the parent repository; e.g., ``git config remote.origin.url``
            * ``$2`` - A relative submodule URL---typically from the .gitmodules file; e.g., ``git config -f .gitmodules submodule.docker/recipes.url``
            * [``$3``] - Up path: path from the submodule to the parent repository; e.g., ``../../``. Must have a trailing slash. (Not strictly necessary if ``$1`` is an absolute path)

:Output: *stdout* - Resolved URL

.. note::

  This is essentially a bash port of the function `relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L117>`_ (called from `resolve_relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L180>`_, aka ``git submodule--helper resolve-relative-url``, which itself is called from `cmd_sync() <https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L1014>`_, aka ``git submodule sync``. ``git submodule--helper resolve-relative-url``, which is available in git 2.9 and after, does not allow us to specify (directly) the remote URL from which to resolve a relative URL: it resolves relative URLs based on the remote URL, ``git config remote.${remote_name}.url``, where remote_name is the default remote of the current branch, if set; otherwise origin.

.. function:: git_sync_submodules

``git submodule sync`` but using a specific remote (``just_upstream`` by default)

Like ``git submodule sync``, synchronize the configured URL of each submodule in a repository (recursively) to the value specified in .gitmodules; however, instead of overwriting the default remote (origin), update the remote specified by JUST_GIT_UPSTREAM (``just_upstream`` by default).

:Arguments: [``$1``] - The project-repository's remote. Default: origin
:Parameters: - [``JUST_GIT_UPSTREAM``] - The submodules' remote to sync. When updating the URL in the submodules' configuration, use this remote. Default: ``just_upstream``
:Parameters: [``RECURSIVE``] - Should the submodules be iterated through recursively. Default: unset

.. note::

  Creates the just_upstream remote just like, and using the same procedure as, :func:`just_git_functions.bsh safe_git_submodule_update`; however, importantly, it does not try to update the submodule to the expected SHA.

.. function:: check_submodules_are_pushed_recursively

Ensure all submodules have pushed the necessary changes to their public repo

Check each submodule (recursively) to see if the SHA tracked by its parent repository has been pushed to the URL tracked by the parent repository (per its .gitmodules file). Must be run from the root of a repository.

:Parameters: - [``JUST_GIT_UPSTREAM``] - The submodule's remote to sync. When fetching, use this remote's URL. Default: ``just_upstream``

:Output: Return 0 if, for each submodule (recursively), the changes tracked by the parent repository have been made public; otherwise, return 1

.. note::

  Creates a JUST_GIT_UPSTREAM remote. See :func:`git_sync_submodules`.

.. note::

  Cf. ``git push --recurse-submodules=check`` (available since git 1.8.0) will check for unpushed commits in a submodule for its current committed state in the parent project. However, this only seems to work if it is used with a set of outgoing commits that contains a change to a submodule. And, despite its name, it does not seem to recurse into submodules.

.. function:: relocate_git_defaultify

Git relocate plugin for just

