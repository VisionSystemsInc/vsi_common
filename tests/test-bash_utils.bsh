#!/usr/bin/env bash

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
fi

source "${VSI_COMMON_DIR}/tests/testlib.bsh"
source "${TESTLIB_DIR}/test_utils.bsh"
source "${VSI_COMMON_DIR}/linux/bash_utils.bsh"
source "${VSI_COMMON_DIR}/linux/string_tools.bsh"
source "${VSI_COMMON_DIR}/linux/quotemire"

function clean_trace()
{
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -lt "41" ]; then
    set +xv
  fi
}

begin_test "Print stack trace"
(
  setup_test

  function foo()
  {
    bar
  }
  function bar()
  {
    print_bash_stack
  }

  nl=$'\n'

  tb="$(clean_trace; bar 2>&1)"
  assert_starts_with "${tb}" "Call stack"
  assert_regex_eq "${tb}" "${nl}"'1\. bar\(\) *:[0-9]* *'"$(regex_escape "${BASH_SOURCE[0]}")"

  tb="$(clean_trace; set +xv; foo 2>&1)"
  assert_starts_with "${tb}" "Call stack"
  assert_regex_eq "${tb}" "${nl}"'1\. bar\(\) *:[0-9]* *'"$(regex_escape "${BASH_SOURCE[0]}")"
  assert_regex_eq "${tb}" "${nl}"'2\. foo\(\) *:[0-9]* *'"$(regex_escape "${BASH_SOURCE[0]}")"
)
end_test

if not command -v script >& /dev/null; then
  skip_next_test
fi

begin_test "RC File insertion"
(
  setup_test

  session="${TRASHDIR////}"

  stdin="$(quotemire "set -xv; touch" \
                       "${TESTDIR}/bar")"

  # Got too complicated, use quotemire
  cmd="$(quotemire "source '${VSI_COMMON_DIR}/linux/bash_utils.bsh'; run_bash_rc_file" \
                     "set -xv; touch" \
                       "${TESTDIR}/foo")"

  # macOS/BSD script doesn't have the --version flag, and has different behavior than linux
  if script --version &> /dev/null; then
    cmd="$(quotemire "bash -c " "${cmd}")"
    echo "${stdin}" | script -q -c "${cmd}" /dev/null
  else
    echo "${stdin}; exit" | script -q /dev/null bash -c "${cmd}"
  fi

  # there's a bug in script 2.23.2 that is not there in 2.24, where it gets all
  # weird as soon as you pipe into stdin, which is sort of the point here. It
  # appears to run in the background (and then hang). But at least we can make
  # this test pass by waiting for the file to be created.
  for ((x=0; x<100; x++)); do
    if [ -f "${TESTDIR}/bar" ]; then
      break
    fi
    sleep 0.01
  done

  [ -f "${TESTDIR}/foo" ]
  [ -f "${TESTDIR}/bar" ]
)
end_test
