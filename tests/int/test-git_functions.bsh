#!/usr/bin/env bash

if [ -z "${VSI_COMMON_DIR+set}" ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"
fi

source "${VSI_COMMON_DIR}/tests/testlib.bsh"
source "${VSI_COMMON_DIR}/tests/test_utils.bsh"
source "${VSI_COMMON_DIR}/linux/aliases.bsh"
command -v "${GIT}" &> /dev/null && source "${VSI_COMMON_DIR}/linux/git_functions.bsh"
source "${VSI_COMMON_DIR}/linux/real_path"
source "${VSI_COMMON_DIR}/linux/compat.bsh"

# These tests chain together, so no point in continuing after one breaks
TESTLIB_STOP_AFTER_FAILS=1
unset TESTLIB_SKIP_TESTS TESTLIB_RUN_SINGLE_TEST

if ! command -v "${GIT}" &> /dev/null; then
  TESTLIB_SKIP_TESTS='.*'
fi

function setup()
{
  # Easier way to take care of committers on vanilla install
  export GIT_COMMITTER_NAME='Foo Bar'
  export GIT_AUTHOR_NAME='Foo Bar'
  export GIT_COMMITTER_EMAIL='foo.bar@example.com'
  export GIT_AUTHOR_EMAIL='foo.bar@example.com'

  mkdir -p "${TESTDIR}/default_branch"
  pushd "${TESTDIR}/default_branch" &> /dev/null
    git init . &> /dev/null
    touch file
    git add file &> /dev/null
    git commit -m "Initial commit" &> /dev/null
    export GIT_DEFAULT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  popd &> /dev/null
}

function setup_variables()
{
  PRETEND_URL="${TRASHDIR}/git/pretend_repo.git" # bare repo
  BUILD_REPO="${TRASHDIR}/build"

  mkdir -p "${PRETEND_URL}"
  mkdir -p "${BUILD_REPO}"
}

begin_test "Check for unpushed tracked commits in submodules"
(
  setup_test

  ##################################
  #              SETUP             #
  ##################################

  BUILD_REPO="${TESTDIR}"/build_repo
  SYNC_REPO="${TESTDIR}"/sync_repo
  PRETEND_URL="${TESTDIR}/git/pretend_repo" # bare repo
  # Test if git supports difficult submodule paths
  if git_bug_submodule_path_with_special_characters; then
    DIFFICULT_PATH='ext/diff  i cult'
  else
    DIFFICULT_PATH=$'ext/diff  i \t cult'
  fi
  DIFFICULT_NAME='difficult submod'

  ENCLOSING_REPO="${TESTDIR}"/enclosing
  SEPARATE_REPO="${ENCLOSING_REPO}"/separate
  SEPARATE_GITDIR="${TESTDIR}"/separate.git

  # Sub sub module
  mkdir -p "${BUILD_REPO}_sub_sub"
  pushd "${BUILD_REPO}_sub_sub" &> /dev/null
    git init .
    touch readme_sub_sub
    git add readme_sub_sub
    git commit -m "Initial commit"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL}_sub_sub"
  pushd "${PRETEND_URL}_sub_sub" &> /dev/null
    # This only works right because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${BUILD_REPO}_sub_sub" .
    # git init --bare .
    # cd "${BUILD_REPO}_sub_sub"
    # git remote add origin "${PRETEND_URL}_sub_sub"
    # git push origin --mirror
  popd &> /dev/null

  # Sub module
  mkdir -p "${BUILD_REPO}_sub"
  pushd "${BUILD_REPO}_sub" &> /dev/null
    git init .
    touch readme_sub
    git add readme_sub
    git submodule add "${PRETEND_URL}_sub_sub" "a_sub_sub_module"
    git commit -m "Initial commit"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL}_sub"
  pushd "${PRETEND_URL}_sub" &> /dev/null
    git clone --mirror "${BUILD_REPO}_sub" .
    # git init --bare .
    # cd "${BUILD_REPO}_sub"
    # git remote add origin "${PRETEND_URL}_sub"
    # git push origin --mirror
  popd &> /dev/null

  # Main Repo

  # sm_path (sm_name, if different)              URL
  # ./                                           "${PRETEND_URL}"
  # ./"${DIFFICULT_PATH}" ("${DIFFICULT_NAME}")  "${PRETEND_URL}_sub"
  # ./"${DIFFICULT_PATH}/a_sub_sub_module"       "${PRETEND_URL}_sub_sub"
  # ./another_sub_module                         "${PRETEND_URL}_sub_sub" (in SYNC_REPO)
  #
  # NOTE each repo is created in a respective ${BUILD_REPO}"_* repo and mirror
  # pushed to "${PRETEND_URL}"_*

  mkdir -p "${PRETEND_URL}"
  pushd "${PRETEND_URL}" &> /dev/null
    git init --bare .
  popd &> /dev/null
  mkdir -p "${BUILD_REPO}"
  pushd "${BUILD_REPO}" &> /dev/null
    git init
    touch readme
    mkdir subdir
    touch subdir/a_file
    git add readme subdir/a_file
    git commit -m "Initial commit"
    # REVIEW Make this a relative URL and the submodule a relative URL as well
    # RE I think this only matters in submodule-helper-relative-url, which is
    # tested (with relative URLs) separately below
    git remote add origin "${PRETEND_URL}"
    git push origin "${GIT_DEFAULT_BRANCH}"

    git submodule add --name "${DIFFICULT_NAME}" "${PRETEND_URL}_sub" "${DIFFICULT_PATH}"
    # Git itself can't handle newlines, although the config file actually can
    # escape them. This is a PURE git bug, plain and simple.
    # This won't actually create a newline in the name, it just ignores it
    # git submodule add https://github.com/visionsystemsinc/vsi_common $'  foo\tar\n'
    # This will.
    # git mv $'  diff  i \t cult' $' \n diff  i \t cult'
    # However, at random this gives permission denied errors, good thing I don't need it...
    git submodule update --init --recursive
    git commit -m "Added submodules"

    pushd "${DIFFICULT_PATH}" &> /dev/null
      pushd a_sub_sub_module &> /dev/null
        git checkout "${GIT_DEFAULT_BRANCH}"
        mkdir subdir
        touch subdir/a_sub_sub_file
        git add subdir/a_sub_sub_file
        git commit -m "Second commit"
      popd &> /dev/null

      git add a_sub_sub_module
      git commit -m "Update (sub) sub module"
    popd &> /dev/null

    git add "${DIFFICULT_PATH}"
    git commit -m "Updated submodules"
  popd &> /dev/null

  # Use this repo to test git_submodule_sync
  cp -a "${BUILD_REPO}" "${SYNC_REPO}"
  pushd "${SYNC_REPO}" &> /dev/null
    git submodule add "${PRETEND_URL}_sub_sub" another_sub_module
    git commit -m "Add another submodule"
  popd &> /dev/null


  # Create another repo hierarchy, similar to the first, but with a separate
  # git dir and inside another git repo

  mkdir -p "${ENCLOSING_REPO}"
  pushd "${ENCLOSING_REPO}" &> /dev/null
    git init .
    touch readme
    git add readme
    git commit -m "Initial commit"
  popd &> /dev/null

  mkdir -p "${SEPARATE_REPO}"
  pushd "${SEPARATE_REPO}" &> /dev/null
    git init --separate-git-dir "${SEPARATE_GITDIR}" .
    touch readme
    mkdir subdir
    touch subdir/a_file
    git add readme subdir/a_file
    git commit -m "Initial commit"

    git submodule add --name "${DIFFICULT_NAME}" "${PRETEND_URL}_sub" "${DIFFICULT_PATH}"
    git submodule update --init --recursive
    git commit -m "Added submodules"
    # subdir doesn't actually have to be tracked by the repo
    mkdir -p "${DIFFICULT_PATH}"/a_sub_sub_module/subdir
  popd &> /dev/null

  #################################
  #              TEST             #
  #################################

  # This doesn't really belong in this test but submodules are such a pain to
  # setup and the next test, git functionality, doesn't have submodules
  pushd "${BUILD_REPO}" &> /dev/null
    # Verify the listing of the submodule paths
    assert_str_eq "$(git_submodule_displaypaths)" "${DIFFICULT_PATH}"
    ans="$(printf "${DIFFICULT_PATH}\n${DIFFICULT_PATH}/a_sub_sub_module")"
    assert_str_eq "$(git_submodule_displaypaths_recursive)" "${ans}"

    # Test in a subdir
    assert_str_eq "$(cd subdir && git_submodule_displaypaths)" "../${DIFFICULT_PATH}"
    ans="$(printf "../${DIFFICULT_PATH}\n../${DIFFICULT_PATH}/a_sub_sub_module")"
    assert_str_eq "$(cd subdir && git_submodule_displaypaths_recursive)" "${ans}"

    # Test in a subdir that is in the path to the submodule (e.g., external and
    # external/vsi_common)
    assert_test "$(basename "${DIFFICULT_PATH}")" != "$(dirname "${DIFFICULT_PATH}")"
    ans="$(basename "${DIFFICULT_PATH}")"
    assert_str_eq "$(cd "$(dirname "${DIFFICULT_PATH}")" && git_submodule_displaypaths)" "${ans}"
    ans="$(printf "$(basename "${DIFFICULT_PATH}")\n$(basename "${DIFFICULT_PATH}")/a_sub_sub_module")"
    assert_str_eq "$(cd "$(dirname "${DIFFICULT_PATH}")" && git_submodule_displaypaths_recursive)" "${ans}"

    # Test in a submodule
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_displaypaths)" "a_sub_sub_module"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_displaypaths_recursive)" "a_sub_sub_module"

    # Test in a repo with no submodules
    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_displaypaths)"
    assert_str_eq "${output}" ""
    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_displaypaths_recursive)"
    assert_str_eq "${output}" ""

    # Verify the listing of the submodule URLs
    assert_str_eq "$(git_submodule_urls)" "${PRETEND_URL}_sub"
    ans="$(printf "${PRETEND_URL}_sub\n${PRETEND_URL}_sub_sub")"
    assert_str_eq "$(git_submodule_urls_recursive)" "${ans}"

    assert_str_eq "$(cd subdir && git_submodule_urls)" "${PRETEND_URL}_sub"
    ans="$(printf "${PRETEND_URL}_sub\n${PRETEND_URL}_sub_sub")"
    assert_str_eq "$(cd subdir && git_submodule_urls_recursive)" "${ans}"

    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_urls)" "${PRETEND_URL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_urls_recursive)" "${PRETEND_URL}_sub_sub"

    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_urls)"
    assert_str_eq "${output}" ""
    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_urls_recursive)"
    assert_str_eq "${output}" ""

    # Verify the listing of the submodule names
    assert_str_eq "$(git_submodule_names)" "${DIFFICULT_NAME}"
    ans="$(printf "${DIFFICULT_NAME}\na_sub_sub_module")"
    assert_str_eq "$(git_submodule_names_recursive)" "${ans}"

    assert_str_eq "$(cd subdir && git_submodule_names)" "${DIFFICULT_NAME}"
    ans="$(printf "${DIFFICULT_NAME}\na_sub_sub_module")"
    assert_str_eq "$(cd subdir && git_submodule_names_recursive)" "${ans}"

    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_names)" "a_sub_sub_module"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git_submodule_names_recursive)" "a_sub_sub_module"

    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_names)"
    assert_str_eq "${output}" ""
    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_names_recursive)"
    assert_str_eq "${output}" ""

    # Verify the listing of the submodule top-levels
    assert_str_eq "$(real_path "$(git_submodule_toplevels)")" "$(real_path "${BUILD_REPO}")"
    assert_str_eq "$(cd subdir && real_path "$(git_submodule_toplevels)")" "$(real_path "${BUILD_REPO}")"

    expected=("$(real_path "${BUILD_REPO}")" "$(real_path "${BUILD_REPO}/${DIFFICULT_PATH}")")
    ans="$(printf '%s\n' "${expected[@]}")"
    output="$(git_submodule_toplevels_recursive | tr "\n" "\0" | xargs -0 -I {} -n 1 real_path {})"
    assert_str_eq "${output}" "${ans}"
    output="$(cd subdir && \
        git_submodule_toplevels_recursive | tr "\n" "\0" | xargs -0 -I {} -n 1 real_path {})"
    assert_str_eq "${output}" "${ans}"

    output="$(cd "${DIFFICULT_PATH}" && real_path "$(git_submodule_toplevels)")"
    assert_str_eq "${output}" "$(real_path "${BUILD_REPO}/${DIFFICULT_PATH}")"
    output="$(cd "${DIFFICULT_PATH}" && real_path "$(git_submodule_toplevels_recursive)")"
    assert_str_eq "${output}" "$(real_path "${BUILD_REPO}/${DIFFICULT_PATH}")"

    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_toplevels)"
    assert_str_eq "${output}" ""
    output="$(cd "${DIFFICULT_PATH}/a_sub_sub_module" && git_submodule_toplevels_recursive)"
    assert_str_eq "${output}" ""
  popd &> /dev/null


  # Test git_submodule_sync
  # NOTE submodule-helper-relative-url is tested below
  pushd "${SYNC_REPO}" &> /dev/null
    # (Don't change git config remote.origin.url here)
    git config submodule."${DIFFICULT_NAME}".url "${PRETEND_URL}_sub1"
    pushd "${DIFFICULT_PATH}" &> /dev/null
      git config remote.origin.url "${PRETEND_URL}_sub1"
      git config submodule.a_sub_sub_module.url "${PRETEND_URL}_sub_sub1"
    popd &> /dev/null
    pushd "${DIFFICULT_PATH}/a_sub_sub_module" &> /dev/null
      git config remote.origin.url "${PRETEND_URL}_sub_sub1"
    popd &> /dev/null
    git submodule sync --recursive

    if [ "${OS-}" = "Windows_NT" ]; then
      PRETEND_URL_INTERNAL="$(cygpath -m "${PRETEND_URL}")"
    else
      PRETEND_URL_INTERNAL="${PRETEND_URL}"
    fi
    # Test the default configuration is correct (absolute paths)
    assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}"
    assert_str_eq "$(git config submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(git config submodule.another_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config submodule.a_sub_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd another_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
  popd &> /dev/null

  cp -a "${SYNC_REPO}" "${SYNC_REPO}_0"
  pushd "${SYNC_REPO}_0" &> /dev/null
    git submodule add "${PRETEND_URL}_sub_sub" a_third_sub_module
    git commit -m "Add a third submodule"

    # Test specifying submodules
    git_submodule_sync origin "${DIFFICULT_PATH}" another_sub_module
    assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}"
    assert_str_eq "$(git config submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(git config submodule.another_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(git config submodule.a_third_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd another_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd a_third_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd another_sub_module && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null
    pushd a_third_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null

    # Test in a repository with no submodules
    pushd "${DIFFICULT_PATH}/a_sub_sub_module" &> /dev/null
      git_submodule_sync_recursive # This shouldn't die
      not git config remote.just_upstream.url
    popd &> /dev/null

    # Test specifying a path that is not a submodule
    not git_submodule_sync origin bad_path
  popd &> /dev/null

  cp -a "${SYNC_REPO}" "${SYNC_REPO}_1"
  pushd "${SYNC_REPO}_1/subdir" &> /dev/null
    # Test specifying a (display)path
    git_submodule_sync origin ../"${DIFFICULT_PATH}"
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd ../"${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    pushd ../"${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null
    pushd ../another_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null
  popd &> /dev/null

  cp -a "${SYNC_REPO}" "${SYNC_REPO}_2"
  pushd "${SYNC_REPO}_2" &> /dev/null
    # Test non-recursively
    git_submodule_sync
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd another_sub_module && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null
  popd &> /dev/null

  cp -a "${SYNC_REPO}" "${SYNC_REPO}_3"
  pushd "${SYNC_REPO}_3" &> /dev/null
    # Test specifying a submodule and recursive
    git_submodule_sync_recursive origin "${DIFFICULT_PATH}"
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    pushd another_sub_module &> /dev/null
      not git config remote.just_upstream.url
    popd &> /dev/null
  popd &> /dev/null

  cp -a "${SYNC_REPO}" "${SYNC_REPO}_4"
  pushd "${SYNC_REPO}_4" &> /dev/null
    #        submod
    #      abs rel url
    # abs  1   4   7
    # rel  2   5   8
    # url  3   6   9
    # Tests 4, 5, and 6 depend on the parent repository; the rest should not

    # Test the default configuration is still correct (just_upstream == origin)
    git_submodule_sync_recursive
    assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}"
    assert_str_eq "$(git config submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
      git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config submodule.a_sub_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"

    # 1) Test abs remote and abs submodule (for a specified remote)
    git remote add upstream "${PRETEND_URL}"
    # Change origin's URL so we can tell if we are using the wrong remote
    # NOTE These paths don't have to resolve
    git remote set-url origin "${PRETEND_URL}_origin"
    pushd "${DIFFICULT_PATH}" &> /dev/null
      git remote set-url origin "${PRETEND_URL}_origin_sub"
    popd &> /dev/null
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      git remote set-url origin "${PRETEND_URL}_origin_sub_sub"
    popd &> /dev/null
    git_submodule_sync_recursive upstream
    # Test the default configuration is still correct
    assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_origin"
    assert_str_eq "$(git config submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_origin_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config submodule.a_sub_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_origin_sub_sub"
    # Test the upstream configuration is still correct
    assert_str_eq "$(git config remote.upstream.url)" "${PRETEND_URL_INTERNAL}"
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"

    # 2) Test relative remote and abs submodule
    git remote set-url upstream "../$(basename "${PRETEND_URL}")"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"

    # 3) Test URL remote and abs submodule
    git remote set-url upstream "https://git-server.com/org/repo.git"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_sub"


    # 4) Test an abs remote and relative submodule
    git remote set-url upstream "${PRETEND_URL}"
    cp .gitmodules .gitmodules.bak
    sed "${sed_flags_i[@]}" -e \
         "s|url = ${PRETEND_URL_INTERNAL}_sub|url = ../$(basename "${PRETEND_URL}_rel_sub")|" .gitmodules
    git add .gitmodules
    git commit -m "update .gitmodules"
    git_submodule_sync_recursive upstream
    # Test the just_upstream configuration is correct
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "${PRETEND_URL_INTERNAL}_rel_sub"

    # 5) Test relative remote and relative submodule
    git remote set-url upstream "../$(basename "${PRETEND_URL_INTERNAL}")"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "../../../$(basename "${PRETEND_URL}_rel_sub")"

    # 6) Test URL remote and relative submodule
    git remote set-url upstream "https://git-server.com/org/repo.git"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && git config remote.just_upstream.url)" \
        "https://git-server.com/org/$(basename "${PRETEND_URL}_rel_sub")"


    # 7) Test abs remote and URL submodule
    git remote set-url upstream "${PRETEND_URL}"
    cp .gitmodules.bak .gitmodules
    sed "${sed_flags_i[@]}" -e \
         "s|url = ${PRETEND_URL_INTERNAL}_sub|url = https://git-server.com/org/submod.git|" .gitmodules
    git add .gitmodules
    git commit -m "update .gitmodules"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "https://git-server.com/org/submod.git"

    # 8) Test relative remote and URL submodule
    git remote set-url upstream "../$(basename "${PRETEND_URL}")"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "https://git-server.com/org/submod.git"

    # 9) Test URL remote and URL submodule
    git remote set-url upstream "https://git-server.com/org/repo.git"
    git_submodule_sync_recursive upstream
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.just_upstream.url)" "https://git-server.com/org/submod.git"
  popd &> /dev/null

  pushd "${SYNC_REPO}" &> /dev/null
    # Customize the remote name and ensure no other remotes get modified
    git remote set-url origin "https://git-server.com/org/repo1.git"
    # Set these remotes to something other than what is in the .gitmodules file
    pushd "${DIFFICULT_PATH}" &> /dev/null
      git remote add just_upstream "https://lab-server.com/org/submod1.git"
    popd &> /dev/null
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      git remote add just_upstream "https://lab-server.com/org/subsubmod.git"
    popd &> /dev/null
    sed "${sed_flags_i[@]}" -e \
        "s|url = ${PRETEND_URL_INTERNAL}_sub|url = https://git-server.com/org/submod2.git|" .gitmodules
    git add .gitmodules
    git commit -m "update .gitmodules"

    JUST_GIT_UPSTREAM=foo_upstream git_submodule_sync_recursive
    assert_str_eq "$(cd "${DIFFICULT_PATH}" && \
        git config remote.foo_upstream.url)" "https://git-server.com/org/submod2.git"
    assert_str_eq "$(cd "${DIFFICULT_PATH}"/a_sub_sub_module && \
        git config remote.foo_upstream.url)" "${PRETEND_URL_INTERNAL}_sub_sub"

    # Test the other configurations are still correct
    assert_str_eq "$(git config remote.origin.url)" "https://git-server.com/org/repo1.git"
    assert_str_eq "$(git config submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
    pushd "${DIFFICULT_PATH}" &> /dev/null
      assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub"
      assert_str_eq "$(git config remote.just_upstream.url)" "https://lab-server.com/org/submod1.git"
      assert_str_eq "$(git config submodule.a_sub_sub_module.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
    popd &> /dev/null
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
        assert_str_eq "$(git config remote.origin.url)" "${PRETEND_URL_INTERNAL}_sub_sub"
        assert_str_eq "$(git config remote.just_upstream.url)" "https://lab-server.com/org/subsubmod.git"
    popd &> /dev/null
  popd &> /dev/null


  # Test git_submodule_is_published_recursive
  expected1="WARNING The commit tracked by the parent repository of the
submodule, '${DIFFICULT_NAME}', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL_INTERNAL}_sub

WARNING The commit tracked by the parent repository of the
submodule, 'a_sub_sub_module', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL_INTERNAL}_sub_sub" # NOTE there is actually a trailing newline here...

  expected2="WARNING The commit tracked by the parent repository of the
submodule, 'a_sub_sub_module', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL_INTERNAL}_sub_sub" # NOTE there is actually a trailing newline here...

  pushd "${BUILD_REPO}" &> /dev/null
    rv=0
    output="$(git_submodule_is_published_recursive)" || rv="${?}"
    assert_test "${rv}" -eq "1"
    assert_str_eq "${output}" "${expected1}"

    # Push the changes to the submodule
    pushd "${DIFFICULT_PATH}" &> /dev/null
      git push origin "${GIT_DEFAULT_BRANCH}"
    popd &> /dev/null
    rv=0
    output="$(git_submodule_is_published_recursive)" || rv="${?}"
    assert_test "${rv}" -eq "1"
    assert_str_eq "${output}" "${expected2}"

    # Push the changes to the sub submodule
    pushd "${DIFFICULT_PATH}"/a_sub_sub_module &> /dev/null
      git push origin "${GIT_DEFAULT_BRANCH}"
    popd &> /dev/null
    output="$(git_submodule_is_published_recursive)"
    assert_str_eq "${output}" ""

    # NOTE We are not testing whether whether the top-level repo has unpushed
    # changes for a given remote & branch; log_unpushed_commits is used to
    # test for this. See the next section, git functionality
  popd &> /dev/null

  # A repo with no submodules
  pushd "${BUILD_REPO}_sub_sub" &> /dev/null
    output="$(git_submodule_is_published_recursive)"
    assert_str_eq "${output}" ""
  popd &> /dev/null


  # This doesn't really belong in this test but submodules are such a pain to
  # setup and the next test, git functionality, doesn't have submodules
  # Test git_project_root_dir
  ans="$(real_path "${BUILD_REPO}")"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${BUILD_REPO}" && real_path "$(git_project_root_dir)")" "${ans}"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${BUILD_REPO}"/subdir && real_path "$(git_project_root_dir)")" "${ans}"
  assert_str_eq "$(cd "${BUILD_REPO}/${DIFFICULT_PATH}"/a_sub_sub_module/subdir && \
      real_path "$(git_project_root_dir)")" "${ans}"

  ans="$(real_path "${SEPARATE_REPO}")"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${SEPARATE_REPO}" && real_path "$(git_project_root_dir)")" "${ans}"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${SEPARATE_REPO}"/subdir && real_path "$(git_project_root_dir)")" "${ans}"
  assert_str_eq "$(cd "${SEPARATE_REPO}/${DIFFICULT_PATH}"/a_sub_sub_module/subdir && \
      real_path "$(git_project_root_dir)")" "${ans}"


  # Test git_project_git_dir
  ans="$(real_path "${BUILD_REPO}/.git")"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${BUILD_REPO}" && real_path "$(git_project_git_dir)")" "${ans}"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${BUILD_REPO}"/subdir && real_path "$(git_project_git_dir)")" "${ans}"
  assert_str_eq "$(cd "${BUILD_REPO}/${DIFFICULT_PATH}"/a_sub_sub_module/subdir && \
      real_path "$(git_project_git_dir)")" "${ans}"

  # Test from within a repo with a separate .git directory
  ans="$(real_path "${SEPARATE_GITDIR}")"
  # needed by macOS to deal with /var/... and /private/var/...
  assert_str_eq "$(cd "${SEPARATE_REPO}" && real_path "$(git_project_git_dir)")" "${ans}"

  # Test from within a bare repo
  ans="$(real_path "${PRETEND_URL}")"
  assert_str_eq "$(cd "${PRETEND_URL}" && real_path "$(git_project_git_dir)")" "${ans}"
  assert_str_eq "$(cd "${PRETEND_URL}/hooks" && real_path "$(git_project_git_dir)")" "${ans}"

  # Test from within a .git directory
  ans="$(real_path "${BUILD_REPO}/.git")"
  assert_str_eq "$(cd "${BUILD_REPO}/.git" && real_path "$(git_project_git_dir)")" "${ans}"
  # Test from within a subdirectory of a .git directory
  assert_str_eq "$(cd "${BUILD_REPO}/.git/objects" && real_path "$(git_project_git_dir)")" "${ans}"
  # Test from within a sub-submodule of a .git directory (.git/modules/...)
  assert_str_eq "$(cd "${BUILD_REPO}/.git/modules/${DIFFICULT_NAME}/modules/a_sub_sub_module" && \
      real_path "$(git_project_git_dir)")" "${ans}"

  # Test from within the separate .git directory
  ans="$(real_path "${SEPARATE_GITDIR}")"
  assert_str_eq "$(cd "${SEPARATE_GITDIR}" && real_path "$(git_project_git_dir)")" "${ans}"
  # Test from within a sub-submodule of a separate .git directory
  # (separate_git/modules/...)
  assert_str_eq "$(cd "${SEPARATE_GITDIR}/modules/${DIFFICULT_NAME}/modules/a_sub_sub_module" && \
      real_path "$(git_project_git_dir)")" "${ans}"
)
end_test

begin_test "git functionality"
(
  setup_test

  ##################################
  #              SETUP             #
  ##################################

  # git log --pretty=format:"%s%d" --graph --all
  # * Eleventh commit (HEAD -> tracking_branchpoint)
  # * Tenth commit (up_master, master)
  # *   Merge branch 'nontracking_merge'
  # |\
  # | * Branching commit (nontracking_merge)
  # * | Ninth commit (upstream/master)
  # |/
  # | * Eighth commit (tracking_branch_ahead)
  # | * Seventh commit (nontracking_branch_ahead)
  # | * Sixth commit (origin/checkpoint, checkpoint)
  # |/
  # | * Tag commit (tag: v0.9)
  # |/
  # * Fourth commit (origin/tracking_branch_equal, origin/tracking_branch_ahead, origin/master, tracking_branch_equal, nontracking_branch_equal)
  # * Third commit (tracking_branch_behind)
  # * Second commit (nontracking_branch_behind)
  # * First commit (remote_tracking_branch_deleted)
  # * Initial commit
  #
  # git branch -vv
  #   checkpoint                     Sixth commit
  #   master                         [origin/master: ahead 4] Tenth commit
  #   nontracking_branch_ahead       Seventh commit
  #   nontracking_branch_behind      Second commit
  #   nontracking_branch_equal       Fourth commit
  #   nontracking_merge              Branching commit
  #   remote_tracking_branch_deleted [origin/remote_tracking_branch_deleted: gone] First commit
  # * tracking_branch_ahead          [origin/tracking_branch_ahead: ahead 3] Eighth commit
  #   tracking_branch_behind         [origin/master: behind 1] Third commit
  #   tracking_branch_equal          [origin/tracking_branch_equal] Fourth commit
  #   tracking_branchpoint           [origin/master: ahead 5] Eleventh commit
  #   up_master                      [upstream/master: ahead 3] Tenth commit

  BUILD_REPO="${TESTDIR}"/build_repo
  PRETEND_URL="${TESTDIR}/git/pretend_repo.git" # bare repo
  UPSTREAM_URL="${TESTDIR}/git/upstream_repo.git" # bare repo
  NO_REMOTE_REPO="${TESTDIR}/no_remotes"

  # Main repo
  mkdir -p "${PRETEND_URL}"
  pushd "${PRETEND_URL}" &> /dev/null
    git init --bare .
  popd &> /dev/null
  mkdir -p "${UPSTREAM_URL}"
  pushd "${UPSTREAM_URL}" &> /dev/null
    git init --bare .
  popd &> /dev/null
  mkdir -p "${BUILD_REPO}"
  pushd "${BUILD_REPO}" &> /dev/null
    git init .
    touch readme
    git add readme
    git commit -m "Initial commit"
    git remote add origin "${PRETEND_URL}"
    git remote add upstream "${UPSTREAM_URL}"
    git push origin "${GIT_DEFAULT_BRANCH}"
    git branch "${GIT_DEFAULT_BRANCH}" -u origin/"${GIT_DEFAULT_BRANCH}"

    echo "1" >> readme
    git add readme
    git commit -m "First commit"

    git checkout -b remote_tracking_branch_deleted
    git push -u origin remote_tracking_branch_deleted
    git push origin --delete remote_tracking_branch_deleted
    git checkout "${GIT_DEFAULT_BRANCH}"

    echo "2" >> readme
    git add readme
    git commit -m "Second commit"
    git branch nontracking_branch_behind

    echo "3" >> readme
    git add readme
    git commit -m "Third commit"
    git branch tracking_branch_behind
    git branch tracking_branch_behind -u origin/"${GIT_DEFAULT_BRANCH}"

    echo "4" >> readme
    git add readme
    git commit -m "Fourth commit"
    git branch nontracking_branch_equal
    git branch tracking_branch_equal
    git push -u origin tracking_branch_equal

    git push origin "${GIT_DEFAULT_BRANCH}"
    # create a remote-tracking branch, origin/tracking_branch_ahead, at
    # origin/master
    git push origin origin/"${GIT_DEFAULT_BRANCH}":refs/heads/tracking_branch_ahead

    git checkout -b checkpoint
    echo "6" >> readme
    git add readme
    git commit -m "Sixth commit"
    git push origin checkpoint # non-tracking branch

    echo "7" >> readme
    git checkout -b nontracking_branch_ahead
    git add readme
    git commit -m "Seventh commit"

    echo "8" >> readme
    git checkout -b tracking_branch_ahead
    git branch tracking_branch_ahead -u origin/tracking_branch_ahead
    git add readme
    git commit -m "Eighth commit"

    git checkout "${GIT_DEFAULT_BRANCH}"
    git checkout -b nontracking_merge
    echo "A" >> readme
    git add readme
    git commit -m "Branching commit"

    git checkout "${GIT_DEFAULT_BRANCH}"
    git checkout -b v0.9
    echo "version bump" >> readme
    git add readme
    git commit -m "Tag commit"
    git tag v0.9

    git checkout "${GIT_DEFAULT_BRANCH}"
    git branch -D v0.9
    echo "9" >> a_file
    git add a_file
    git commit -m "Ninth commit"
    git push upstream "${GIT_DEFAULT_BRANCH}"
    git merge nontracking_merge

    echo "10" >> readme
    git add readme
    git commit -m "Tenth commit"

    git checkout "${GIT_DEFAULT_BRANCH}"
    git branch "up_${GIT_DEFAULT_BRANCH}"
    git branch "up_${GIT_DEFAULT_BRANCH}" -u upstream/"${GIT_DEFAULT_BRANCH}"
    git checkout -b tracking_branchpoint
    git branch tracking_branchpoint -u origin/"${GIT_DEFAULT_BRANCH}"
    echo "11" >> readme
    git add readme
    git commit -m "Eleventh commit"
  popd &> /dev/null

  mkdir -p "${NO_REMOTE_REPO}"
  pushd "${NO_REMOTE_REPO}" &> /dev/null
    git init
    touch readme
    git add readme
    git commit -m "Initial commit"
  popd &> /dev/null

  #################################
  #              TEST             #
  #################################

  pushd "${NO_REMOTE_REPO}" &> /dev/null
    git_tracking_branches
    assert_test "${#vsi_git_tracking_branches[@]}" -eq "0"
    assert_test "${#vsi_git_remote_tracking_branches[@]}" -eq "0"

    # no remotes
    [[ $(log_unpushed_commits | head -n 1) = *"1 unpushed"* ]] || false

    # no outgoing commits - no remotes (or tracking branches)
    output="$(log_outgoing_commits)"
    assert_str_eq "${output}" ""
  popd &> /dev/null

  pushd "${BUILD_REPO}" &> /dev/null
    # list local tracking branches and their corresponding remote branch
    # NOTE remote_tracking_branch_deleted is a tracking branch, but the remote-
    # tracking branch has been deleted
    git_tracking_branches
    ans=(""${GIT_DEFAULT_BRANCH}"" "tracking_branch_ahead" "tracking_branch_behind" \
        "tracking_branch_equal" "tracking_branchpoint" "up_${GIT_DEFAULT_BRANCH}")
    assert_array_eq vsi_git_tracking_branches ans
    ans=("origin/"${GIT_DEFAULT_BRANCH}"" "origin/tracking_branch_ahead" "origin/"${GIT_DEFAULT_BRANCH}"" \
        "origin/tracking_branch_equal" "origin/"${GIT_DEFAULT_BRANCH}"" "upstream/"${GIT_DEFAULT_BRANCH}"")
    assert_array_eq vsi_git_remote_tracking_branches ans

    # specify a remote
    git_tracking_branches origin
    ans=(""${GIT_DEFAULT_BRANCH}"" "tracking_branch_ahead" "tracking_branch_behind" \
        "tracking_branch_equal" "tracking_branchpoint")
    assert_array_eq vsi_git_tracking_branches ans
    ans=("origin/"${GIT_DEFAULT_BRANCH}"" "origin/tracking_branch_ahead" "origin/"${GIT_DEFAULT_BRANCH}"" \
        "origin/tracking_branch_equal" "origin/"${GIT_DEFAULT_BRANCH}"")
    assert_array_eq vsi_git_remote_tracking_branches ans

    git_tracking_branches upstream
    ans=("up_${GIT_DEFAULT_BRANCH}")
    assert_array_eq vsi_git_tracking_branches ans
    ans=("upstream/"${GIT_DEFAULT_BRANCH}"")
    assert_array_eq vsi_git_remote_tracking_branches ans

    # specify a branch that has a tracking branch
    output="$(git_tracking_branch tracking_branch_behind)"
    assert_str_eq "${output}" "origin/"${GIT_DEFAULT_BRANCH}""
    output="$(git_tracking_branch "up_${GIT_DEFAULT_BRANCH}")"
    assert_str_eq "${output}" "upstream/"${GIT_DEFAULT_BRANCH}""

    # specify a branch that has a tracking branch that has been pruned
    output="$(git_tracking_branch remote_tracking_branch_deleted)"
    assert_str_eq "${output}" ""

    # specify a branch that does not have a tracking branch
    output="$(git_tracking_branch nontracking_branch_behind)"
    assert_str_eq "${output}" ""
  popd &> /dev/null


  pushd "${BUILD_REPO}" &> /dev/null
    # nothing unpushed - branch (non-tracking) behind origin/master
    output="$(log_unpushed_commits origin nontracking_branch_behind)"
    assert_str_eq "${output}" ""

    # no outgoing commits - tracking branch is behind its tracked branch, origin/master (a differently named branch)
    output="$(log_outgoing_commits tracking_branch_behind)"
    assert_str_eq "${output}" ""

    # nothing unpushed - branch (non-tracking) equal to origin/* (origin/master
    # in this case)
    output="$(log_unpushed_commits origin nontracking_branch_equal)"
    assert_str_eq "${output}" ""

    # no outgoing commits - tracking branch is equal to its tracked branch, origin/master (a differently named branch)
    output="$(log_outgoing_commits tracking_branch_equal)"
    assert_str_eq "${output}" ""

    # unpushed commits - branch (non-tracking) ahead of origin/*
    [[ $(log_unpushed_commits origin nontracking_branch_ahead | head -n 1) = *"1 unpushed"* ]] || false

    # unpushed commits - branch (non-tracking) ahead of upstream/*
    # (upstream/master in this case)
    [[ $(log_unpushed_commits upstream "${GIT_DEFAULT_BRANCH}" | head -n 1) = *"3 unpushed"* ]] || false

    # outgoing commits - non-tracking branch ahead of upstream/master
    [[ $(log_outgoing_commits "up_${GIT_DEFAULT_BRANCH}" | head -n 1) = *"3 outgoing"* ]] || false

    # unpushed commits - branch (tracking) is ahead of origin/*
    [[ $(log_unpushed_commits origin tracking_branch_ahead | head -n 1) = *"2 unpushed"* ]] || false

    # outgoing commits - tracking branch is ahead of its tracked branch, origin/master (a differently named branch)
    [[ $(log_outgoing_commits tracking_branch_ahead | head -n 1) = *"3 outgoing"* ]] || false

    # unpushed commits - branches (one tracking and one non-tracking) are both
    # ahead of origin/*
    [[ $(log_unpushed_commits origin tracking_branch_ahead nontracking_merge | head -n 1) = *"3 unpushed"* ]] || false

    # all unpushed commits
    [[ $(log_unpushed_commits | head -n 1) = *"7 unpushed"* ]] || false

    # all outgoing commits on origin
    [[ $(log_all_outgoing_commits origin | head -n 1) = *"8 outgoing"* ]] || false

    # all outgoing commits on upstream
    [[ $(log_all_outgoing_commits upstream | head -n 1) = *"3 outgoing"* ]] || false

    # all outgoing commits
    [[ $(log_all_outgoing_commits | head -n 1) = *"7 outgoing"* ]] || false
  popd &> /dev/null


  # Test submodule-helper-relative-url
  # NOTE git_submodule_sync is tested above
  assert_str_eq "$(submodule-helper-relative-url https://git-server.com/org/repo.git ../submod.git)" "https://git-server.com/org/submod.git"
  assert_str_eq "$(submodule-helper-relative-url /path/to/git/repo.git ../submod.git)" "/path/to/git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../submod.git)" "../../git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../../git/submod.git)" "../../git/submod.git"

  assert_str_eq "$(submodule-helper-relative-url https://git-server.com/org/repo.git ../submod.git ../)" \
      "https://git-server.com/org/submod.git"
  assert_str_eq "$(submodule-helper-relative-url /some/git/repo.git ../submod.git ../)" "/some/git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../submod.git ../)" "../../../git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../../git/submod.git ../)" "../../../git/submod.git"

  assert_str_eq "$(submodule-helper-relative-url https://git-server.com/org/repo.git ../submod.git ../../)" \
      "https://git-server.com/org/submod.git"
  assert_str_eq "$(submodule-helper-relative-url /some/git/repo.git ../submod.git ../../)" "/some/git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../submod.git ../../)" \
      "../../../../git/submod.git"
  assert_str_eq "$(submodule-helper-relative-url ../../git/repo.git ../../git/submod.git ../../)" \
      "../../../../git/submod.git"
)
end_test

begin_test "Make remote pushable"
(
  setup_test

  ##################################
  #              SETUP             #
  ##################################

  BUILD_REPO="${TESTDIR}"/build_repo
  PRETEND_URL="${TESTDIR}/git/pretend_repo" # bare repo
  # Test if git supports difficult submodule paths
  if git_bug_submodule_path_with_special_characters; then
    DIFFICULT_PATH='diff  i cult'
  else
    DIFFICULT_PATH=$'diff  i \t cult'
  fi
  DIFFICULT_NAME='difficult submod'

  # Sub module
  mkdir -p "${BUILD_REPO}_sub"
  pushd "${BUILD_REPO}_sub" &> /dev/null
    git init .
    touch readme_sub
    git add readme_sub
    git commit -m "Initial commit"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL}_sub"
  pushd "${PRETEND_URL}_sub" &> /dev/null
    git clone --mirror "${BUILD_REPO}_sub" .
    # git init --bare .
    # cd "${BUILD_REPO}_sub"
    # git remote add origin "${PRETEND_URL}_sub"
    # git push origin --mirror
  popd &> /dev/null

  # Main repo
  mkdir -p "${BUILD_REPO}"
  pushd "${BUILD_REPO}" &> /dev/null
    git init .
    touch readme
    git add readme
    git commit -m "Initial commit"

    git submodule add --name "${DIFFICULT_NAME}" "${PRETEND_URL}_sub" "${DIFFICULT_PATH}"
    git submodule update --init --recursive
    git commit -m "Added submodules"

    git remote add origin http://git-server.org/company/arepo.git
    git remote add upstream https://git1-server.org/company/arepo1.git
    git remote set-url --add upstream https://git2-server.org/company/arepo1.git
    git remote add pushconfig https://git3-server.org/company/arepo1.git
    git remote set-url --push pushconfig git@git3-server.org:company/arepo1.git

    pushd "${DIFFICULT_PATH}" &> /dev/null
      git remote set-url origin https://git-server.org/company/asubmod.git
      git remote add sm_upstream https://git1-server.org/company/asubmod1.git
    popd &> /dev/null
  popd &> /dev/null

  #################################
  #              TEST             #
  #################################

  pushd "${BUILD_REPO}" &> /dev/null
    convert_git_remote_http_to_git origin
    assert_str_eq "$(git config --get remote.origin.url)" "http://git-server.org/company/arepo.git"
    assert_str_eq "$(git config --get remote.origin.pushurl)" "git@git-server.org:company/arepo.git"
    assert_str_eq "$(git config --get remote.upstream.url)" "https://git2-server.org/company/arepo1.git"
    not git config --get remote.upstream.pushurl
    convert_git_remote_http_to_git upstream
    assert_str_eq "$(git config --get remote.upstream.url)" "https://git2-server.org/company/arepo1.git"
    assert_str_eq "$(git config --get remote.upstream.pushurl)" "git@git2-server.org:company/arepo1.git"
    # do nothing if a pushurl is configured
    convert_git_remote_http_to_git pushconfig
    assert_str_eq "$(git config --get remote.pushconfig.url)" "https://git3-server.org/company/arepo1.git"
    assert_str_eq "$(git config --get remote.pushconfig.pushurl)" "git@git3-server.org:company/arepo1.git"

    pushd "${DIFFICULT_PATH}" &> /dev/null
      convert_git_remote_http_to_git origin
      assert_str_eq "$(git config --get remote.origin.url)" "https://git-server.org/company/asubmod.git"
      assert_str_eq "$(git config --get remote.origin.pushurl)" "git@git-server.org:company/asubmod.git"
      convert_git_remote_http_to_git sm_upstream
      assert_str_eq "$(git config --get remote.sm_upstream.url)" "https://git1-server.org/company/asubmod1.git"
      assert_str_eq "$(git config --get remote.sm_upstream.pushurl)" "git@git1-server.org:company/asubmod1.git"
    popd &> /dev/null

    if [ "${OS-}" = "Windows_NT" ]; then
      PRETEND_URL_INTERNAL="$(cygpath -m "${PRETEND_URL}")"
    else
      PRETEND_URL_INTERNAL="${PRETEND_URL}"
    fi
    # ensure the submodule's configured path is not changed
    assert_str_eq "$(git config --get submodule."${DIFFICULT_NAME}".url)" "${PRETEND_URL_INTERNAL}_sub"
  popd &> /dev/null
)
end_test
