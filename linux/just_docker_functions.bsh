#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

JUST_DEFAULTIFY_FUNCTIONS+=(docker_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"

#*# just/plugins/docker/just_docker_functions

#**
# =========================
# J.U.S.T. Docker Functions
# =========================
#
# .. default-domain:: bash
#
# .. file:: just_docker_functions.bsh
#**

#**
# .. function:: docker-compose_restore_from_cache
#
# :Arguments: - ``$1`` - Docker-compose filename
#             - ``$2`` - Main service name to restore and rebuild. This needs to be the last (unnamed) stage
#             - ``[$3...]`` - Addition services based on same dockerfile to restore and rebuild
# :Parameters: - ``JUST_DOCKER_COMPOSE_CACHE_REPO`` - Default value: ``vsiri/ci_cache``
#              - ``JUST_DOCKER_COMPOSE_PULL`` - Pulls images to use. Default: 1 (true).
#              - ``JUST_DOCKER_COMPOSE_BUILD`` - Builds images after pulling cache. Default: 1 (true).
#              - ``JUST_DOCKER_COMPOSE_PUSH`` - Pushes images when done. Default: 1 (true).
#
# Restores image from cached images downloaded from the registry.
#
# This is done in three steps:
#
# 1. First, the images are pull from ``JUST_DOCKER_COMPOSE_CACHE_REPO``, if available.
# 2. Next, the images are built against the dockerfiles using the downloaded cache.
# 3. Lastly, the images are pushed back to ``JUST_DOCKER_COMPOSE_CACHE_REPO`` to keep them up to date.
#
# - Every stage is backed up, as long as they are given a name. They must have a name, or they cannot be targeted using the ``docker`` cli or ``docker-compose``. These stages are named: ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:${main_service_name}_${stage_name}``
# - The final stage is tagged as: ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${main_service_name}``
# - Any VSI recipes used are also identified, and tagged: ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:recipe_${main_service_name}_${recipe_name}``. The recipes contain "ONBUILD" commands that are different images than the ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:${main_service_name}_${stage_name}`` version of them.
#
# Even though all the stages are restored, only the services specified (``$2`` ...) are retagged so that they can be used. If you need more than one service images restored, you will need to specify them all. If multiple services use the same image tag, they do not need to be specified. E.g. service ``foo`` uses image ``stuff:foo``, service ``bar`` uses image ``stuff:bar``, and service ``car`` uses image ``stuff:bar`, only ``foo`` and ``bar`` need to be passed in.
#**
function docker-compose_restore_from_cache()
{
  local compose_file="${1}"
  shift 1

  # Render compose file
  local compose_rendered="$(docker-compose -f "${compose_file}" config)"
  local compose_yarp="$(yarp <<< "${compose_rendered}")"
  local docker_compose_version="$(sed -nE "s|^version = '(.*)'$|\1|p" <<< "${compose_yarp}")"
  local dockerfile="$(get_dockerfile_from_compose "${compose_file}" "${1}" "${compose_yarp}")"

  local JUST_DOCKER_COMPOSE_CACHE_REPO="${JUST_DOCKER_COMPOSE_CACHE_REPO:-vsiri/ci_cache}"

  local i

  local stage_names=($(get_docker_stage_names "${dockerfile}"))
  local recipes=($(get_docker_recipes "${dockerfile}"))

  local temp_file="$(mktemp)"
  local temp_override="$(mktemp)"
  local temp_push_pull="$(mktemp)"

  #######################
  # Pull all the images #
  #######################
  if [ "${JUST_DOCKER_COMPOSE_PULL-1}" = "1" ] || [ "${JUST_DOCKER_COMPOSE_PUSH-1}" = "1" ]; then
    _dynamic_docker-compose_push_pull "${1}" > "${temp_push_pull}"
  fi

  if [ "${JUST_DOCKER_COMPOSE_PULL-1}" = "1" ]; then
    # Let it fail, since the first time the images won't exist
    Docker-compose -f "${temp_push_pull}" pull || :
  fi

  ##############################
  # Restore recipes from cache #
  ##############################
  local recipes_compose_file="${VSI_COMMON_DIR}/docker/recipes/docker-compose.yml"
  local recipe_compose_version="$(yarp < "${recipes_compose_file}" | sed -nE "s|^version = '(.*)'$|\1|p")"
  _dynamic_docker-compose_restore_recipes "${1}" > "${temp_override}"

  if [ "${JUST_DOCKER_COMPOSE_BUILD-1}" = "1" ]; then
    Docker-compose -f "${recipes_compose_file}" -f "${temp_override}" build ${recipes[@]+"${recipes[@]}"}
    # retag recipes for push
    for i in ${recipes[@]+"${recipes[@]}"}; do
      Docker tag "vsiri/recipe:${i}" "${JUST_DOCKER_COMPOSE_CACHE_REPO}:recipe_${1}_${i}"
    done
  fi

  local main_service="${1}"

  ############################################################
  # Restore services from cache and setup stages for pushing #
  ############################################################
  local main_image_name="$(sed -nE "s|^services.${main_service}.image = ||p" <<< "${compose_yarp}")"
  _dynamic_docker-compose_add_cache_from "${@}" <<< "${compose_rendered}" > "${temp_file}" 3>"${temp_override}"

  # The above function's for loop is in a different subshell actually, in order
  # to update the services array, this has to be done separately
  local services=()
  for stage_name in ${stage_names[@]+"${stage_names[@]}"}; do
    # Update list docker-compose commands
    services+=("${main_service}_auto_gen_${stage_name}")
  done
  services+=(${@+"${@}"})

  # Build images
  if [ "${JUST_DOCKER_COMPOSE_BUILD-1}" = "1" ]; then
    Docker-compose -f "${temp_file}" -f "${temp_override}" --project-directory "$(dirname "${compose_file}")" build "${services[@]}"
  fi

  # Tag the final image, for push
  if [ "${main_image_name}" != "" ]; then
    Docker tag "${main_image_name}" "${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${main_service}"
  fi
  # local target
  # for i in ${@+"${@:2}"}; do
  #   image_name="$(sed -nE "s|^services.${i}.image = ||p" <<< "${compose_yarp}")"
  #   target="$(sed -nE "s|^services.${i}.build.target = ||p" <<< "${compose_yarp}")"

  #   if [ "${image_name}" != "" ]; then
  #     if [ "${target}" = "" ]; then
  #       Docker tag "${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${main_service}" "${image_name}"
  #     else
  #       Docker tag "${JUST_DOCKER_COMPOSE_CACHE_REPO}:stage_${target}" "${image_name}"
  #     fi
  #   fi
  # done

  if [ "${JUST_DOCKER_COMPOSE_PUSH-1}" = "1" ]; then
    Docker-compose -f "${temp_push_pull}" push
  fi

  # Cleanup
  ${DRYRUN-} rm "${temp_file}" "${temp_override}" "${temp_push_pull}"
}

# docker-compose_restore_from_cache helper function
function _dynamic_docker-compose_push_pull()
{
  local i
  echo   "version: '3.5'"
  echo   "services:"
  echo   "  final_${1}:"
  echo   "    build: ."
  echo   "    image: ${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${1}"

  for i in ${stage_names[@]+"${stage_names[@]}"}; do
    echo "  stage_${i}:"
    echo "    build: ."
    echo "    image: ${JUST_DOCKER_COMPOSE_CACHE_REPO}:${1}_${i}"
  done
  for i in ${recipes[@]+"${recipes[@]}"}; do
    echo "  recipe_${i}:"
    echo "    build: ."
    echo "    image: ${JUST_DOCKER_COMPOSE_CACHE_REPO}:recipe_${1}_${i}"
  done
}

# docker-compose_restore_from_cache helper function
function _dynamic_docker-compose_restore_recipes()
{
  local i
  echo   "version: '${recipe_compose_version}'"
  echo   "services:"
  for i in ${recipes[@]+"${recipes[@]}"}; do
    echo "  ${i}:"
    echo "    build:"
    echo "      cache_from:"
    echo "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:recipe_${1}_${i}"
  done
}

# docker-compose_restore_from_cache helper function
# stdin - docker-compose file
# stdout - patched docker-compose file
# fid 3 out - docker-compose override file
# arguments - Services to use cache
function _dynamic_docker-compose_add_cache_from()
{
  # local file="${1}"
  # local override="${2}"
  # shift 2
  local main_service="${1}"
  local i

  # anchor the main stage
  local compose_content="$(sed "s|  ${1}:|& \&main_stage|")"

  # A rendered docker-compose file is always in alphabetical order, The only top
  # level keys are x-*, version, services, secrets, and networks. So I can always
  # add a new services before "^version:". Start by getting the line number of
  # the version line-1
  i="$(sed -n '/^version:/=' <<< "${compose_content}")"
  i=$((i-1))

  # ----------------
  # | setup stages |
  # ----------------
  # This loop will both patch the docker-compose ${file} and generate
  # a compose override file ${override} that will combine in two different
  # ways to make our final configuration.
  # - Anchors can't work across, so we need the ${file} method
  # - We can't override target without redefining/anchoring all of build, so
  #   we need file_override to just add to it

  function _print_cache_froms()
  {
    echo   "      cache_from:"
    echo   "        - ${main_image_name}"
    echo   "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${main_service}"
    for i in ${stage_names[@]+"${stage_names[@]}"}; do
      echo "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:${main_service}_${i}"
    done
    for i in ${recipes[@]+"${recipes[@]}"}; do
      echo "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:recipe_${main_service}_${i}"
    done
  }

  echo     "version: '${docker_compose_version}'" >&3
  echo     "services:" >&3
  for stage_name in ${stage_names[@]+"${stage_names[@]}"}; do
    # Service patch for 2
    echo   "  ${1}_auto_gen_${stage_name}:"
    echo   "    <<: *main_stage"
    echo   "    image: ${JUST_DOCKER_COMPOSE_CACHE_REPO}:${1}_${stage_name}"

    # Service addition for 3
    echo   "  ${1}_auto_gen_${stage_name}:" >&3
    echo   "    build:" >&3
    echo   "      target: ${stage_name}" >&3
    _print_cache_froms >&3
         # https://stackoverflow.com/a/26141656/4166604
  done | sed "${i}"'r/dev/stdin' <(echo "${compose_content}")

    # ------------------
  # | setup services |
  # ------------------
  # Build services using cache
  while (( $# )); do
    # By adding an override file, any special build flags will be included,
    # such as build args, etc...
    echo   "  ${1}:" >&3
    echo   "    build:" >&3
    _print_cache_froms >&3

    shift 1
  done
}

#**
# .. function:: get_docker_recipes
#
# :Arguments: ``$1...`` - Dockerfiles to search for recipes
# :Parameters: ``JUST_RECIPE_REPO`` - Name of recipe image to look for. Default: ``vsiri/recipe``
# :Output: **stdout** - Newline separated list of the tags of the recipes
#
# Looks for recipes that are used in the dockerfiles.
#**
function get_docker_recipes()
{
  local JUST_RECIPE_REPO="${JUST_RECIPE_REPO-vsiri/recipe}"
  # / and . are the only valid character in an image name that needs regex escaping
  JUST_RECIPE_REPO="${JUST_RECIPE_REPO//./\\.}"
  # Need to escpae / for the first search
  JUST_RECIPE_REPO="${JUST_RECIPE_REPO////\\/}"
  sed -nE '/^ *[fF][rR][oO][mM] *'"${JUST_RECIPE_REPO}"':/{
            s/^ *[fF][rR][oO][mM]  *'"${JUST_RECIPE_REPO}"':([^ ]+).*/\1/
            # Skip (miss) lines with a $ in it, they have variable names that I
            # will not be able to match
            /\$/d
            p
          }' ${@+"${@}"} | sort -u
}

#**
# .. function:: docker_defaultify
#
# .. command:: build_recipes
#
# :Arguments: [``$1``]... - Recipe names to run
#
# Runs ``docker-compose build`` for the docker recipes. Useful command to call before ``docker build`` on your own project that uses recipes in vsi_common, to keep them synced with your build.
#
# .. command:: build_recipes-auto
#
# :Arguments: ``$1``... - Dockerfiles to parse
#
# Scans dockerfiles for ``vsiri/recipe:`` images, and calls :cmd:`build_recipes` on the recipes discovered. Accepts multiple files and ``-`` for stdin
#
# .. command:: log
#
# :Arguments: [``$1``]... - Service names
#
# Show logs from all service containers. Optionally specify service names to only log specific containers.
#
# .. warning::
#
#   Does not pick up containers that didn't exist when starting ``just`` log
#
# Override the log target in your ``Justfile`` and call ``__docker-compose-log`` if you need to set other parameter.
#
# .. command:: docker_clean
#
# :Arguments: ``$1`` - Volume to be removed
#
# Runs ``docker volume rm`` on the specified volume. If the volume is in use, there are four strategies to handle this:
#
# 1. ``ask`` - (default) Interactively asks you if you want to use the stop, delete, or error strategy.
# 2. ``stop`` - Attempts to stop the containers with a 30 second timeout and then forcefully remove the current containers mounting the volume, without prompting
# 3. ``delete`` - Mounts the volume and deletes all of the files. May not work when a container is running a database, or the volumes modified by the entrypoint, i.e. adding user permissions.
# 4. ``error`` - Errors out instead of cleaning the volume
#
# The action for a specific volume is specified by setting the label ``com.vsi.just.clean_action``.
#
# For example, in a ``docker-compose.yaml`` file:
#
# .. code-block:: yaml
#
#   volumes:
#     venv:
#       labels:
#         com.vsi.just.clean_action: ask
#
# delete
# ------
#
# In the case of ``delete`` strategy, an optional labels ``com.vsi.just.clean_setup`` can be specified to designate what just target to run to repopulate a volume. Typically this just target should run ``sh -c ":"`` or similar. This allows the entrypoint or another command to properply setup the volume, and set permissions, etc...
#
#**
function docker_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    build_recipes) # Build recipes
      JUST_DOCKER_COMPOSE_DIR="${VSI_COMMON_DIR}/docker/recipes" \
          COMPOSE_FILE="${VSI_COMMON_DIR}/docker/recipes/docker-compose.yml" \
          Docker-compose build ${@+"${@}"}
      extra_args=$#
      ;;
    build_recipes-auto) # Build recipes used in specified dockerfiles. "-" for \
                        # stdin; multiple files (via wildcards) accepted
      if [ "$#" = "0" ]; then
        source "${VSI_COMMON_DIR}/linux/colors.bsh"
        echo "${RED}ERROR:${NC} You must pass at least one argument to build recipes-auto" >&2
        return 1
      fi

      source "${VSI_COMMON_DIR}/linux/elements.bsh"

      # Set up cache (global) array of recipes already built, so we don't build
      # the same recipe multiple times.
      if ! is_array JUST_DOCKER_RECIPES; then
        JUST_DOCKER_RECIPES=()
      fi

      local recipes=($(get_docker_recipes ${@+"${@}"}))

      local tmp=()
      subtract_array recipes JUST_DOCKER_RECIPES tmp
      recipes=(${tmp+"${tmp[@]}"})

      JUST_DOCKER_RECIPES=(${JUST_DOCKER_RECIPES+"${JUST_DOCKER_RECIPES[@]}"} ${recipes+"${recipes[@]}"})

      if [ "${#recipes[@]}" != "0" ]; then
        justify build recipes "${recipes[@]}"
      fi
      extra_args=$#
      ;;
    docker_clean) # Delete a docker volume. The next container to use this \
                  # volume will automatically copy any content from the image.
      local volume_inspect_rv=0
      # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
      local volume_inspect
      # docker volume inspect causes a trap set by just and inherited by the
      # subshell to execute when the volume is not found on bash 3.2.
      # although redirecting the docker command catches inspect's error message,
      # it doesn't catch the trap unless the entire subshell's stderr is
      # redirected via exec 2>/dev/null. Disabling the trap felt cleaner
      volume_inspect="$(trap -- ERR; docker volume inspect "${1}" 2>/dev/null)" || volume_inspect_rv=$?

      if [ "${volume_inspect_rv}" = "0" ]; then
        local rm_rv
        local rm_out
        local rm_err

        {
            IFS= read -r -d '' rm_err
            IFS= read -r -d '' rm_rv
            IFS= read -r -d '' rm_out
        } < <((printf '\0%s\0' "$(Docker volume rm "${1}"; printf '\0%d' "${?}" 1>&2)" 1>&2) 2>&1)
        # Command outputs stdout on 1, stderr on 2; then add "NUL+Return" Value on Stderr
        # printf will buffer stdout (letting "stderr+NUL+rv" stream out in real time)
        # printf then redirects its output to 2, so now 2 contains "stderr+NUL+rv+NUL+stdout"
        # finally, stderr is redirected to 1, allowing the read commands to read "stderr+NUL+rv+NUL+stdout"

        # Echo stdout as if the command was run normally. Important for dryrun
        echo "${rm_out}"

        if [ "${rm_rv}" != "0" ]; then
          local pattern='volume is in use - \[(.*)\]'
          [[ ${rm_err} =~ ${pattern} ]]
          local OLD_IFS="${IFS}"
          IFS=", "
          local containers=(${BASH_REMATCH[1]})
          IFS="${OLD_IFS}"

          pattern='"com\.vsi\.just\.clean_action": "([^"]+)"'
          local action
          if [[ ${volume_inspect} =~ $pattern ]]; then
            action="${BASH_REMATCH[1]}"
          else
            action=ask
          fi

          _docker_clean_actions "${1}" "${action}"
        fi
      else
        echo "${1} already removed" >&2
      fi

      extra_args=1
      ;;
    docker-compose_clean) # Delete a docker-compose volume. The next container \
                          # to use this volume will automatically copy any \
                          # content from the image. Use --all to clean all \
                          # volumes listed in the docker-compose.yml file
      if [ "${1}" = "--all" ]; then
        local DOCKER_INTERNAL_VOLUMES
        local volume
        docker-compose-list-internal-volumes < <(Just-docker-compose config)
        for volume in ${DOCKER_INTERNAL_VOLUMES[@]+"${DOCKER_INTERNAL_VOLUMES[@]}"}; do
          justify docker_clean "${COMPOSE_PROJECT_NAME}_${volume}"
        done
      else
        justify docker_clean "${COMPOSE_PROJECT_NAME}_${1}"
      fi
      extra_args=1
      ;;
    docker-compose_enter) # Enter a running container, running an interactive
                          # bash session. Set COMPOSE_SERVICES to limit to a
                          # specific service. Additional arguments are run in
                          # lieu of bash
      # not Docker-compose; no quotes
      local containers=($(docker-compose ps -q ${COMPOSE_SERVICES-} || :))
      if [ "${#containers[@]}" == 0 ]; then
        echo "No running containers found"
        extra_args=$#
        return 0
      elif [ "${#containers[@]}" == 1 ]; then
        local picked=1
      else
        local picked
        local pretty=()
        for picked in "${!containers[@]}"; do
          pretty[${picked}]="$(docker container inspect -f \
              '{{index .Config.Labels "com.docker.compose.service"}} - {{.Name}} ({{.Config.Hostname}})' \
              ${containers[$picked]}) $(docker ps --format {{.Status}} -f id=${containers[$picked]})"
        done
        picker "${pretty[@]}" || picked=$?
      fi

      # Give the dev a way to override the -it flags, should they ever need to
      local DOCKER_EXTRA_EXEC_ARGS=("${DOCKER_EXTRA_EXEC_ARGS[@]--it}")

      if [ "$#" = "0" ]; then
        Docker exec "${containers[$((picked-1))]}" bash
      else
        Docker exec "${containers[$((picked-1))]}" ${@+"${@}"}
      fi
      extra_args=$#
      ;;
    docker-compose_log) # Show logs from all service containers. Optionally \
         # specify service names to only log specific containers. Bug: Does \
         # not pick up containers that didn't exist when starting just log

      # Override the log target in your Justfile and call __docker-compose-log
      # if you need to set other parameters
      justify __docker-compose-log ${@+"${@}"}
      extra_args=$#
      ;;
    __docker-compose-log)
      function stop_logging(){ JUST_STOP_LOGGING=1; }
      JUST_STOP_LOGGING=0
      trap stop_logging INT
      trap stop_logging TERM
      while [ "${JUST_STOP_LOGGING}" == "0" ]; do
        Docker-compose logs --tail=20 -f ${@+"${@}"} || echo $?
        while [ "${JUST_STOP_LOGGING}" == "0" ] && ! docker_service_running | grep running > /dev/null; do
          sleep 1
        done
      done
      trap - INT
      trap - TERM
      extra_args=$#
      ;;

    docker) # Run generic docker command
      Docker ${@+"${@}"}
      extra_args=$#
      ;;

    docker-compose) # Run generic docker-compose command
      Just-docker-compose ${@+"${@}"}
      extra_args=$#
      ;;

    docker-compose_ci-save) # Build and tag all stages of an image. $1 - compose filename, $2 - docker-compose service to build (for final stage)
      docker-compose_tag_all_stages "${1}" "${2}"
      extra_args=2
      ;;

    docker-compose_ci-load) # Build all stages of an image from a pulled cache. $1 - compose filename, $2 - docker-compose service to build (for final stage), [$3...] - additional service names that might point to other stage targets in the same dockerfile.
      docker-compose_restore_from_cache "${@}"
      extra_args=$#
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}

# :Arguments: ``$1`` - Volume to be removed
#             ``$2`` - Action to take
# :Parameters: ``containers`` - Array of containers using volume
#              ``volume_inspect`` - String of the result from ``docker volume inspect ${1}``
function _docker_clean_actions()
{
  case "${2}" in
    ask)
      echo "The following containers are using ${1}:"
      echo "${containers[*]}"

      local action
      picker "Stop and forcefully remove these containers then try again" \
             "Deletes all of the volumes files and repopulate" \
             "Do nothing and error" > /dev/null || action=$?

      if [ "${action}" = "1" ]; then
        _docker_clean_actions "${1}" stop
      elif  [ "${action}" = "2" ]; then
        _docker_clean_actions "${1}" delete
      elif  [ "${action}" = "3" ]; then
        _docker_clean_actions "${1}" error
      else
        _docker_clean_actions "${1}" unknown
      fi
      ;;
    delete)
      # Remove the files
      Docker run --rm --mount "type=volume,src=${1},dst=/data" alpine sh -c "find /data -maxdepth 1 -mindepth 1 -print0 | xargs -0 rm -rf"

      # If there is a com.vsi.just.clean_setup label
      pattern=$'"com\.vsi\.just\.clean_setup": "([^\n]*)"\n'
      if [[ ${volume_inspect} =~ $pattern ]]; then
        # Parse \" to "
        setup_cmd="${BASH_REMATCH[1]//\\\"/\"}"
        # Evaluate this string into arguments. By definition this is arbitrary
        # code execution, so eval is acceptable.
        eval "setup_cmd=(${setup_cmd})"
        # Run the just target
        justify "${setup_cmd[@]}"
      else
        echo "No 'com.vsi.just.clean_setup' label found for volume ${1}" >&2
        # false
      fi
      ;;
    stop)
      for x in "${containers[@]}"; do
        Docker stop -t 30 "${x}"
        Docker rm -f "${x}" || :
      done
      Docker volume rm "${1}"
      ;;
    error)
      false
      ;;
    *)
      echo "Unknown action ${2}"
      false
      ;;
  esac
}

# Idea from Issue #103
function set_docker_compose_project_name()
{
  if [ "${COMPOSE_PROJECT_NAME:+set}" != "set" ]; then
    local cwd_var="${JUST_PROJECT_PREFIX}_CWD"
    local user_var="${JUST_PROJECT_PREFIX}_USERNAME"
    if [ "${!user_var:+set}" = "set" ]; then
      COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${!cwd_var}" "${!user_var}")
    else
      COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${!cwd_var}")
    fi
  fi
}
