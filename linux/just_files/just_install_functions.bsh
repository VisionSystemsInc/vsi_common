#!/usr/bin/env false bash

if [[ ${-} != *i* ]]; then
  source_once &> /dev/null && return 0
fi

# dependencies
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
source "${VSI_COMMON_DIR}/linux/command_tools.bsh"
source "${VSI_COMMON_DIR}/linux/requirements.bsh"
source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
source "${VSI_COMMON_DIR}/linux/web_tools.bsh"

#*# just/plugins/just_install_functions

JUST_DEFAULTIFY_FUNCTIONS+=(install_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

#**
# =============================
# J.U.S.T. Install CI Functions
# =============================
#
# .. default-domain:: bash
#
# .. file:: just_install_functions.bsh
#
# Install plugin for just. Installation routines are designed to be installed to isolated standalone locations, for example ``/your/path/python-3.7.9``.
#**

#**
# .. envvar:: JUST_INSTALL_ACTIVATE_BASENAME
#
# File basename for utility activation. Users may source anactivation file to create useful environment variables and add the utility to $PATH.
#**

: ${JUST_INSTALL_ACTIVATE_BASENAME="just_activate.bsh"}

#**
# .. function:: cmake-install
#
# Install CMake.
#
# :Arguments: * [``--dir {dir}``] - CMake install directory
#             * [``--version {version}``] - CMake version for install (default= ``${CMAKE_VERSION:-3.16.3}``)
#
# :Output: * cmake_exe - CMake executable
#          * cmake_version - CMake version
#          * cmake_extra_args - number of arguments consumed
#          * cmake_activate - Bash file to activate cmake environment
#
#**

function cmake-install()
{
  local cmake_dir  # install directory
  local cmake_ver="${CMAKE_VERSION:-3.16.3}"  # cmake version

  parse_args cmake_extra_args \
      --dir cmake_dir: \
      --version cmake_ver: \
      -- ${@+"${@}"}

  # directory check
  if [ -z "${cmake_dir-}" ]; then
    echo "CMake install must specify --dir" >& 2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # download zip/tar
  make_temp_path temp_dir -d

  local cmake_id
  local cmake_url="https://cmake.org/files/v${cmake_ver%.*}/"
  if [ "${OS-}" = "Windows_NT" ]; then
    cmake_id="cmake-${cmake_ver}-win64-x64"
    cmake_url+="${cmake_id}.zip"
  elif [[ ${OSTYPE-} = darwin* ]]; then
    cmake_id="cmake-${cmake_ver}-Darwin-x86_64"
    cmake_url+="${cmake_id}.tar.gz"
  else
    cmake_id="cmake-${cmake_ver}-Linux-x86_64"
    cmake_url+="${cmake_id}.tar.gz"
  fi

  echo "Downloading cmake from <${cmake_url}>..." >&2
  local cmake_file="${temp_dir}/$(basename "${cmake_url}")"
  download_to_file "${cmake_url}" "${cmake_file}"

  # convert zip to tar
  # cmake archives contain an extra parent directory that must be ignored,
  # which is easily handled by "tar --strip-components=1". Unfortunately,
  # unzip has no equivalent argument so we convert to tar.
  if [ "${OS-}" = "Windows_NT" ]; then
    local unzip_dir="${temp_dir}/unzip"
    unzip -oq "${cmake_file}" -x "*/doc/**" -d "${unzip_dir}"

    cmake_file="${temp_dir}/cmake.tar"
    tar -cf "${cmake_file}" -C "${unzip_dir}" "${cmake_id}"
  fi

  # create output directory
  mkdir -p "${cmake_dir}"
  cmake_dir="$(cd "${cmake_dir}"; pwd)"

  # extract archive
  echo "Extracting cmake archive..." >&2
  tar -xf "${cmake_file}" --exclude="*/doc" -C "${cmake_dir}" \
      --strip-components=1

  # executable
  local cmake_exe_footer
  if [[ ${OSTYPE-} = darwin* ]]; then
    cmake_exe_footer="CMake.app/Contents/bin/cmake"
  else
    cmake_exe_footer="bin/cmake"
  fi
  local CMAKE="${cmake_dir}/${cmake_exe_footer}"

  # outputs: executable & version
  cmake_exe="${CMAKE}"
  cmake_version="$("${CMAKE}" --version | awk 'NR==1{print $3}')"
  echo "CMake ${cmake_version} installed at \"${cmake_exe}\"" >&2

  # Make sure python meets request
  if ! meet_requirements "${cmake_version}" "==${cmake_ver}"; then
    echo "CMake version ${cmake_version} is not the requested version ${cmake_ver}" >&2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # cmake activate
  cmake_activate="${cmake_dir}/cmake_${JUST_INSTALL_ACTIVATE_BASENAME}"
  uwecho '#!/usr/bin/env bash
          set -eu

          # folder where this file resides
          CMAKE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"
          ' > "${cmake_activate}"
  uwecho "
          # executable & version
          CMAKE_EXE=\"\${CMAKE_DIR}/${cmake_exe_footer}\"
          CMAKE_VER=\"${cmake_version}\"
          " >> "${cmake_activate}"
  uwecho '
          # update PATH
          PATH="$(dirname "${CMAKE_EXE}"):${PATH}"
          ' >> "${cmake_activate}"
}


#**
# .. function:: conda-install
#
# Install miniconda
#
# :Arguments: * [``--dir {dir}``] - conda install directory
#             * [``--version {version}``] - conda version for install (default= ``${CONDA_VERSION:-latest}``)
#             * [``--installer {INSTALLER}``] - Conda installer
#
# :Output: * conda_exe - conda executable
#          * conda_version - conda version
#          * conda_extra_args - number of arguments consumed
#          * conda_activate - bash file to make conda available
#**

function conda-install()
{
  local conda_dir  # install directory
  local conda_ver="${CONDA_VERSION:-latest}"  # conda version
  local CONDA_INSTALLER  # optional conda installer

  parse_args conda_extra_args \
      --dir conda_dir: \
      --version conda_ver: \
      --installer CONDA_INSTALLER: \
      -- ${@+"${@}"}

  # directory check
  if [ -z "${conda_dir-}" ]; then
    echo "Conda install must specify --dir" >& 2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # download conda installer to self-deleting temporary directory
  if [ -z "${CONDA_INSTALL-}" ]; then

    local conda_url="https://repo.anaconda.com/miniconda/"
    if [ "${OS-}" = "Windows_NT" ]; then
      conda_url+="Miniconda3-${conda_ver}-Windows-x86_64.exe"
    elif [[ ${OSTYPE-} = darwin* ]]; then
      conda_url+="Miniconda3-${conda_ver}-MacOSX-x86_64.sh"
    else
      conda_url+="Miniconda3-${conda_ver}-Linux-x86_64.sh"
    fi
    echo "Downloading miniconda <${conda_url}>..." >&2

    local conda_installer_dir
    make_temp_path conda_installer_dir -d
    CONDA_INSTALLER="${conda_installer_dir}/$(basename "${conda_url}")"
    download_to_file "${conda_url}" "${CONDA_INSTALLER}"
  fi

  # install conda
  echo "Installing miniconda..." >&2

  # windows
  if [ "${OS-}" = "Windows_NT" ]; then

    # manual specification of NoRegistry, AddToPath, & RegisterPython
    # ensure the temporary miniconda is not added to the system registry
    # at <HKEY_CURRENT_USER\SOFTWARE\Python\PythonCore>
    MSYS2_ARG_CONV_EXCL="*" "${CONDA_INSTALLER}" \
        /NoRegistry=1 /AddToPath=0 /RegisterPython=0 \
        /InstallationType=JustMe /S /D="$(cygpath -aw "${conda_dir}")"

    # conda executable
    conda_exe_footer="Scripts/conda.exe"
    CONDA="${conda_dir}/${conda_exe_footer}"

    # cleanup shortcuts
    "${CONDA}" remove --offline -y -p "${conda_dir}" console_shortcut powershell_shortcut

  # linux & darwin
  else

    # install conda
    bash "${CONDA_INSTALLER}" -b -p "${conda_dir}" -s

    # conda executable
    conda_exe_footer="bin/conda"
    CONDA="${conda_dir}/${conda_exe_footer}"
  fi

  # output: executable & version
  conda_exe="${CONDA}"
  # Source conda.sh and use conda function to handle long paths (see No module
  # named conda.cli error below)
  conda_version="$(source "${conda_dir}/etc/profile.d/conda.sh"; conda --version | awk 'NR==1{print $2}')"
  echo "Conda ${conda_version} installed at \"${conda_exe}\"" >&2

  # Make sure version meets request
  # note we remove any any "py??_" prefix during version comparison
  if [ "${conda_ver}" != "latest" ]; then
    if ! meet_requirements "${conda_version}" "==${conda_ver#*_}"; then
      echo "Conda version ${conda_version} is not the requested version ${conda_ver}" >&2
      local JUST_IGNORE_EXIT_CODES=1
      return 1
    fi
  fi

  # conda "activation", making conda available on the command line
  conda_activate="${conda_dir}/conda_${JUST_INSTALL_ACTIVATE_BASENAME}"
  uwecho '#!/usr/bin/env bash
          set -eu

          # folder where this file resides
          CONDA_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"
          ' > "${conda_activate}"
  uwecho "
          # executable & version
          CONDA_EXE=\"\${CONDA_DIR}/${conda_exe_footer}\"
          CONDA_VER=\"${conda_version}\"
          " >> "${conda_activate}"

  uwecho '
          # source conda.sh which contains the "conda" command as a function
          # https://github.com/conda/conda/blob/master/CHANGELOG.md#440-2017-12-20
          # This function will auto-update the path
          CONDA_SH="${CONDA_DIR}/etc/profile.d/conda.sh"
          . "${CONDA_SH}"
          ' >> "${conda_activate}"
}


#**
# .. function:: conda-python-install
#
# Install python via conda.
#
# The conda executable is selected as per the following preference order:
# * ``--conda``
# * temporary conda installed from ``conda-installer``
# * if ``--download``: temporary miniconda3 download
# * else: system level conda if available, then temporary miniconda3 download
#
# :Arguments: * [``--dir {dir}``] - Python install directory
#             * [``--version {version}``] - Python version for install (default= ``${PYTHON_VERSION:-3.6.9}``)
#             * [``--conda {CONDA}``] - Conda executable
#             * [``--conda-installer {INSTALLER}``] - Conda installer
#             * [``--download``] - Download miniconda
#             * [``--package {package}``] - An additional package to be installed, may be called multiple times
#
# :Output: * python_exe - Python executable
#          * python_version - Python version
#          * conda_python_extra_args - number of arguments consumed
#          * python_activate - Bash file to activate python environment
#**

function conda-python-install()
{
  local python_dir  # install directory
  local python_ver="${PYTHON_VERSION:-3.6.9}"  # python version
  local CONDA  # conda executable
  local CONDA_INSTALLER  # conda installer
  local prefer_download=0  # prefer conda download if no CONDA|CONDA_INSTALLER
  local packages=()
  local conda_activate

  parse_args conda_python_extra_args \
      --dir python_dir: \
      --version python_ver: \
      --conda CONDA: \
      --conda-installer CONDA_INSTALLER: \
      --download prefer_download \
      --package +packages: \
      -- ${@+"${@}"}

  # directory check
  if [ -z "${python_dir-}" ]; then
    echo "Conda python install must specify --dir" >& 2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # conda install requirements
  if [ -n "${CONDA:+set}" ]; then
    # use provided conda
    :
  elif [ "${prefer_download}" == "1" ]; then
    # download fresh installer
    CONDA_INSTALLER=
  elif [ -n "${CONDA_INSTALLER:+set}" ]; then
    # use provided conda installer to install conda
    :
  else
    # check path for available conda
    CONDA="$( ( (command -v conda3 || command -v conda || command -v conda2) | head -n 1) || :)"
  fi

  # install conda to self-deleting temporary directory
  if [ -z "${CONDA-}" ]; then
    local conda_temp_dir
    make_temp_path conda_temp_dir -d

    conda-install \
        --dir "${conda_temp_dir}/conda" \
        ${CONDA_INSTALLER:+ --installer "${CONDA_INSTALLER}"}

    # Shebang can't be more than 128 often, so we need to source conda.sh and so
    # and use the conda function, so the right python is found and used, else
    # you will see "ImportError: No module named conda.cli"
    CONDA="conda"
  fi

  # create output directory
  mkdir -p "${python_dir}"
  python_dir="$(cd "${python_dir}"; pwd)"

  # install python
  echo "Installing python..." >&2
  (
    if [ -r "${conda_activate-}" ]; then
      source "${conda_activate}"
    fi
    "${CONDA}" create -y -p "${python_dir}" "python==${python_ver}" ${packages[@]+"${packages[@]}"}
  )
  local python_exe_footer
  if [ "${OS-}" = "Windows_NT" ]; then
    python_exe_footer="python.exe"
  else
    if [ -f "${python_dir}/bin/python3" ]; then
      python_exe_footer="bin/python3"
    else
      python_exe_footer="bin/python"
    fi
  fi
  local PYTHON="${python_dir}/${python_exe_footer}"

  # output: python executable & version
  # (note python may write --version to stderr)
  python_exe="${PYTHON}"
  python_version="$("${python_exe}" --version 2>&1 | awk '{print $2}')"
  echo "Python ${python_version} installed at \"${python_exe}\"" >&2

  # Make sure python meets request
  if ! meet_requirements "${python_version}" "==${python_ver}"; then
    echo "Python version ${python_version} is not the requested version ${python_ver}" >&2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi


  # python activation - users may source this file to mimic conda
  # activation, ensuring appropriate path setup for python functions
  #
  # Without sourcing this file, a subsequent call of 'just install pipenv'
  # may fail with errors such as:
  #   urllib.error.URLError: <urlopen error unknown url type: https>
  # as python cannot find necessary libraries
  python_activate="${python_dir}/python_${JUST_INSTALL_ACTIVATE_BASENAME}"
  uwecho '#!/usr/bin/env bash
          set -eu

          # folder where this file resides
          PYTHON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"
          ' > "${python_activate}"
  uwecho "
          # executable & version
          PYTHON_EXE=\"\${PYTHON_DIR}/${python_exe_footer}\"
          PYTHON_VER=\"${python_version}\"
          " >> "${python_activate}"

  if [ "${OS-}" = "Windows_NT" ]; then
    uwecho '
            # additional paths for python as per "conda activate"
            # https://github.com/conda/conda/blob/master/conda/shell/condabin/_conda_activate.bat#L23
            MORE_PATHS=(
                "${PYTHON_DIR}"
                "${PYTHON_DIR}/Library/mingw-w64/bin"
                "${PYTHON_DIR}/Library/usr/bin"
                "${PYTHON_DIR}/Library/bin"
                "${PYTHON_DIR}/Scripts"
                "${PYTHON_DIR}/bin"
            )
            MORE_PATH="$(IFS=':'; echo "${MORE_PATHS[*]}")"

            # update PATH
            PATH="${MORE_PATH}:${PATH}"
            ' >> "${python_activate}"
  fi
}


#**
# .. function:: pipenv-install
#
# Install a virtualenv containing pipenv.
#
# :Arguments: * [``--dir {dir}``] - Pipenv install directory
#             * [``--version {version}``] - Pipenv version for install (default= ``${RECIPE_PIPENV_VERSION:-${PIPENV_VERSION:-2020.11.15}}``)
#             * [``--python {PYTHON}``] - Python executable (default=(python3|python|python2))
#             * [``--python-activate {script}``] - Optional python activation script, for example as created by :func:`conda-python-install`
#             * [``--virtualenv-pyz {file}``] - Optional virtualenv zipapp file (default= ``${RECIPE_VIRTUALENV_PYZ:-${VIRTUALENV_PYZ:-}}``)
#             * [``--virtualenv-version {version}``] - Optional viertualenv version (default= ``${RECIPE_VIRTUALENV_VERSION:-${VIRTUALENV_VERSION:-20.4.5}}``)
#
# :Output: * pipenv_exe - Pipenv executable
#          * pipenv_version - Pipenv version
#          * pipenv_extra_args - number of arguments consumed
#          * pipenv_activate - Bash file to activate pipenv environment
#**

function pipenv-install()
{
  local pipenv_dir  # install directory
  local pipenv_ver="${RECIPE_PIPENV_VERSION:-${PIPENV_VERSION:-2020.11.15}}"  # pipenv version
  local PYTHON  # python executable
  local python_activate
  local virtualenv_pyz="${RECIPE_VIRTUALENV_PYZ:-${VIRTUALENV_PYZ:-}}"
  local virtualenv_ver="${RECIPE_VIRTUALENV_VERSION:-${VIRTUALENV_VERSION:-20.4.5}}"

  parse_args pipenv_extra_args \
      --dir pipenv_dir: \
      --version pipenv_ver: \
      --python PYTHON: \
      --python-activate python_activate: \
      --virtualenv-pyz virtualenv_pyz: \
      --virtualenv-version virtualenv_ver: \
      -- ${@+"${@}"}

  # check for pipenv directory
  if [ -z "${pipenv_dir-}" ]; then
    echo "Pipenv install must specify --dir" >& 2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # search for python if not specified
  : ${PYTHON:=$( (command -v python3 || command -v python || command -v python2) | head -n 1)}
  if [ ! -f "${PYTHON}" ]; then
    echo "Pipenv install cannot find python executable" >&2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # optional python_activate script
  if [ -n "${python_activate-}" ] && [ ! -f "${python_activate}" ]; then
    echo "Pipenv install cannot find \"${python_activate}\"" >&2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # create pipenv directory
  mkdir -p "${pipenv_dir}"
  pipenv_dir="$(cd "${pipenv_dir}"; pwd)"

  # pipenv install via 30_get-pipenv
  # run in subshell, as sourced files are only needed temporarily
  (
    # "activate" python if created via the "conda-python-install" function
    [ -n "${python_activate-}" ] && source "${python_activate}"

    # install via 30_get-pipenv
    echo "Installing pipenv..." >&2
    source "${VSI_COMMON_DIR}/docker/recipes/30_get-pipenv"
    PIPENV_PYTHON="${PYTHON}"
    PIPENV_VERSION="${pipenv_ver}"
    PIPENV_VIRTUALENV="${pipenv_dir}"
    VIRTUALENV_PYZ="${virtualenv_pyz}"
    VIRTUALENV_VERSION="${virtualenv_ver}"
    install_pipenv
  )

  # pipenv executable
  local pipenv_exe_footer
  if [ "${OS-}" = "Windows_NT" ]; then
    pipenv_exe_footer="Scripts/pipenv"
  else
    pipenv_exe_footer="bin/pipenv"
  fi
  local PIPENV="${pipenv_dir}/${pipenv_exe_footer}"

  # outputs: pipenv executable & version
  pipenv_exe="${PIPENV}"
  pipenv_version="$("${PIPENV}" --version | awk '{print $3}' | sed 's|$\r||g' )"
  echo "Pipenv ${pipenv_version} installed at \"${pipenv_exe}\"" >&2

  # Make sure pipenv meets requirements
  if ! meet_requirements "${pipenv_version}" "==${pipenv_ver}"; then
    echo "Pipenv version ${pipenv_version} does not match request ${pipenv_ver}" >&2
    local JUST_IGNORE_EXIT_CODES=1
    return 1
  fi

  # pipenv activate
  pipenv_activate="${pipenv_dir}/pipenv_${JUST_INSTALL_ACTIVATE_BASENAME}"
  uwecho '#!/usr/bin/env bash
          set -eu

          # folder where this file resides
          PIPENV_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"
          ' > "${pipenv_activate}"
  uwecho "
          # executable & version
          PIPENV_EXE=\"\${PIPENV_DIR}/${pipenv_exe_footer}\"
          PIPENV_VER=\"${pipenv_version}\"
          " >> "${pipenv_activate}"
  uwecho '
          # update PATH
          PATH="$(dirname "${PIPENV_EXE}"):${PATH}"
          ' >> "${pipenv_activate}"
}


#**
# .. command:: install_cmake
#
# Install CMake
#
# .. seealso::
#
#   :func:`cmake-install`
#

# .. command:: install_conda
#
# Install miniconda
#
# .. seealso::
#
#   :func:`conda-install`
#

# .. command:: install_conda-python
#
# Install python via conda
#
# .. seealso::
#
#   :func:`conda-python-install`
#

# .. command:: install_pipenv
#
# Install a virtualenv containing pipenv
#
# .. seealso::
#
#   :func:`pipenv-install`

#**

function install_defaultify()
{
  arg="${1}"
  shift 1
  case ${arg} in
    install_cmake) # Install CMake
      cmake-install ${@+"${@}"}
      extra_args=cmake_extra_args
      ;;
    install_conda) # Install Miniconda
      conda-install ${@+"${@}"}
      extra_args=conda_extra_args
      ;;
    install_conda-python) # Install python via conda
      conda-python-install ${@+"${@}"}
      extra_args=conda_python_extra_args
      ;;
    install_pipenv) # Install a virtualenv containing pipenv
      pipenv-install ${@+"${@}"}
      extra_args=pipenv_extra_args
      ;;
    *)
      plugin_not_found=1
      ;;

  esac
}
