#!/usr/bin/env false bash
# Source this script to access just functionality

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"
fi

source "${VSI_COMMON_DIR}/linux/compat.bsh"
source "${VSI_COMMON_DIR}/linux/elements.bsh"
source "${VSI_COMMON_DIR}/linux/just_files/container_functions.bsh"
# Preload some files (speed boost, esp. on NT)
source "${VSI_COMMON_DIR}/linux/just_files/just_common.bsh"
source "${VSI_COMMON_DIR}/linux/isin"
source "${VSI_COMMON_DIR}/linux/set_flags.bsh"
source "${VSI_COMMON_DIR}/linux/elements.bsh"
source "${VSI_COMMON_DIR}/linux/findin"

#*# just/just_functions

#**
# .. default-domain:: bash
#
# =========
# Functions
# =========
#
# .. file:: just_functions.bsh
#
# A few functions are defined in a common. Sourced here for DRY
#**

function check_just_version()
{
  # 0.2.0 is when JUST_VERSION was added to new_just as an env variable.
  local last_just_version=${JUST_VERSION-pre0.2.0}
  source "${VSI_COMMON_DIR}/linux/just_files/just_version.bsh"
  export JUST_VERSION

  # If last just version was set and different
  if [ -n "${last_just_version:+set}" ] && \
     [ "${last_just_version}" != "${JUST_VERSION}" ]; then
    echo "WARNING: The version of just (${JUST_VERSION}) appears to have changed" >&2
    echo "since it was last updated (${last_just_version})" >&2
    # echo "You may want to source ${JUST_SETUP_SCRIPT-your setup script} again" >&2
    echo "You may want to run 'just_diff -- --' and see what's changed in just." >&2
    if [ -z "${JUST_SETTINGS+set}" ]; then
      local JUST_SETTINGS=/dev/null
    fi
    echo "When you are done, update 'JUST_VERSION=${JUST_VERSION}' in '${JUST_SETTINGS//${JUST_SETTINGS_SEPARATOR}/"' or '"}'" >&2
    echo >&2
  fi
}

# _get_owner_id {path} -> owner user id
function _get_owner_id()
{
  if [[ ${OSTYPE} = darwin* ]]; then
    stat -f %u "${1}"
  else
    stat -c %u "${1}"
  fi
}

#**
# .. envvar:: DRYRUN
#
# Print out some commands instead of executing.
#
# ${DRYRUN} <command>
#
# Display key commands as they would be executed. This is conveniently set by using the ``-n``/``--dryrun`` argument. Default: ``<Null>``
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#     function Docker()
#     {
#       ${DRYRUN} docker "${@}"
#     }
#
# .. note::
#
#   :envvar:`DRYRUN` doesn't just echo out the command, it uses the :func:`print_command print_command` function to print out a command that can be copied and pasted in. This handles spaces correctly unlike echo.
#
# .. seealso::
#
#   :func:`print_command print_command`
#**

: ${DRYRUN=}

#**
# .. envvar:: JUST_SEPARATOR
#
# Separator used for :func:`just_functions.bsh get_args`
#
# When passing an unknown number of arguments, the JUST_SEPARATOR can be used to begin and end a group of arguments. Default: --
#
# .. seealso::
#
#   :func:`get_args`, :func:`get_additional_args`
#**

: ${JUST_SEPARATOR='--'}

#**
# .. envvar:: JUST_SAFE_LOAD_DELIMITER
#
# Separator used for safe_load
#
# safe_load reads a key:value file, and this variable is used to separate the keys and values. Default: =
#
# .. seealso::
#
#   :func:`safe_load`
#**

: ${JUST_SAFE_LOAD_DELIMITER='='}

#**
# just_plugins
# ------------
#
# Plugin system for just
#
# .. rubric:: Usage
#
# Certain just targets can be used for many different projects, and rather then repeating this code, just_plugins give a way to expose the common code of these targets to many different projects.
#
# To add plugins to your project, simply add the plugin filenames to your :file:`.justplugins` file.
#
# When writing a new plugin, you need to follow a few rules:
#
# 1. A case statement in a defaultify function must be written. The case statement should have a unique name that is not likely to be used anywhere else. All plugin functions have to exist in the same namespace.
# 2. Add the case names to the array :envvar:`JUST_DEFAULTIFY_FUNCTIONS` to allow the commonly used functionality to be added as targets for just
# 3. Add the plugin filename to the array :envvar:`JUST_HELP_FILES`
# 4. Must return non-zero if the argument is not matched, and return 0 on target match
#
# .. rubric:: Example
#
# Source code of a just_example_functions.bsh, which looks something like:
#
## .. code-block:: bash
##
##     JUST_DEFAULTIFY_FUNCTIONS+=(just_example_defaultify)
##     JUST_HELP_FILES+=("${BASH_SOURCE[0]}")
##     function just_example_defaultify()
##     {
##       arg="${1}"
##       shift 1
##       case "${arg}" in
##         foo|bar) #Foobar test
##           echo "Foo or bar: ${1}"
##           extra_args=1
##           ;;
##         *)
##           plugin_not_found=1
##           ;;
##       esac
##       return 0
##     }
#**

# The above example needs the ## before foo|bar, or else just help will pick it up as a valid command. ## is a special pattern in the docs entrypoint

#**
# .. envvar:: JUST_PLUGIN_FILE
#
# Name of the just plugin file
#
# Defaults to :file:`.justplugins` in the same directory as the Justfile, but can be overridden to another filename/path by exporting this variable
#
# .. note::
#
#   Since plugins are loaded right before the project environment, you can not set the :envvar:`JUST_PLUGIN_FILE` in the project env file. If you are using a custom :envvar:`JUST_PLUGIN_FILE`, it will need to be set in the :file:`setup.env`
#
# .. seealso::
#
#   just safe_env
#**

#**
# .. envvar:: JUST_DEFAULTIFY_FUNCTIONS
#
# List of defaultify functions
#
# The values of this array are executed as a command. Each plugin should have a unique name for the function, and is responsible for adding that function name to :envvar:`JUST_DEFAULTIFY_FUNCTIONS`
#**

if [ "${JUST_DEFAULTIFY_FUNCTIONS+set}" != "set" ]; then
  JUST_DEFAULTIFY_FUNCTIONS=()
fi


#**
# .. envvar:: JUST_HELP_FILES
#
# This should include just_functions.bsh, the Justfile, and any plugins. The plugin is responsible for adding itself to this array.
#
# .. rubric:: Usage
#
# Every project should have a :ref:`setup file <just-setup-file>`, typically called ``setup.env``. This script's location is stored in :envvar:`JUST_SETUP_SCRIPT` and is also where :envvar:`JUST_HELP_FILES` should be set.
#
# .. seealso::
#
#   :envvar:`JUST_SETUP_SCRIPT`
#**

if [ "${JUST_HELP_FILES+set}" != "set" ]; then
  JUST_HELP_FILES=("${BASH_SOURCE[0]}")
fi

#**
# .. envvar:: JUST_PROJECT_PREFIX
#
# Variable prefix for project
#
# Some just functions need to know the prefix used for a project's environment variables (e.g., in order to list all project env variables using compgen). This should be defined in your project's settings env file, and does not need to be overridable.
#
# .. envvar:: JUST_SETTINGS
#
# Absolute path to the project settings env file; set automatically when you source :file:`just_env`
#
# JUST_SETTINGS is set automatically by :file:`just_env`, which is used to setup the project's environment by sourcing the projects settings env file very early in the project's Justfile.
#
# .. rubric:: Example
#
# Typically, the Justfile will include a line like this very near the top:
#
# .. code-block:: bash
#
#   source "${VSI_COMMON_DIR}/linux/just_files/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'my_project.env'
#
# .. note::
#   :envvar:`JUST_SETTINGS` supports multiple files using the :envvar:`JUST_SETTINGS_SEPARATOR` (default: ``///``). The user and developer should not need to come up with this themselves, as it is automatically generated, unless they are manually overriding it.
#
# .. envvar:: JUST_SETTINGS_SEPARATOR
#
# Separator used between filenames of :envvar:`JUST_SETTINGS`
#**
: ${JUST_SETTINGS_SEPARATOR=///}
#**
# .. function:: source_environment_files
#
# Convenience function for sourcing environments
#
# The just system works by sourcing environment files, aka settings files, and plugins
#
# 1. First, ${project_dir}/local.env. This file should never be added to version control. It should contain customizations for that particular install.
# 2. Then, the project's settings env file. This file should ideally contain all the default values necessary to run without any local.env settings.
# 3. Last, ${project_dir}/local_post.env. This file should never be added to version control. It is rarely used, except in situations where the value of a variable is based off of another variable. This is why it is loaded last.
# 4. Any plugins that are identified, are also sourced
#
# :Arguments: ``$1`` - The project settings filename (e.g., vsi_common.env)
#
# .. _source_environment_files:
#
# :Parameters: * [``JUST_LOCAL_SETTINGS``] - Path to the local settings file. Default: ${same_dir}/local.env
#              * [``JUST_LOCAL_SETTINGS_POST``] - Path to the post local settings file. Default: ${same_dir}/local_post.env
#
# .. rubric:: Usage
#
# ``JUST_LOCAL_SETTINGS`` and ``JUST_LOCAL_SETTINGS_POST`` must not be set in any of the the project's settings files or plugins, as it will not have the desired effect. Instead, they should either be manually set in the environment or set in the setup script (see :envvar:`JUST_SETUP_SCRIPT`)
#
# .. note::
#   Certain exceptions to not storing values in the project settings file make sense such as credentials, encryption keys, etc... information that should not be hard-coded ever.
#
#
#   Only require settings in ``local.env`` when it cannot be avoided. For example, it might be reasonable to use openssl to create ssl certs in a default location (that is ignored by version control).
#
# .. seealso::
#
#   :func:`just_common.bsh _just_get_plugins` :envvar:`JUST_SETUP_SCRIPT`
#**

function source_environment_files()
{
  local project_dir="$(dirname "${1}")"
  local x

  # In case there are multiple calls to source_environment files, create an
  # exportable list of all the file names. Since arrays can't be exported
  x="$(cd "${project_dir}"; pwd)/${1##*/}"

  if [ -z "${JUST_SETTINGS+set}" ]; then
    # First settings env file
    JUST_SETTINGS="${x}"
  else
    # Additional settings env file
    JUST_SETTINGS="${JUST_SETTINGS}${JUST_SETTINGS_SEPARATOR}${x}"
  fi

  export JUST_SETTINGS

  local JUST_LOCAL_SETTINGS="${JUST_LOCAL_SETTINGS-}"
  local JUST_LOCAL_SETTINGS_POST="${JUST_LOCAL_SETTINGS_POST-}"
  create_local_settings_file "${1}" || :

  # if [ ! -e "${JUST_LOCAL_SETTINGS_POST}" ]; then
  #   echo "# Put local setting in this file" > "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# Use this file ONLY when you need the values from" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# \"${1}\"" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo >> "${JUST_LOCAL_SETTINGS_POST}" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# Values set in this file will not be reflected in" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# \"${JUST_LOCAL_SETTINGS}\" or" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# \"${1}\". To get variable substitution" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# in these files, consider using \"${JUST_LOCAL_SETTINGS}\"" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# NEVER commit this file. Tracked environment changes go in" >> "${JUST_LOCAL_SETTINGS_POST}"
  #   echo "# \"${1}\" only" >> "${JUST_LOCAL_SETTINGS_POST}"
  # fi

  # Load plugins
  _just_get_plugins "${project_dir}"
  for just_plugin in ${JUST_PLUGINS[@]+"${JUST_PLUGINS[@]}"}; do
    source "${just_plugin}"
  done

  set_flag a
  for x in "${JUST_LOCAL_SETTINGS}" \
           "${1}" \
           "${JUST_LOCAL_SETTINGS_POST}"; do
    if [ -f "${x}" ]; then
      source "${x}"
    fi
  done
  reset_flag a

  # There is a feature of the set -a builtin in bash that will actually export
  # functions. While we don't need this, it is normally harmless. However in the
  # macOS case, sh somehow gets invoked by python on start, and thus complains
  # if a function name with a hyphen in it has been exported. Again, this is
  # harmless but annoying
  while IFS= read -r x || [[ -n ${x} ]] ; do
    x=${x##* }
    if [[ ${x} = *-* ]]; then
      export -fn $x
    fi
  done < <(declare -Fx)
}

#**
# .. function:: create_local_settings_file
#
# :Arguments: ``$1`` - Path to the settings file
#
# :Parameters: [``JUST_LOCAL_SETTINGS``] - The location to create the local settings file
#              [``JUST_LOCAL_SETTINGS_POST``] - The location to create the post local local settings file
#
# :Return Value: * ``0`` - Settings file was created
#                * ``1`` - Settings file was not created
#
# :Output: [``JUST_LOCAL_SETTINGS``] - Path to the local settings file. Default: ${same_dir}/local.env
#          [``JUST_LOCAL_SETTINGS_POST``] - Path to the post local settings file. Default: ${same_dir}/local_post.env
#
# Try to create the local.env settings file
#
# Create the local.env settings file if a) it does not already exist and b) it will be owned by the correct user.
#**

# REVIEW Revert these changes: aa99afe
function create_local_settings_file()
{
  local project_dir="$(dirname "${1}")"
  JUST_LOCAL_SETTINGS="${JUST_LOCAL_SETTINGS:-${project_dir}/local.env}"
  JUST_LOCAL_SETTINGS_POST="${JUST_LOCAL_SETTINGS_POST:-${project_dir}/local_post.env}"

  if [ ! -e "${JUST_LOCAL_SETTINGS}" ]; then
    local project_file="$(basename "${1}")"

    local perm
    if [ -e "${1}" ]; then
      perm=$(_get_owner_id "${1}")
    else
      perm=$(_get_owner_id "${project_dir}")
    fi

    # If the current user is the same one who owns the repo files, then generate
    # the local file. This prevents other users from creating local.env files in
    # your directory by accident
    if [ "${perm}" = "$(id -u)" ]; then
      echo "# Put local setting in this file" 2>/dev/null > "${JUST_LOCAL_SETTINGS}" &&
      {
        echo "# You should edit this file and not \"${project_file}\"" >> "${JUST_LOCAL_SETTINGS}"
        echo "# to customize setting just for your setup/computer" >> "${JUST_LOCAL_SETTINGS}"
        echo >> "${JUST_LOCAL_SETTINGS}"
        echo "# If you need a value from \"${project_file}\" to set a custom" >> "${JUST_LOCAL_SETTINGS}"
        echo "# value, use \"$(basename "${JUST_LOCAL_SETTINGS_POST}")\"" >> "${JUST_LOCAL_SETTINGS}"
        echo >> "${JUST_LOCAL_SETTINGS}"
        echo "# NEVER commit this file. Tracked environment changes go in" >> "${JUST_LOCAL_SETTINGS}"
        echo "# \"${project_file}\" only" >> "${JUST_LOCAL_SETTINGS}"
        return 0
      } || : # <== Fix for #84
    fi
  fi
  # Settings file was not created: either it already existed or something else
  # went wrong (e.g., no permissions)
  return 1
}

#**
# .. function:: translate_just_settings
#
# Convert :envvar:`JUST_SETTINGS` to an array: ``JUST_SETTINGSS``, translating the paths to another filesystem
#
# :Arguments: - ``$1`` - Directory name to be translated from
#             - ``$2`` - Directory name to translate to
# :Output: ``JUST_SETTINGSS`` - Array of the translated paths
#
# Useful for translating :envvar:`JUST_SETTINGS` from host to a container.
#
# .. seealso::
#   :func:`container_functions.bsh translate_path`
#**
function translate_just_settings()
{
  JUST_SETTINGSS=()
  MIFS="${JUST_SETTINGS_SEPARATOR}" split_s JUST_SETTINGSS ${JUST_SETTINGS+"${JUST_SETTINGS}"}
  local i
  for i in ${JUST_SETTINGSS[@]+"${!JUST_SETTINGSS[@]}"}; do
    JUST_SETTINGSS[i]="$(translate_path "${JUST_SETTINGSS[i]}" ${@+"${@}"})"
  done
}

#**
# .. function:: auto_path_escape
#
# Automatically add an escape character to paths that match a pattern
#
# TODO: Explain
#
# .. seealso::
#
#   :file:`just_env`
#**

function auto_path_escape()
{
  local var
  local value
  local auto_vars="${JUST_PROJECT_PREFIX}_AUTO_ESCAPE"
  auto_vars="${!auto_vars-\$^}"

  for var in $(compgen -A export); do
    if [[ ${var} =~ ${auto_vars} ]]; then
      value="${!var}"
      if [ -n ${#value} ] && [ "${value:0:1}" = "/" ]; then
        if [ ${#value} -gt 1 ]; then
          # If it doesn't already have two //
          if [ "${value:1:1}" != "/" ]; then
            export "${var}=/${value}"
          fi
        else
          # This is basically the / corner case
          export "${var}=/${value}"
        fi
      fi
    fi
  done
}

#**
# .. function:: set_temp_array
#
# :Arguments: - ``$1`` - Name of array to check if it is already set
#             - ``$2...`` - Default values of the array
#
# :Output: ``JUST_TEMP_ARRAY`` - Destination for all the values set
#
# DEPRECATED: Set array to default values if not already set.
#
# In bash, when setting a variable to a default value if it has not already been set, it is typical to follow the pattern:
#
#   ``: ${MY_VAR=default}``
#
# However, this syntax does not work for an array. Bash 3.2 does not give an equivalent one line version of this. Instead, using :func:`set_temp_array`, JUST_TEMP_ARRAY can be set to a default value if not already set (albeit, in two lines).
#
# It works by checking if an array is set. If it is, it copies all the values to the array JUST_TEMP_ARRAY. If it is not, it will copy the rest of the arguments (the default values) to ``JUST_TEMP_ARRAY``. When using this function with set -u turned on, it is best to reference ``JUST_TEMP_ARRAY`` by (${JUST_TEMP_ARRAY[@]+"${JUST_TEMP_ARRAY[@]}"}) in case the array is empty, as this triggers bash's unbound variable test.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#     set_temp_array MY_ARRAY default1 default\ 2 "default 3"
#     MY_ARRAY=(${JUST_TEMP_ARRAY[@]+"${JUST_TEMP_ARRAY[@]}"})
#
#     # And when done, clean up
#     unset JUST_TEMP_ARRAY
#
# .. seealso::
#
#   :func:`set_array_default`
#**

function set_temp_array()
{
  echo "set_temp_array is deprecated: use set_array_default" >&2
  local default="${1}"
  shift
  if declare -p $default &> /dev/null; then
    default="${default}[@]"
    JUST_TEMP_ARRAY=(${!default+"${!default}"})
  else
    JUST_TEMP_ARRAY=(${@+"${@}"})
  fi
}

#**
# .. function:: set_array_default
#
# :Arguments: ``$1`` - Name of array to check if it is already set
#
#             ``$2...`` - Default values of the array
#
# Set array to default values if not already set.
#
# In bash, when setting a variable to a default value, if it has not already been set, it is typical to follow the pattern:
#
#   ``: ${MY_VAR=default}``
#
# However, this syntax does not work for an array. Bash 3.2 does not give an equivalent one line version of this. Instead, using :func:`set_array_default`, an array can be set to a default value if not already set (albeit, in two lines).
#
# It works by checking if an array is set. If it is set, nothing happens. If it is not set, it will copy the rest of the arguments (the default values) to the array named.
#
# .. note::
#
#     An empty array counts as set
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#     set_array_default MY_ARRAY default1 default\ 2 "default  3"
#**

function set_array_default()
{
  local _set_array_default_index

  # Handle case if using indirect variable name
  if [ "${1}" = "default" ]; then
    shift 1
    default=(${@+"${@}"})
  fi

  local default="${1}"
  shift 1

  if ! declare -p "${default}" &> /dev/null; then
    local IFS=''
    if [ "${bash_feature_declare_global}" = "0" ]; then
      declare -ag "${default}=()"
    else
      eval "${default}=()"
    fi
    for (( _set_array_default_index=0; $#; _set_array_default_index++ )); do
      read -r "${default}[$_set_array_default_index]" <<< "${1}"
      shift 1
    done
  fi
}

#**
# .. function:: pretty_print_help
#
# :Arguments: *stdin* - Each line is an entry in the pretty printout, separated by " ${:envvar:`JUST_HELP_SEPARATOR`} " (without the quotes, but with the spaces)
#
# :Parameters: indent - How much the right side should be indented to make a uniform output
#
# Restructures text to indent properly on wrap around
#
# Each line consists of a command that will be printed on the left, and the indented description on the right. The description is wrapped around based on tput cols.
#
# .. seealso::
#
#   :envvar:`JUST_HELP_SEPARATOR`
#**

function pretty_print_help()
{
  # This patch is mainly for wine, where tput doesn't work for some reason
  local cols=$(tput cols 2>/dev/null)
  if [ "${cols}" = "" ]; then
    cols=80
  fi

  awk -F " ${JUST_HELP_SEPARATOR}" '
   function min(a, b)
   {
     if (a<b)
       return a
     return b
   }
   {
    indent='${indent}'
    printf "%-'$(($indent-1))'s", $1
    n = split($2,x," ")
    len = '${indent}'
    width = '"${cols}"'
    for(i=1;i<=n;i++)
    {
     if(len+length(x[i])>width)
     {
      long=x[i]
      for(j=1;j<length(long);j+=width-indent)
      {
       # If this is not the beginning of the right column, newline it. This
       # condition prevents blank lines being inserted for these long words
       if(len != indent)
       {
        printf("\n%'$((indent-1))'s", "")
        len = indent
       }
       # Print what is available
       printf(" "substr(long, j, width-len))
       # Calculate the amount added
       len += min(width-len+1, length(long)-j+1+1)
       # If len exceeds width, then make a new line
       if (len>=width)
       {
        printf("\n%'$((indent-1))'s", "")
        len = indent
       }
      }
     }
     else
     {
      printf " %s",x[i]
      len += 1+length(x[i])
     }
    }
    printf "\n"
  }' # c/o https://unix.stackexchange.com/a/280205/123413
}

#**
# .. function:: print_help
#
# Prints the auto generated help info from Justfile
#**

function print_help()
{
  local cols=$(tput cols 2>/dev/null)
  if [ "${cols}" = "" ]; then
    cols=80
  fi
  local indent=4
  local parsed_help parsed_help_flags parsed_help_subcommands_commented
  local parsed_help_a
  local help_line

  echo
  echo "List of possible $(basename "$0") commands:"
  echo "-----------------------------------"

  # Get help data => parsed_help_a
  _just_parse_helps ${JUST_HELP_FILES[@]+"${JUST_HELP_FILES[@]}"}

  # Determine the ideal indent width for commands
  while IFS='' read -r help_line || [[ -n "${help_line}" ]]; do
    if (( ${#help_line} > indent-2 )); then
      indent=$((${#help_line}+2))
    fi
  done < <(IFS=$'\n'; echo "${parsed_help_a[*]}" | \
                      sed -${sed_flag_rE} \
                             's| '"${JUST_HELP_SEPARATOR}"'.*||;
                              /^[?*a-zA-Z0-9\-]+_[?*a-zA-Z0-9_\-]+/d') #;
                              # Remove sub commands for this

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  {
    # Print non-flag first and non-subcommand_subtargets
    {
      grep -E -v '^-|^[?*a-zA-Z0-9\-]+_[?*a-zA-Z0-9_\-]+' | sort
    } <<< "${parsed_help_a[*]}"

    # Print flags second
    {
      grep -E '^-[?*a-zA-Z0-9\|\-]+( |$)' | sort
    } <<< "${parsed_help_a[*]}"
  } | pretty_print_help
  IFS="${OLD_IFS}"

  echo
  echo "Subcommands"
  echo "-----------"

  local just_subcommands=()
  local just_subtargets
  local subcommand
  local subtarget
  local subtarget_name
  local parsed_help_subcommands=""

  indent=5

  # Determine the ideal indent width for commands
  while IFS='' read -r help_line || [[ -n "${help_line}" ]]; do
    if (( ${#help_line} > indent-2 )); then
      indent=$((${#help_line}+2))
    fi
  done < <(IFS=$'\n'; echo "${parsed_help_a[*]}" | \
                      sed -${sed_flag_rE} 's| '"${JUST_HELP_SEPARATOR}"'.*||;
                                           /^[?*a-zA-Z0-9\-]+_[?*a-zA-Z0-9_\-]+/!d;
                                        '$'s:\|:\\\n:g')

  IFS=$'\n'
  #WARNING: Susceptible to wildcard expansion (what if a subcommand is literal *)
  just_subcommands=($(_just_subcommands_from_array <<< "${parsed_help_a[*]}"))
  IFS="${OLD_IFS}"

  # Sort the subcommands
  if [ "${just_subcommands+set}" == "set" ]; then
    IFS=$'\n'
    #WARNING: Susceptible to wildcard expansion (what if a subcommand is literal *)
    just_subcommands=($(sort -u <<<"${just_subcommands[*]}"))
    IFS="${OLD_IFS}"
  fi

  for subcommand in ${just_subcommands[@]+"${just_subcommands[@]}"}; do
    parsed_help_subcommands+="${subcommand}"$'\n'

    # Get list of subtargets
    just_subtargets=()
    # Get all the subtargets already parsed by the helpfile
    _just_subtargets_from_array "${subcommand}" ${parsed_help_a[@]+"${parsed_help_a[@]}"}

    # Sort the subtargets
    if [ "${just_subtargets+set}" == "set" ]; then
      # Prevent expansion and allow for spaces, etc...
      local just_subtargets2=()
      while IFS= read -r -d '' help_line || [ -n "${help_line}" ]; do
        just_subtargets2+=("${help_line}")
      done < <(MIFS='\\x00' join_a_out "${just_subtargets[@]}" | sort -u -z)
      just_subtargets=("${just_subtargets2[@]}")
    fi

    for subtarget in ${just_subtargets[@]+"${just_subtargets[@]}"}; do
      for help_line in "${parsed_help_a[@]}"; do
        subtarget_name="${subcommand}_${subtarget}"
        if [ "${help_line::${#subtarget_name}+1}" = "${subtarget_name} " ]; then
          parsed_help_subcommands+="    ${help_line#*_}"$'\n'
          break
        fi
        help_line=
      done
      if [ "${help_line}" == "" ]; then
        parsed_help_subcommands+="    ${subtarget}"$'\n'
      fi
    done
  done

  pretty_print_help <<< "${parsed_help_subcommands%$'\n'}"
}

#**
# .. function:: is_powershell
#
# Check if the current command window is powershell
#
# Using a Window's title trick, determine if the shell is running in powershell or some other shell (e.g., Windows command prompt, cygwin or git bash)
#**

function is_powershell()
{
  if [ "${JUST_IS_TTY-0}" == "1" ]; then
    return 0
  fi

  local unique_title="$(basename "$(mktemp -u -t XXXXXXXXXXXXXXXX)")"

  echo -en "\033]0;${unique_title}\a"
  if [ $(MSYS_NO_PATHCONV=1 tasklist /fi "windowtitle eq ${unique_title}" | tail -n 1 | awk '{print $1}') == "powershell.exe" ]; then
    return 0
  else
    return 1
  fi
}

#**
# .. function:: need_tty
#
# Check to see if a tty is missing. Normal tty checks do not work in mintty, as the pts appears to be a tty to native apps, but external apps will see a pipe. Checking to see if stdin has a name of "None" will tell us if we don't have a piped stdin.
#
# Calling this function is an expensive operation, and takes roughtly 1-2 seconds (to call a new powershell). Setting JUST_IS_TTY to 1 will cause the function to return false instantly.
#
# :Parameters: [``JUST_IS_TTY``] - If set to `1``, need_tty automatically returns 1. If set to ``0``, then :func:`need_tty` will automatically returns 0 once.
#
# If ``JUST_IS_TTY`` is set in a ``local.env`` file, then it should be set conditionally:
#
# .. code-block:: bash
#
#     : ${JUST_IS_TTY=0}
#
# This way it is triggered only once, instead of everytime ``local.env`` is source, which can be quite frequently.
#
# One use case for this is "ssh from linux into windows, start git bash, . setup.env, and then run python". This will detect a fake tty name, because it is piped. However, you still need a tty because in python up and down will not work. I do not know why in this case...
#
# .. seealso::
#
#   https://tinyurl.com/yb5jjzqt
#**

function need_tty()
{
  if [ "${OS-}" != "Windows_NT" ] || [ "${JUST_IS_TTY-}" = "1" ]; then
    return 1
  elif [ "${JUST_IS_TTY-}" = "0" ]; then
    return 0
  else
     # If stdin has a name, it's probably a mintty, etc... something with a pty
     # that's really a pipe emulating tty to external app
    local stdin_name="$(powershell -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "${VSI_COMMON_DIR}/windows/get_stdin_name.ps1")"
    # This happens if you ssh into windows directly. If I ssh into WSL, then
    # SSH_TTY will be somethinhg like /dev/pty/*. I'm not yet sure if that
    # needs a winpty, but at the same time I don't support WSL, so I'm choosing
    # to not care about it right now.
    if [ "${SSH_TTY-}" = "windows-pty" ]; then
      # I'm not sure why, but ssh pty needs a winpty for python -i to work
      return 0
    elif [ "${stdin_name}" = "None" ]; then
      return 1
    elif [[ ${stdin_name} != *-from-master ]]; then
      return 1
    fi
  fi
  # elif [[ $(uname) = MINGW* ]] && [[ $(tty) = /dev/pty* ]]; then
  return 0
}

#**
# .. function:: setup_tty
#
# Pops up a new powershell window and runs just
#
# Cygwin bash is pretty bad. The new git bash (MINGW64) does not have a tty. This is a problem for docker. Powershell does have a tty, but cannot run bash scrips natively. The solution is to run bash in powershell (which is not as straight forward as it sounds). This function is designed to re-execute in a new powershell on Windows if not in powershell
#
# :Parameters: [``JUST_PTY``] - PTY app to use create a psuedoterminal for windows apps. By default, uses ``winpty``. Set to ``powershell`` for the old behavior
#
# .. rubric:: Usage
#
# setup_tty ${@+"${@}"}
#**

function setup_tty()
{
  if need_tty; then
    local JUST_PTY="${JUST_PTY-winpty}"
    if [ "${JUST_PTY}" != "powershell" ] && command -v "${JUST_PTY}" &> /dev/null; then
      JUST_IS_TTY=1 ${JUST_PTY} bash "$0" ${@+"${@}"}
      JUST_IS_TTY=1 exec ${JUST_PTY} bash --rcfile "${VSI_COMMON_DIR}/.winbashrc"
    else
      JUST_IS_TTY=1 exec start powershell "cmd /c color 07; bash \"$0\" ${@}; bash --rcfile \"${VSI_COMMON_DIR}/.winbashrc\""
    fi
  fi
}

#**
# .. function:: defaultify
#
# Default commands for just
#
# Handles a few default commands for just:
#
# - Calls plugins specified in :envvar:`JUST_DEFAULTIFY_FUNCTIONS`
# - --dryrun|-n - Sets DRYRUN to :func:`print_command print_command`. This way ${DRYRUN} can be put in front of any command and be printed instead of executed when in dryrun mode
# - --separator - Used to override the :envvar:`JUST_SEPARATOR` (default --) to anything else. This only affect commands that use get_args
# - -h|--help|help - Prints out help using print_help
# - _null - A target that does nothing. This is seldom needed.
# - * - For all other commands not captured yet, called unknownify (which can
#       be overridden for other behavior) to print an error message.
#**

function defaultify()
{
  local arg
  local rv
  local plugin_not_found

  # Loop through the plugins, and call them
  for arg in ${JUST_DEFAULTIFY_FUNCTIONS[@]+"${JUST_DEFAULTIFY_FUNCTIONS[@]}"}; do
    plugin_not_found=0
    ${arg} ${@+"${@}"}
    if [ "${plugin_not_found-}" != "1" ]; then
      return 0
    fi
  done

  arg="${1}"
  shift 1
  case "${arg}" in
    --dryrun|-n) # Dryrun flag. Used to echo instead of run commands
      source "${VSI_COMMON_DIR}/linux/print_command"
      export DRYRUN="print_command_env just --wrap"
      print_command_save_env
      ;;
    --separator) # Commands that can take an undefined number of additional \
                 # arguments use the -- separator to start and end the extra \
                 # arguments. If -- is needed for other things, specify a custom \
                 # separator
      JUST_SEPARATOR="${1}"
      extra_args=1
      ;;
    --version) # Print version
      echo "${0##*/} version ${JUST_VERSION}"
      ;;
    --new) # Run the new just wizard
      "${VSI_COMMON_DIR}/linux/just_files/new_just" ${@+"${@}"}
      extra_args=$#
      ;;
    --latest) # Print latest juste version install instructions
      (
        current_version=$(juste --version | awk '{print $NF}')
        if command -v curl &> /dev/null; then
            url="$(curl -sL https://api.github.com/repos/visionsystemsinc/just/releases | \
                  sed -${sed_flag_rE}n '/"browser_download_url": ".*juste"/{
                            s/ *"browser_download_url": "(.*juste)"/\1/;
                            p;
                            q;}')"
            [[ ${url} =~ https://github.com/VisionSystemsInc/just/releases/download/(.*)/juste ]]
            version="${BASH_REMATCH[1]}"
            if [ "${version}" = "${current_version}" ]; then
              echo "You are already up to date (${version})" >&2
            else
              echo "To install the latest juste:" >&2
              echo "sudo curl -o \"$(which juste)\" -L \"${url}\""
            fi
        elif command -v wget &> /dev/null; then
            url="$(wget -qO- https://api.github.com/repos/visionsystemsinc/just/releases | \
                  sed -${sed_flag_rE}n '/"browser_download_url": ".*juste"/{
                            s/ *"browser_download_url": "(.*juste)"/\1/;
                            p;
                            q;}')"
            [[ ${url} =~ https://github.com/VisionSystemsInc/just/releases/download/(.*)/juste ]]
            version="${BASH_REMATCH[1]}"
            if [ "${version}" = "${current_version}" ]; then
              echo "You are already up to date (${version})" >&2
            else
              echo "To install the latest juste:" >&2
              echo "sudo wget -O \"$(which juste)\" \"${url}\""
            fi
        # elif command -v python &> /dev/null; then
        #   :
        # elif command -v powershell &> /dev/null; then
        #   :
        else
          echo "You don't have a supported web downloader installed" >&2
          false
        fi
      )
      ;;
    --wrap) # Wraps command with Just_wrap ... Useful for just executable
      exec "${VSI_COMMON_DIR}/linux/just_files/Just_wrap" ${@+"${@}"}
      ;;
    --run) # Run arbitrary command in just environment
      ${@+"${@}"}
      extra_args=$#
      ;;
    --tab) # Tab complete script (takes about 300ms). Usage: source <(juste --tab)
      if [ "$#" = "0" ]; then
        echo 'function _juste()'
        echo '{'
        #WARNING: Susceptible to wildcard expansion (what if a command is literal *)
        echo '  COMPREPLY=($(juste --tab "${1}" "${2}" "${3}" ${COMP_WORDS[@]+"${COMP_WORDS[@]}"}))'
        echo '}'
        echo 'complete -F _juste juste'
      else
        source "${VSI_COMMON_DIR}/linux/just_files/.just"
        local one="${1}"
        local two="${2}"
        local three="${3}"
        local COMP_WORDS

        shift 3
        extra_args=3

        COMP_WORDS=(${@+"${@}"})

        _just "${one}" "${two}" "${three}" ${@+"${@}"}
        echo "${COMPREPLY[*]}"
        extra_args=$#
      fi
      ;;
    -h|--help|help) # Print help
      print_help
      ;;
    _null)
      ;;
    *)
      unknownify "${arg}" ${@+"${@}"}
      ;;
  esac
}

#**
# .. function:: unknownify
#
# :Parameters: ``JUST_FILE_NOT_FOUND`` - Prints out a different message if ``JUST_FILE_NOT_FOUND`` is set to ``1``
#
# The function executed when an unknown target is specified
#
# The default behavior is to print an error and exit 1. However, a custom unknownify can be declared in Justfile to override this behavior
#**

function unknownify()
{
  if [ "${JUST_FILE_NOT_FOUND-}" = "1" ]; then
    source "${VSI_COMMON_DIR}/linux/colors.bsh"

    echo "${RED}Can't find a suitable configuration file in this directory or any" >&2
    echo "parent. Are you in the right directory?${NC}" >&2
    echo >&2
    echo "Supported filenames: ${YELLOW}\"Justfile\" or value of \${JUSTFILE} (${JUSTFILE-unset})${NC}" >&2
    echo >&2
    exit 1
  else
    echo "I don't understand: ${1}" >&2
    exit 1
  fi
}

#**
# .. var:: extra_args
#
# The number of additional arguments consumed in a caseify target
#
# When writing a caseify target, by default one argument is consumed. This is enough for any simple target. However some targets need additional arguments.
#
# There are really three situation when extra arguments are needed
#
# #. A fixed number of arguments. For example, if 3 arguments are needed, just use $1, $2, $3, and set ``extra_args=3``
# #. The rest of the arguments are going to be consumed. In this case, use all the arguments (typically by $@) and set extra_args=$#
# #. An unknown number of arguments need to be used, and maybe multiple groups of unknown arguments. This is the case where JUST_SEPARATOR is used. (See EXAMPLE)
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#    # Lets say we call:
#
#    just test 11 22 33 -- aa bb cc dd -- _null
#
#    # test is called with 3 arguments
#    # aa is called with 3 arguments
#    # _null is called
#
# .. rubric:: The deprecated way
#
# .. code-block:: bash
#
#   # Lets say we call:
#
#     just test -- 11 22 33 -- aa bb cc dd -- _null
#
#     # And I have a target test that takes two sets of arguments of unknown length
#
#   test)
#     get_args ${@+"${@}"}
#     first=${args[@]+"${args[@]}"}
#     get_additional_args ${@+"${@}"}
#     second=${args[@]+"${args[@]}"}
#     ;;
#
# In this case, there is no need to add :var:`extra_args`, :func:`get_args` does this already
#**

declare -i extra_args

#**
# .. function:: justify
#
# :Arguments: ``$1...`` - list of targets
#
# The main loop of just
#
# Handles determining what subcommands are and calling commands and subcommands.
#
# When one target is called from another target, justify should be used to do the calling, for example:
#
#   justify target2
#**

function justify()
{ # caseify needs to be written by the main script, and set the number
  # of extra arguments it consumes to extra_args
  local extra_args_orig=${extra_args-0}
  # Cache list of subcommands
  local just_subcommands=()
  local just_subtargets

  local parsed_help_a
  # Get help data => parsed_help_a
  _just_parse_helps ${JUST_HELP_FILES[@]+"${JUST_HELP_FILES[@]}"}

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  #WARNING: Susceptible to wildcard expansion (what if a subcommand is literal *)
  just_subcommands=($(_just_subcommands_from_array <<< "${parsed_help_a[*]}"))
  IFS="${OLD_IFS}"

  local index
  while (( $# > 0 )); do
    index=$(findin "${JUST_SEPARATOR}" "${@}")
    if [ "${index}" == "-1" ]; then
      _justify "${@}"
      break
    else
      _justify "${@:1:$index}"
      shift $((index+1))
    fi
  done

  extra_args=${extra_args_orig}
}

function _justify()
{
  while (( $# > 0 )); do
    extra_args=0

    if [ "${JUST_VERBOSE-0}" -ge "1" ]; then
      echo "Searching justify: ${@}" >&2
    fi

    # If it's a subcommand
    if isin "${1}" ${just_subcommands[@]+"${just_subcommands[@]}"}; then
      just_subtargets=()
      # Get all the subtargets already parsed by the helpfile
      _just_subtargets_from_array "${1}" ${parsed_help_a[@]+"${parsed_help_a[@]}"}

      # If it's a valid target, call them, else use default caseify
      if (( $# >= 2 )) && isin "${2}" ${just_subtargets[@]+"${just_subtargets[@]}"}; then
        local target="${1}_"
        shift 1

        # Execute all subtargets
        while (( $# > 0 )) && isin "${1}" ${just_subtargets[@]+"${just_subtargets[@]}"}; do
          extra_args=0
          if command -v caseify &> /dev/null; then
            caseify "${target}${@}"
          else
            defaultify "${target}${@}"
          fi
          if (( $extra_args+1 > $# )); then
            source "${VSI_COMMON_DIR}/linux/colors.bsh"
            echo "${RED}JUST ERROR${NC}: Not enough arguments for \"${target}${1-}\" target" >&2
          fi
          shift $extra_args
          shift 1
        done
        continue
      else
        if command -v caseify &> /dev/null; then
          caseify "${@}"
        else
          # If caseify isn't found, just call defaultify. This is useful for
          # commands that don't require a Justfile
          defaultify "${@}"
        fi
      fi
    else
      if command -v caseify &> /dev/null; then
        caseify "${@}"
      else
        defaultify "${@}"
      fi
    fi
    if (( $extra_args+1 > $# )); then
      source "${VSI_COMMON_DIR}/linux/colors.bsh"
      echo "${RED}JUST ERROR${NC}: Not enough arguments for \"${target}${1-}\" target" >&2
    fi
    shift $extra_args
    shift 1
  done
}

#**
# .. function:: callify
#
# Helper for consuming arguments and calling a function with them
#
# Takes: cmd -- $1 $2 $3 ... $n -- $m $m+1 ...
# and calls: cmd $1 $2 $3 ... $n and consumes n+2 args
# Trailing -- is optional
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   target)
#     callify python ${@+"${@}"}
#     ;;
#
#   just target -- -c "print 1+3"
#
# .. note::
#
#   Not sure this is worth keeping
#**

function callify()
{
  local cmd
  cmd="${1}"
  shift 1
  get_args ${@+"${@}"}
  $cmd ${args[@]+"${args[@]}"}
}

#**
# .. function:: get_args
#
# :Arguments: Inputs ``$@`` - All the unconsumed arguments
#
# :Output: ``args`` - Array of unknown number of arguments consumed
#          ``get_args_args_used`` - Number of arguments used, including separator
#
# Get and consume an unknown collection of arguments
#
# Gets an unknown number of arguments. The ending of the collection of arguments is annotated with the :envvar:`JUST_SEPARATOR`. The trailing annotation is optional as long as there are no more just commands following
#
# .. rubric:: Bugs
#
# This will conveniently update ``extra_args`` inside of the Justfile caseify function. However, if you are calling from another function (i.e., not writing a caseify section), this will produce incorrect behavior; therefore, extra_args should be made a local variable in the calling function
#
# .. note::
#
#   ``get_args_args_used`` is a global variable. Unsetting it can cause unexpected
#   behavior
#**

declare -i get_args_args_used
function get_args()
{
  local next_break

  args=()
  : ${extra_args=0}
  get_args_args_used=${pre_args_used-0}
  if (( $# >= 1 )); then
      # Look to see if there is another --
      next_break=$(findin "${JUST_SEPARATOR}" ${@+"${@}"})
      if [ "${next_break}" == -1 ]; then
        args=("${@}")
        get_args_args_used+=$#
        extra_args+=$#
      else
        # When you slice @, the default ${@:1} (which is the same as ${@})
        # becomes ${@:0:x}, so you have to specify ${@:1:x}. @ is "special".
        # That's why I can't say ${@::$next_break}
        args=("${@:1:${next_break}}")
        # Plus one since the index count starts from 0, not 1
        get_args_args_used+=${next_break}+1
        extra_args+=${next_break}+1
      fi
  fi
}

#**
# .. function:: get_additional_args
#
# Get and consume additional collections of arguments
#
# :func:`get_args` can only be called once, but :func:`get_additional_args` can be called continuously after the first call of :func:`get_args`
#
# .. rubric:: Example
#
# Must be called after :func:`get_args` with all arguments passed in. For example:
#
# .. code-block:: bash
#
#   target)
#     get_args ${@+"${@}"}
#     args1=(${args[@]+"${args[@]}"})
#     get_additional_args ${@+"${@}"}
#     args2=(${args[@]+"${args[@]}"})
#     get_additional_args ${@+"${@}"}
#     args3=(${args[@]+"${args[@]}"})
#     ;;
#
#  just target 11 22 33 -- aa bb cc -- '!!' '@@' '##'
#
#  #args1=(11 22 33)
#  #args2=(aa bb cc)
#  #args3=(!! @@ ##)
#**

function get_additional_args()
{
  local pre_args_used

  if [ "${get_args_args_used}" -gt "0" ]; then
    # Copy this var so get_args knows it's not being called for the first time
    pre_args_used=${get_args_args_used}
    # Skip the args already used last time get_args/get_additional_args was called
    shift ${get_args_args_used}
    get_args "${@}"
  fi
}

#**
# .. function:: safe_load
#
# A non-eval method for loading and exporting a text file of keys/values
#
# :Arguments: Inputs ``$1`` - Filename of file to be loaded
#
# :Parameters: [:envvar:`JUST_SAFE_LOAD_DELIMITER`] - By default, = is used between key and value. If = is needed, then this environment variable can override the delimiter.
#
# :Output: All keys are set as environment variables and exported
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   key1=value_one
#   key2=this is another value
#
# .. note::
#
#   Does not support comments, blank lines, or anything else other than key=value
#
# .. rubric:: Bugs
#
# As with anything in a language like bash, it's not guaranteed that an arbitrary command won't be executed with this, but as far as is known, there are no known issues with this function.
#**

function safe_load() # Loads a very simple safe config file, and sets environment variables accordingly
{ # File should contain lines: key=value
  local safe_load_tmp_key=foobar
  local safe_load_tmp_value
  local line
  while IFS='' read -r line || [[ -n "${line}" ]]; do
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key safe_load_tmp_value <<< "${line}"
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key "${safe_load_tmp_key}" <<< "${line}"
    export "${safe_load_tmp_key}"
  done < "${1}"
}

#**
# .. file:: .justplugins
#
# Plugin file
#
# The filename defaults to .justplugins and sits next to your Justfile, but can be overridden by exporting the environment variable :envvar:`JUST_PLUGIN_FILE`.
#
# Lists the various plugin files. Blank lines and # comment lines are allowed
#**
