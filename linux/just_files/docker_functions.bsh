#!/usr/bin/env false bash

if [[ ${-} != *i* ]]; then
  source_once &> /dev/null && return 0
fi

if [ -z "${VSI_COMMON_DIR+set}" ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"
fi

source "${VSI_COMMON_DIR}/linux/mount_tools.bsh"
source "${VSI_COMMON_DIR}/linux/just_files/docker_compose_override"
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
source "${VSI_COMMON_DIR}/linux/compat.bsh"
source "${VSI_COMMON_DIR}/linux/aliases.bsh"

#*# just/plugins/docker/docker_functions

#**
# ================
# Docker Functions
# ================
#
# .. default-domain:: bash
#
# .. file:: docker_functions.bsh
#
# Set of functions to make using dockers easier
#
# .. var:: DOCKER_VOLUME_PATTERN
#
# Regex pattern for matching docker volume short form
#
# .. note::
#   Works on:
#     C:\*, c:/* .* /* - '^(([a-zA-Z]:[/\])?[^:]*)'
#
#   Break the volume string up into ``BASH_REMATCH``
#    1 - Host path
#    2 - Docker path
#    3 - flags
#**
# https://www.debuggex.com/r/lJRoX_sSnhOKpEER
DOCKER_VOLUME_PATTERN='^([a-zA-Z]:[/\][^:]*|[^:]+):([a-zA-Z]:[/\][^:]*|[^:]+)((:ro|:rw|:z|:Z|:r?shared|:r?slave|:r?private|:delegated|:cached|:consistent|:nocopy)*)$'
#**
# .. function:: is_dir_and_not_exist
#
# :Arguments: ``$1`` - String to check
# :Output: Returns ``0`` for is a directory, and ``1`` for not a directory (is an internal mount)
#
# See if the string looks like a non-existing directory
#
# Docker currently creates directories that do not exist when mounting. This
# has a few bad side effects, such as the directories end up being own by root.
# In order to work around this "bug", this function identifies if docker will
# assume a string is a directory/file or an internal mount.
#
# .. rubric:: Example
# .. code-block:: bash
#
#     is_dir_and_not_exist this_looks_like_an_internal_volume
#     is_dir_and_not_exist ./this_looks/like_a/directory
#     is_dir_and_not_exist /this_also_looks/like_a/directory
#
#     if is_dir_and_not_exist ${my_mount}; then
#       mkdir -p ${my_mount}
#     fi
# .. seealso::
#   :func:`docker_sanitize_volume`
#**

function is_dir_and_not_exist()
{
 local dir_name="${1}"

 if ( [ "${dir_name:0:1}" == "/" ] || \
      ( (( ${#dir_name} >= 2 )) && ( [ "${dir_name:0:2}" == "./" ] || [ "${dir_name:1:1}" == ":" ] ) ) ) && \
    [ ! -d "${dir_name}" ] && [ ! -e "${dir_name}" ]; then
    return 0 #TRUE!
 fi
 return 1 #False :(
}

#**
# .. function:: is_internal_docker_volume
#
# :Arguments: ``$1`` - String to check
# :Output: Returns ``0`` if it is a volume and ``1`` if it is not (i.e., it is a directory or invalid)
#
# Checks to see if the string is a valid internal docker volume (as opposed to a Linux- or Windows-style directory)
#
# .. seealso::
#   :func:`is_dir_and_not_exist`
#**

function is_internal_docker_volume()
{
  if [[ ${1} =~ ^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$ ]]; then
    return 0
  else
    return 1
  fi
}

#**
# .. function:: is_readonly_docker_volume
#
# :Arguments: * ``$1`` - docker volume_flags string to check
# :Return Value: * ``0`` if it is readonly
#                * ``1`` it if is writeable (according to docker flags only)
#
# Checks to see if a volume string contains the read only attribute. Can be used both for the docker volume syntax and the docker-compose short volume syntax
#
# .. note::
#
#   It is still possible the underlying directory is not writeable; this will not check that. Used mostly for docker volumes where this is not an issue.
#
# .. seealso::
#
#   :func:`docker_parse_volume_string`
#     Parses a docker volume string and generates volume_flags
#**

function is_readonly_docker_volume()
{
  if [[ ${1} =~ :ro($|:) ]]; then
    return 0
  else
    return 1
  fi
}

#**
# .. function:: is_readonly_docker_compose_long_volume
#
# :Arguments: * ``$1`` - A DOCKER_VOLUME_FLAGS string to check (Not the whole array)
# :Return Value: * ``0`` if it is readonly
#                * ``1`` it if is writeable (according to docker flags only)
#
# Checks to see if a volume string contains the read only attribute. Can be used both for the docker-compose long volume syntax
#
# .. note::
#
#   It is still possible the underlying directory is not writeable, this will not check that. Used mostly for docker volumes, where this is not an issue.
#
# .. seealso::
#
#   docker-compose-volumes
#     Parses docker-compose volumes and generates DOCKER_VOLUME_FLAGS
#**

function is_readonly_docker_compose_long_volume()
{
  local IFS=$'\n'
  local flags=(${1}) # noquotes
  local flag

  for flag in ${flags[@]+"${flags[@]}"}; do
    if [ "${flag}" == "read_only: true" ]; then
      return 0
    fi
  done

  return 1
}

#**
# .. function:: container_get_label
#
# :Arguments: * ``$1`` - Container name
#             * ``$2`` - Label name
# :Output: * `stdout` - Prints out the label value (and evaluates environment variables)
#          * Return ``1`` if label is blank (possibly not set), ``0`` for label found
#
# Get a label value from a docker container
#
# .. note::
#   Requires perl be installed
# .. rubric:: Bugs
#
# Cannot determine the difference between blank and unset labels. See :func:`container_has_label` to handle that ambiguity.
#**

function container_get_label()
{ # All labels go through a perl filter that evaluate %name% using exported
  # environment variables. This won't work on unexported variables
  local value="$(docker inspect -f "{{index .Config.Labels \"${2}\"}}" "${1}")"
  if [ "${value}" == "" ]; then
    return 1
  fi

  echo "${value}" | perl -wpe 's#\%?(\w+)\%# $ENV{$1} // $& #ge;'

  return 0
}

#**
# .. function:: container_has_label
#
# :Arguments: * ``$1`` - Container name
#             * ``$2`` - Label name
# :Output: Return ``1`` for label is unset, ``0`` for label is set
#
# Check to see if a container contains a certain label
#
# :func:`container_get_label` cannot tell whether a container
# has a label or not when the label is blank. The go template filter does not
# differentiate. This will verify if a blank label is set or unset.
#
# .. note::
#   Requires jq be installed
#**

function container_has_label()
{
  if [ "$(docker inspect -f '{{json .Config.Labels }}' "${1}" | \
          jq ".[\"${2}\"]")" == "null" ]; then
    return 1
  else
    return 0
  fi
}

#**
# .. function:: docker_premkdir
#
# :Arguments: ``$1`` - Host directory name or docker volume
#
# Convenient wrapper to deal with the ``MINGW`` screw ups
#
# Preempt one of docker's annoying behaviors of creating directories that
# don't exist with root:root ownership, and just make the directory yourself.
#
# When the argument is a docker volume, nothing should happen. Docker auto
# creates those just fine.
#
# .. note::
#   Always creates the directory with 777 permission. This is to maximize the
#   chances that it works. If you don't want this, the easiest solution is to
#   create the directory yourself. This is more of a last resort. For this
#   reason, when the directory is created, a message is printed.
#
#   When a directory doesn't exist, it is assumed it is a directory, and not a
#   file because this is the same behavior as docker.
#**

function docker_premkdir()
{
  local host_dir="${1}"

  # In Windows (only), \'s are converted to /'s
  if [ "${OS-notwindows}" == "Windows_NT" ]; then
    host_dir="${host_dir//\\//}"
  fi

  if is_dir_and_not_exist "${host_dir}"; then # if not a file or dir
    echo "Missing directory ${host_dir} created with 777" >&2
    mkdir -p "${host_dir}" # make the dir
    chmod 777 "${host_dir}" # blow open permissions
  fi
}

#**
# .. function:: docker_host_dir
#
# :Arguments: ``$1`` - Directory name
# :Output: `stdout` - Converted directory name
#
# Normalize ``POSIX`` path to native path
#
#   On Windows:
#     Converts /d/foo/bar to D:\foo\bar using cygpath
#   On everything else in the world:
#     ``WYSIWYG``
#**

function docker_host_dir()
{
  if [ "${OS-notwindows}" == "Windows_NT" ] && command -v cygpath &> /dev/null ; then
    echo "$(cygpath -w "${1}")"
    #Bash 4 in mingw64 includes cygpath for some reason
    #Cygpath converts / -> \
    #^/{single letter} -> {single letter}:\
    #^/{single letter}/ -> {single letter}:\\ #bug? No longer on v2.9.0!
    #else ^/ -> {git_directory}
  else
    echo "${1}"
  fi
}

#**
# .. function:: docker_parse_volume_string
#
# :Arguments: ``$1`` - The volume string (source:destination:flags)
# :Output: * volume_host - Host path part of the string
#          * volume_docker - Docker path part of the string
#          * volume_flags - Extra optional flags part of the string; may be empty
#          * Returns ``1`` if regex is not matched, else return ``0``
#
# Split up the docker volume string
#
# Docker volume strings can contain optional flags and, depending on windows
# or ``POSIX`` operating systems, have different rules, etc... This function will
# universally split the string up.
#
# .. note::
#   Based off of docker 17.12 syntax. If new flags are added, the regex must be
#   updated.
#
#   Not actually a bug, but a string like "d:/test:ro" would be parsed as host
#   path "D:\test" and docker path "ro", NOT internal volume "d", docker path
#   "/test", and flag read-only. This is not a bug because you can't have a
#   single letter docker volume, so this shouldn't work anyways.
#**

function docker_parse_volume_string()
{
  if [[ ${1} =~ ${DOCKER_VOLUME_PATTERN} ]]; then
    volume_host="${BASH_REMATCH[1]}"
    volume_docker="${BASH_REMATCH[2]}"
    volume_flags="${BASH_REMATCH[3]}"
    return 0
  else
    return 1
  fi
}

# Work in progress
function docker_parse_mount_string()
{
  local IFS=,
  local docker_args

  local noglob=0
  if [[ ${SHELLOPTS} =~ (^|:)noglob(:|$) ]]; then
    noglob=1
  fi
  set -o noglob
  # There's no better way in bash
  eval "docker_args=($(cat <<< "${1}"))"
  if [ "${noglob}" = "0" ]; then
    set +o noglob
  fi
}

#**
# .. function:: docker_sanitize_volume
#
# :Arguments: * ``$1`` - The host directory/volume name
#             * [``$2``] - The docker directory (optional. If omitted, copies host directory)
# :Output: `stdout` - The argument that should go with the -v to docker for mounting
#
# Create a directory before docker gets a chance to
#
# A number of things can go wrong with something as simple as mounting a directory. If the directory doesn't exist, root will end up owning the directory (which is often not desired). Also, on MINGW Linux/Windows path expansion ends up being an error to docker on Windows. So this function will take care of both of these problems in an OS agnostic way.
#
# .. rubric:: Usage
#
# Mainly for the docker and docker-compose CLI -v flags
#
# .. rubric:: Bugs
#
# The docker directory is not optional if the host mount is a volume
#**

function docker_sanitize_volume()
{
  if (( ${#} < 2 )); then
    set -- "${1}" "${1}"
  fi

  local host_dir
  local docker_dir

  if [ "${OS-notwindows}" == "Windows_NT" ]; then
    host_dir="$(docker_host_dir "${1}")"
    # Add an extra / so that mingw doesn't attempt path conversion
    docker_dir="/${2}"
  else
    host_dir="${1}"
    docker_dir="${2}"
  fi

  # Create the directory before docker
  docker_premkdir "${host_dir}"

  echo "${host_dir}:${docker_dir}"
}

#**
# .. function:: parse-docker
#
# :Arguments: ``$1``.. - Arguments to be sent to docker command
# :Output: * docker_args - Arguments to docker, before the docker subcommand (run, up, down, etc...)
#          * docker_command - Docker command specified
#          * docker_command_args - Arguments for the specified command
#
# Parse docker's arguments and split up information (See OUTPUT)
#
# .. rubric:: Usage
#
# Typically, in the calling function, you will define all the output variables as local so that they are captured by the calling function only.
#
# Original command can be thought of as:
#  docker "${docker_args[@]}" "${docker_command}" "${docker_command_args[@]}"
#**

function parse-docker()
{
  docker_args=()
  docker_command=
  docker_command_args=()

  while (( ${#} )); do
    case ${1} in
      -H|-l|\
      --config|--context|--host|--log-level|--tlscacert|--tlscert|--tlskey)
        docker_args+=("${1}" "${2}")
        shift 2
        ;;
      -H*|-l*|\
      --config=*|--context=*|--host=*|--log-level=*|--tlscacert=*|--tlscert=*|--tlskey=*|\
      -D|-v|\
      --debug|--tls|--version|--tlsverify)
        docker_args+=("${1}")
        shift 1
        ;;
      # Anything else must be a docker compose command.
      *)
        docker_command="${1}"
        shift 1
        docker_command_args=(${@+"${@}"})
        break
        ;;
    esac
  done
}

#**
# .. function:: Exec-Docker
#
# Version of Docker that ``exec``'s the command rather than call
#**

function Exec-Docker(){ DOCKER_EXEC=1 Docker "${@}";}

#**
# .. function:: Docker
#
# :Arguments: ``$1``.. - Arguments to be sent to docker command
# :Parameters: * [``DRYRUN``] - Optional variable inserted at the beginning of all docker commands. Useful for setting to "echo" or similar for dryrun mode
#              * ``DOCKER_EXTRA_ARGS`` - Array of extra arguments inserted after docker but before the docker subcommand
#              * ``DOCKER_EXTRA_{subcommand}_ARGS`` - Extra arguments inserted right after the docker subcommand
#              * [``DOCKER_AUTOREMOVE``] - Automatically add the --rm flag to docker run commands. Default: 1
# :Output: Runs docker command
#
# Helper function to execute the right docker command, or just dryrun
#
# Instead of calling the docker command directly, this Docker function should
# be called instead (for all dryrun-able activities. Simple commands like
# inspect, ps, etc. don't make as much sense to dryrun, as the reset of the
# script will never be executed, thus rendering dryrun useless.)
#
# .. rubric:: Bugs
#
# Does not handle the ``-v`` or ``--help`` case where no command is supplied
#**

function Docker()
{
  local docker_args
  local docker_command
  local docker_command_args

  parse-docker ${@+"${@}"}

  _Docker
  return ${?}
}

function _Docker()
{
  local docker_extra_command_args=()
  local cmd=(${DRYRUN} "${DOCKER}")
  local extra_args_var

  if [ "${docker_command}" = "run" ] && [ "${DOCKER_AUTOREMOVE-1}" == "1" ]; then
    docker_extra_command_args+=(--rm)
  fi

  # Indirectly append DOCKER_EXTRA_{COMMAND}_ARGS
  extra_args_var="$(uppercase "${docker_command-none}")"
  extra_args_var="DOCKER_EXTRA_${extra_args_var}_ARGS[@]"
  docker_extra_command_args+=(${!extra_args_var+"${!extra_args_var}"})

  cmd=("${cmd[@]}"
      ${docker_args[@]+"${docker_args[@]}"}
      ${DOCKER_EXTRA_ARGS[@]+"${DOCKER_EXTRA_ARGS[@]}"}
      ${docker_command-}
      ${docker_extra_command_args[@]+"${docker_extra_command_args[@]}"}
      ${docker_command_args[@]+"${docker_command_args[@]}"})

  if [ "${DOCKER_EXEC-}" == "" ] || [ "${DRYRUN}" != "" ]; then
    "${cmd[0]}" "${cmd[@]:1}"
    return ${?}
  else
    exec "${cmd[@]}"
  fi
}

######################
### docker-compose ###
######################

#**
# .. function:: docker-compose-volumes-old
#
# :Arguments: * ``$1`` - Name of service of interest
#          * [``$2``] - Prefix to volume names
# :Output: ``DOCKER_VOLUME_FLAGS`` - Array of the docker flags, including necessary -v's
#
# Get volume flags from docker-compose config
#
# Reformats the output from docker-compose config to an array with -v flags
# for use in passing to another docker or docker-compose run command.
#
# .. rubric:: Example
# .. code-block:: bash
#
#  docker-compose.yml
#    version: "3.2"
#    services:
#      nb:
#        image : some_image
#        volumes:
#        - /tmp:/mnt
#        - test:/opt
#    volumes:
#      test:
#
#  docker-compose-volumes-old nb test_prefix_ < <(docker-compose config)
#  # Or
#  # docker-compose-volumes-old nb <<< "$(docker-compose config)"
#
#  declare -p DOCKER_VOLUME_FLAGS
#  > declare -a DOCKER_VOLUME_FLAGS='([0]="-v" [1]="/tmp:/mnt:rw" [2]="-v"
#                                     [3]="test_prefix_test:/opt")'
#
# .. rubric:: Bugs
#
# Currently only works on volume short format
#
# .. note::
#   Useful for working around docker/compose#4728
#**

function docker-compose-volumes-old()
{
  local PREFIX="${2-}"
  local IFS=$'\n'
  DOCKER_VOLUME_FLAGS=(\
    $(sed -n${sed_flag_rE} \
              '/^services:$/b services
               d
               :services
               n
               # Search for the service entry
               /^  '"${1}"':$/b found
               /^ /b services
               d
               :found
               # Clear pattern buffer and read next line
               n
               # Read volumes: found
               /^    volumes:/b volumes
               # Search all of the service entry
               /^    /b found
               # Volumes were not found, give up
               d
               :volumes
               # Read in a new line
               n
               # Match this new line for an indented(4) list
               /^    -/{
                 s|^    - ([^./])|    - '"${PREFIX}"'\1|
                 # Add these lines to the hold buffer
                 H
                 # Repeat
                 b volumes
               }
               # Switch the hold and pattern buffer
               x
               # Format indented list to look like docker flags
            '$'s|\\n    - |\\\n-v\\\n|g''
               #s|^\n|| # Remove the first blank line - Not needed with array magic
               # Print out that pretty pattern!
               p'))
}

#**
# .. function:: parse-docker-compose-volumes
#
# :Arguments: * ``$1`` - Name of service of interest
#             * [``$2``] - Prefix to volume names
#
# :Output: ``DOCKER_VOLUME_LINES`` - Array of the docker lines. Lines starting with an S represent the short format. Lines starting with an L represent the beginning of a long format entry. Subsequent lines starting with an l are the additional lines of the long format entry. Order matters when in this format.
#
# Get volume lines from docker-compose config
#
# Parses the output from docker-compose config so that information about the
# available mounts are ready to be used by docker-compose-volumes
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#  docker-compose.yml
#    version: "3.2"
#    services:
#      nb:
#        image : some_image
#        volumes:
#        - /tmp:/mnt
#        - type: bind
#          source: /home/user/src
#          target: /src
#        - test:/opt
#    volumes:
#      test:
#
#  parse-docker-compose-volumes nb test_prefix_ < <(docker-compose config)
#  # Or
#  # parse-docker-compose-volumes nb <<< "$(docker-compose config)"
#
#  declare -p DOCKER_VOLUME_LINES
#  > declare -a DOCKER_VOLUME_LINES='([0]="S/tmp:/mnt" [1]="Ltype: bind"
#                                     [2]="lsource: /home/user/src"
#                                     [3]="ltarget: /src" [4]="Stest:/opt")'
#
# .. note::
#   Useful for working around docker/compose#4728
#
#   Supports both short and long format
#
# .. seealso::
#   docker-compose-volumes
#**

function parse-docker-compose-volumes()
{
  local PREFIX="${2-}"
  local IFS=$'\n'
  DOCKER_VOLUME_LINES=(\
    $(sed -n${sed_flag_rE} \
              '/^services:$/b services
               d
               :services
               n
               # Search for the service entry
               /^  '"${1}"':$/b found
               /^ /b services
               d
               :found
               # Clear pattern buffer and read next line
               n
               # Read volumes: found
               /^    volumes:/b volumes
               # Search all of the service entry
               /^    /b found
               # Volumes were not found, give up
               d
               :volumes
               # Read in a new line
               n
               :volumes_long
               # Long format
               /^    - .*:( .*)?$/{
                 :long
                 # Remove spaces, and id as the beginning of a long form
                 s|^    - |L|
                 # Or remove the spaces and id as the next line in a long form
                 s|^      |l|
                 # Add PREFIX if it is a volume mount
                 s|^([lL]source: )([^./])|\1'"${PREFIX}"'\2|
                 H
                 n
                 /^      /b long
                 b volumes_long
               }
               # Match this new line for an indented(4) list
               /^    -/{
                 # Remove spaces, and id as short form
                 s|^    - |S|
                 s|^S([^./])|'S"${PREFIX}"'\1|
                 # Add these lines to the hold buffer
                 H
                 # Repeat
                 b volumes
               }
               # Switch the hold and pattern buffer
               x
               # Print out that pretty pattern!
               p'))
}

#**
# .. function:: docker-compose-list-internal-volumes
#
# :Input: **stdin** - Docker-compose yaml file
# :Output: ``DOCKER_INTERNAL_VOLUMES`` - Array of the docker volumes
#
# Parses the output from ``docker-compose config`` to get the list of all internal volumes
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#  docker-compose.yml
#    version: "3.2"
#    services:
#      nb:
#        image : some_image
#        volumes:
#        - test:/opt
#    volumes:
#      test:
#      stuff:
#
#  docker-compose-list-internal-volumes < <(docker-compose config)
#  # Or
#  # docker-compose-list-internal-volumes <<< "$(docker-compose config)"
#
#  declare -p DOCKER_INTERNAL_VOLUMES
#  > declare -a DOCKER_INTERNAL_VOLUMES='([0]="test" [1]="stuff")'
#
# .. note::
#
#    Both ``test`` and ``stuff`` will be returned, even though stuff is not used.
#**
function docker-compose-list-internal-volumes()
{
  local IFS=$'\n'
  DOCKER_INTERNAL_VOLUMES=(\
    $(sed -n${sed_flag_rE} \
              '/^volumes:/b volumes
               # Delete lines until I find the "^volumes:" line
               d
               :volumes
               # Read the next line immediately after volumes: it should be a volume name
               n
               # Search for the volume entry, two space, name (starting with not a space) then colon
               /^  [^ ].*:/b found
               # If I found another unindented line, then I am done parsing, quit
               /^[^ #]/q
               # Keep scanning for the next volume
               b volumes
               :found
               # Clean up the volume name, so only the name is left
               s/^ *//
               s/:.*$//
               p
               b volumes'))
}

#**
# .. function:: docker-compose-volumes
#
# :Output: * ``DOCKER_VOLUME_SOURCES`` - List of sources
#          * ``DOCKER_VOLUME_TARGETS`` - Corresponding list of targets
#          * ``DOCKER_VOLUME_FLAGS`` - Corresponding list of flags. Can be a mix of short and long format flags. Needs more parsing before this mix is useful.
#          * ``DOCKER_VOLUME_FORMATS`` - Corresponding list specifying either "long" or "short" as the format of each volume
#
# Get volume lists from ``DOCKER_VOLUME_LINES``
#
# .. rubric:: Usage
#
# .. code-block:: bash
#
#   parse-docker-compose-volumes nb test_prefix_ < <(docker-compose config)
#   docker-compose-volumes
#
# .. seealso::
#   parse-docker-compose-volumes
#**

function docker-compose-volumes()
{
  local volume_line
  DOCKER_VOLUME_SOURCES=()
  DOCKER_VOLUME_TARGETS=()
  DOCKER_VOLUME_FLAGS=()
  DOCKER_VOLUME_FORMATS=()
  local -i count=0

  for volume_line in ${DOCKER_VOLUME_LINES[@]+"${DOCKER_VOLUME_LINES[@]}"}; do
    # Capital means new volume
    if [[ ${volume_line:0:1} = [SL] ]]; then
      count+=1
      # Extend each array, to guarantee there are no holes and they are the
      # same length. Makes more robust and the code simpler
      DOCKER_VOLUME_SOURCES[count]=""
      DOCKER_VOLUME_TARGETS[count]=""
      DOCKER_VOLUME_FORMATS[count]=""
      DOCKER_VOLUME_FLAGS[count]=""
    fi

    if [ "${volume_line:0:1}" = "S" ]; then # Short format
      volume_line="${volume_line:1}"
      if [[ ${volume_line} =~ ${DOCKER_VOLUME_PATTERN} ]]; then
        DOCKER_VOLUME_SOURCES[count]="${BASH_REMATCH[1]}"
        DOCKER_VOLUME_TARGETS[count]="${BASH_REMATCH[2]}"
        DOCKER_VOLUME_FORMATS[count]="short"
        DOCKER_VOLUME_FLAGS[count]="${BASH_REMATCH[3]}"
      else
        declare -p volume_line DOCKER_VOLUME_LINES >&2
        echo "Invalid short form volume string: ${volume_line}" >&2
        return 1
      fi
    elif [[ ${volume_line:0:1} = [Ll] ]]; then
      if [ "${volume_line:0:1}" = "L" ]; then
        DOCKER_VOLUME_FORMATS[count]="long"
      fi
      # Remove the L/l, so the rest is simpler to parse
      volume_line="${volume_line:1}"
      if [[ ${volume_line} = source:* ]]; then
        DOCKER_VOLUME_SOURCES[count]="${volume_line#source: *}"
      elif [[ ${volume_line} = target:* ]]; then
        DOCKER_VOLUME_TARGETS[count]="${volume_line#target: *}"
      elif [[ ${volume_line} != type:* ]]; then
        if [ "${DOCKER_VOLUME_FLAGS[count]}" = "" ]; then
          DOCKER_VOLUME_FLAGS[count]="${volume_line}"
        else
          DOCKER_VOLUME_FLAGS[count]+=$'\n'"${volume_line}"
        fi
      fi
    fi
  done
}

#**
# .. function:: parse-docker-compose
#
# :Arguments: ``$1``.. - Arguments to be sent to docker-compose command
# :Parameters: [``JUST_DOCKER_COMPOSE_DIR``] - By default, the docker-compose files will initially be searched for in the ``JUSTFILE`` directory, and then up the parent dirs until / is hit. However, if you wish to the disable this behavior and start searching for a docker-compose file from the current directory where "just" is called, then set this var to an empty string. You can also set to a specific directory to start searching from within that directory.
# :Output: * ``docker_compose_args`` - Arguments to docker-compose, before the docker-compose command (run, up, down, etc...)
#          * ``docker_compose_command`` - Docker compose command specified
#          * ``docker_compose_command_args`` - Arguments for the specified command
#          * ``docker_compose_files`` - Array of docker compose files that are used
#          * ``docker_compose_project_name`` - Docker compose project name
#
# Parse docker-compose's arguments and pull out a few important pieces of
# information (See OUTPUT)
#
# .. rubric:: Usage
#
# Typically, in the calling function, you will define all the output variables
# as local, so that they are captured by the calling function only.
#
# Original command can be thought of as:
#
# .. code-block:: bash
#
#   docker-compose "${docker_compose_args[@]}" "${docker_compose_command}" \
#                  "${docker_compose_command_args[@]}"
#
# .. rubric:: Example
#
# To start searching for docker-compose.yml in the directory where "just" is called:
# (Justfile snippet)
#
# .. code-block:: bash
#
#     target) # Test target
#       JUST_DOCKER_COMPOSE_DIR="" Just-docker-compose run target
#       ;;
#
# To change the default search location for a project, in the project env file
# add
#
# .. code-block:: bash
#
#   : ${JUST_DOCKER_COMPOSE_DIR="${PROJECT_CWD}/docker_dir"}
#
# .. note::
#   Because the -f argument overrides all other forms of choosing the compose
#   file, the ``docker_compose_args`` are updated to use this notation instead of
#   other methods that may be used. This will not change the behavior of the
#   ``docker-compose`` command run, but will make adding additional compose files
#   a lot easier.
#**

function parse-docker-compose()
{
  local compose_file

  docker_compose_files=()
  docker_compose_args=()
  docker_compose_project_name=
  docker_compose_command=
  docker_compose_command_args=()

  while (( ${#} )); do
    case ${1} in
      -f|-p|-H|-c)
        docker_compose_args+=("${1}" "${2}")
        case ${1} in
          -f)
            docker_compose_files+=("${2}")
            ;;
          -p)
            docker_compose_project_name="${2}"
            ;;
        esac
        shift 2
        ;;
      -f*|-p*|-H*|-c*)
        docker_compose_args+=("${1}")
        case ${1} in
          -f*)
            docker_compose_files+=("${1:2:${#1}-2}")
            ;;
          -p*)
            docker_compose_project_name="${1:2:${#1}-2}"
            ;;
        esac
        shift 1
        ;;
      --file=*|--project-name=*|--host=*|--context=*|--log-level=*|\
      --tlscacert=*|--tlscert=*|--tlskey=*|--project-directory=*|--env-file=*|\
      --no-ansi|-v|--verbose|--tls|--skip-hostname-check|--tlsverify|\
      --compatibility)
        docker_compose_args+=("${1}")
        case ${1} in
          --file=*)
            docker_compose_files+=("${1:7:${#1}-7}")
            ;;
          --project-name=*)
            docker_compose_project_name="${1:15:${#1}-15}"
            ;;
        esac
        shift 1
        ;;
      --file|--project-name|--host|--context|--log-level|\
      --tlscacert|--tlscert|--tlskey|--project-directory|--env-file)
        docker_compose_args+=("${1}" "${2}")
        case ${1} in
          --file)
            docker_compose_files+=("${2}")
            ;;
          --project-name)
            docker_compose_project_name="${2}"
            ;;
        esac
        shift 2
        ;;
      # Anything else must be a docker compose command
      *)
        docker_compose_command="${1}"
        shift 1
        docker_compose_command_args=(${@+"${@}"})
        break
        ;;
    esac
  done

  if [ "${#docker_compose_files[@]}" -eq "0" ]; then
    local OLD_IFS="${IFS}"
    local IFS="$(compose_path_separator)"
    docker_compose_files+=(${COMPOSE_FILE+${COMPOSE_FILE}})
    for compose_file in ${docker_compose_files[@]+"${docker_compose_files[@]}"}; do
      docker_compose_args+=(-f "${compose_file}")
    done
    IFS="${OLD_IFS}"
  fi

  if [ "${#docker_compose_files[@]}" -eq "0" ]; then
    local file_matches
    # This is one of the few times the directory you are in matters. To create
    # an expected default behavior, switch to the JUSTFILE dir before searching
    # for the docker-compose file.
    pushd "${JUST_DOCKER_COMPOSE_DIR-$(dirname "${JUSTFILE}")}" > /dev/null
      parent_find_files docker-compose.yml docker-compose.yaml
    popd > /dev/null

    docker_compose_files=(${file_matches[@]+"${file_matches[@]}"})
    if [ "${#docker_compose_files[@]}" -ne "0" ]; then
      local override
      for override in "$(dirname "${docker_compose_files[0]}")/docker-compose.override.yml" \
                      "$(dirname "${docker_compose_files[0]}")/docker-compose.override.yaml"; do
        if [ -e "${override}" ]; then
          docker_compose_files+=("${override}")
        fi
      done
    fi

    for compose_file in ${docker_compose_files[@]+"${docker_compose_files[@]}"}; do
      docker_compose_args+=(-f "${compose_file}")
    done
  fi

  # project-name flag wins
  if [ "${docker_compose_project_name:+set}" != "set" ]; then
    # Then environment variable
    if [ "${COMPOSE_PROJECT_NAME:+set}" = "set" ]; then
      docker_compose_project_name="${COMPOSE_PROJECT_NAME}"
    elif [ "${#docker_compose_files[@]}" -ne "0" ]; then
      docker_compose_project_name="$(basename "$(cd "$(dirname "${docker_compose_files[0]}")"; pwd)")"
    else
      docker_compose_project_name=default
    fi
  fi
}

#**
# .. function:: compose_path_separator
#
# :Output: *stdout* - IFS string
#
# Reproduce ``docker-compose`` logic for pathsep
#
# ``docker-compose`` uses some logic to determine the IFS separator for splitting
# up the ``COMPOSE_FILE`` environment variable. This should return the exact same
# result
#
# .. rubric:: Usage
#
# .. code-block:: bash
#
#  local OLD_IFS="${IFS}"
#  local IFS="$(compose_path_separator)"
#  ...
#  IFS="${OLD_IFS}"
#**

function compose_path_separator()
{
  if [ "${COMPOSE_PATH_SEPARATOR:+set}" = "set" ]; then
    echo -n "${COMPOSE_PATH_SEPARATOR}"
  elif [ "${OS-notwindows}" = "Windows_NT" ]; then
    echo -n ";"
  else
    echo -n ":"
  fi
}

#**
# .. function:: Docker-compose
#
# :Arguments: ``$1``.. - Arguments to be sent to docker-compose command
# :Parameters: * ``DOCKER_COMPOSE_EXTRA_ARGS`` - Array of extra arguments inserted after ``docker-compose`` but before the docker subcommand
#              * ``DOCKER_COMPOSE_EXTRA_{subcommand}_ARGS`` - Array of extra arguments inserted right after the docker subcommand
#              * [``DOCKER_COMPOSE_AUTOREMOVE``] - Automatically add the --rm flag to ``docker-compose`` run commands when using the Docker-compose helper function. Default: 1
#              * ``DRYRUN``] - Optional variable inserted at the beginning of all docker commands. Useful for setting to "echo" or similar for dryrun mode
# :Output: Runs docker-compose command
#
# Helper function to execute (dryrun) the right command
#
# Instead of calling the ``docker-compose`` command directly, the ``Docker-compose``
# command should be called instead (for all dryrun-able activities. Simple
# commands like ps, etc. don't make as much sense to dryrun, as the reset of
# the script will never be executed, thus rendering dryrun useless.)
#
# .. rubric:: Bugs
#
# ``Docker-compose`` should not be exec'd like Docker was. Since fifo buffers are
# created in common usage of ``Docker-compose``, `exec Docker-compose` would
# result in fifo buffers being left behind in /tmp
#**

function Docker-compose()
{
  local docker_compose_args
  local docker_compose_command
  local docker_compose_command_args
  local docker_compose_files
  local docker_compose_project_name

  parse-docker-compose ${@+"${@}"}

  _Docker-compose
}

function _Docker-compose()
{
  local docker_compose_extra_command_args=()
  local cmd=(${DRYRUN} "${DOCKER_COMPOSE}")
  local extra_args_var

  if [ "${docker_compose_command}" = "run" ] && [ "${DOCKER_COMPOSE_AUTOREMOVE-1}" == "1" ]; then
    docker_compose_extra_command_args+=(--rm)
  fi

  # Indirect: add DOCKER_COMPOSE_EXTRA_{COMMAND}_ARGS
  extra_args_var="$(tr '[a-z]' '[A-Z]' <<< "${docker_compose_command}")"
  extra_args_var="DOCKER_COMPOSE_EXTRA_${extra_args_var}_ARGS[@]"
  docker_compose_extra_command_args+=(${!extra_args_var+"${!extra_args_var}"})

  "${cmd[@]}" \
      ${docker_compose_args[@]+"${docker_compose_args[@]}"} \
      ${DOCKER_COMPOSE_EXTRA_ARGS[@]+"${DOCKER_COMPOSE_EXTRA_ARGS[@]}"} \
      ${docker_compose_command} \
      ${docker_compose_extra_command_args[@]+"${docker_compose_extra_command_args[@]}"} \
      ${docker_compose_command_args[@]+"${docker_compose_command_args[@]}"}
  return ${?}
}

#**
# .. function:: get_docker_compose_version
#
# :Arguments: ``$1``... - ``docker-compose`` yaml filenames
# :Output: *stdout* - ``docker-compose`` version. Nothing if none are found
#
# Returns the first ``docker-compose`` version found
#**

function get_docker_compose_version()
{
  local COMPOSE_VERSION

  while (( ${#} )); do
    while IFS='' read -r line || [[ -n "${line}" ]]; do
      if [[ ${line} =~ ^version\ *:\ *[\'\"](.*)[\'\"] ]]; then
        COMPOSE_VERSION="${BASH_REMATCH[1]}"
        break 2
      fi
    done < "${1}"
    shift 1
  done

  echo "${COMPOSE_VERSION-}"
}

#**
# .. function:: get_docker_stage_names
#
# :Arguments: ``$1`` - Dockerfile filename
# :Output: *stdout* - List of stages, newline separated
#
# Get list of named stages in a Dockerfile
#**

function get_docker_stage_names()
{
  sed -n 's|^ *[fF][rR][oO][mM] [a-zA-Z0-9:\./_-]* [aA][sS] ||p' "${1}"
}

#**
# .. function:: get_dockerfile_from_compose
#
# :Arguments: - ``$1`` - docker-compose file
#             - ``$2`` - Service name
#             - [``$3``] - :file:`yarp` of compose file
# :Output: *stdout* - The Dockerfile. Not guaranteed to be a full path
#
# Determine Dockerfile filename from the compose file
#
# If you would like to set the "project directory" used by compose to be somewhere other then the directory in which the docker-compose.yml (``$1``) resides, you must provide the :file:`yarp` of the compose file as ``$3`` and set ``$1`` to a "file" in the directory of the project dir. Note, however, that this file does not necessarily have to exist.
#**

function get_dockerfile_from_compose()
{
  local compose_yarp
  if [ "${#}" -lt "3" ]; then
    compose_yarp="$(yarp < "${1}")"
  else
    compose_yarp="${3}"
  fi

  local context="$(sed -n 's|^services.'"${2}"'.build.context = ||p' <<< "${compose_yarp}")"
  if [ "${context}" = "" ]; then
    context="$(sed -n 's|^services.'"${2}"'.build = ||p' <<< "${compose_yarp}")"
  fi
  # If it is a relative path
  if [ "${context:0:1}" != "/" ]; then
    context="$(dirname "${1}")/${context}"
  fi

  local dockerfile="$(sed -n 's|^services.'"${2}"'.build.dockerfile = ||p' <<< "${compose_yarp}")"
  # If blank, it wasn't in the compose file. Use default
  if [ "${dockerfile}" = "" ]; then
    dockerfile=Dockerfile
  fi

  echo "$(normpath "${context}/${dockerfile}")"
}

#**
# .. function:: Just-docker-compose
#
# :Arguments: ``$1``... - Arguments to docker-compose
# :Parameters: * ``JUST_PROJECT_PREFIX`` - Typically, the project name that is prepended to all the variables. EXAMPLE would cover EXAMPLE_VARIABLE
#              * [``COMPOSE_VERSION``] - The docker compose yaml version number is auto determined by parsing the existing files, and is used in the auto generated files. In order to bypass this, you can specify the version number manually using this variable.
#
# ``Docker-compose`` with advance just features
#
# To provide a smoother just experience, advanced features are baked into
# ``Just-docker-compose`` to work with Just and :file:`just_entrypoint_functions` to cover the
# last mile in getting docker started and setup with a predictable environment
# user permissions, mounts (and more...)
#
# Creates a docker override yaml file and extends the current docker-compose
# configuration.
#
# See :func:`docker_compose_override generate_docker_compose_override` for more
# information.
#
# Determines which docker compose yaml files to use by mimicking the
# behavior of docker-compose, which includes querying the ``COMPOSE_FILE``
# environment variable or trying the default files.
#
# .. rubric:: Bugs
#
# A temp file is left behind in dryrun mode so that dryrun mode will actually
# work. As long as the commands echo'd by dryrun are executed, the temp file
# will be cleaned up, as one of them is rm. So ultimately, this is by design.
#
# Using this function with windows paths is not currently supported.
#
# You can not use process substitution for the docker-compose.yml file because
# ``bash`` has to read it before docker-compose reads it. So this will not work:
# Just-docker-compose -f <(echo "${compose_file}") run test
# You have to use files.
#
# .. seealso::
#   :func:`docker_compose_override generate_docker_compose_override`
#**

function Just-docker-compose()
{
  if [ ! "${JUST_PROJECT_PREFIX:+set}" == "set" ]; then
    echo "You need to define JUST_PROJECT_PREFIX for this to work. Please add"
    echo "JUST_PROJECT_PREFIX to your environment script, typically the project"
    echo "name in caps."
    exit 1
  fi

  local docker_compose_args
  local docker_compose_command
  local docker_compose_command_args
  local docker_compose_files
  local DOCKER_COMPOSE_FILES
  local docker_compose_project_name
  local COMPOSE_VERSION="${COMPOSE_VERSION-}"

  local override_file="$(mktemp)"

  parse-docker-compose ${@+"${@}"}

  # 1. Get docker-compose version
  # Auto detect compose version (PURE BASH, WHAT?!)
  if [ -z "${COMPOSE_VERSION:+set}" ]; then
    COMPOSE_VERSION="$(get_docker_compose_version "${docker_compose_files[0]}")"
  fi

  # 2. Get service name list
  # Get complete list of unique service names
  local service_names=()
  local compose_file
  for compose_file in "${docker_compose_files[@]}"; do
    service_names+=($(docker_compose_service_names "${compose_file}"))
  done

  # 3. Unique service name list
  local OLD_IFS="${IFS}"
  local IFS=$'\n'
  service_names=($(awk '!count[$0]++' <<< ${service_names[*]+"${service_names[*]}"}))
  IFS="${OLD_IFS}"

  # 4. Create override file
  DOCKER_COMPOSE_FILES=(${docker_compose_files[@]+"${docker_compose_files[@]}"})
  generate_docker_compose_override ${JUST_PROJECT_PREFIX} \
      ${service_names[@]+"${service_names[@]}"} > "${override_file}"

  # 5. Add the override file to compose files
  docker_compose_args+=(-f "${override_file}")

  # 6. Call docker compose
  # "Fail later" behavior for set -eu. This should guarantee the override_file
  # is deleted. If this isn't enough, investigate adding cleanup to a trap
  local rv=0
  _Docker-compose || rv="${?}"
  ${DRYRUN} rm "${override_file}"
  return "${rv}"
}

#**
# .. function:: docker_service_running
#
# :Arguments: [``$1``...] - service names, if none are provided, all are used
# :Parameters: ``COMPOSE_FILE`` - Colon delimited file listing docker-compose files to use
# :Output: *stdout* - State of service running, Up/Exited/Creating/etc...
# :Return Value: * ``0`` - Service found
#                * ``1`` - Service not found
#
# Checks to see if a service is running
#
# Returns the state-status of any containers, using the docker-compose service
# names.
#**

function docker_service_running()
{
  "${DOCKER}" inspect -f '{{.State.Status}}' \
              $("${DOCKER_COMPOSE}" ps -q ${@+"${@}"}) 2>/dev/null # noquotes
}

#**
# .. function:: docker_compose_service_names
#
# :Arguments: ``$1`` - docker compose yaml file
# :Output: *stdout* - New line separated list of service names
#
# Get service names from compose yaml file
#**

function docker_compose_service_names()
{
           # Skip (d) all lines until services: is matched
  sed -n${sed_flag_rE} \
          '/^services:/b services
           d
           :services
           # Read next line
           n
           /^ *#/{
             b services
           }
           # Two space only indent is a service name
           /^  [^ ]*:.*/{
             # Remove leading spaces and :.*
             s|^  ([^ ]*):.*|\1|
             p
             b services
           }
           # As soon as a line not starting with a space is encountered, the
           # service section is over, so (q)uit
           /^[^ ]/q
           b services' "${1}"
}

# :Arguments: ``$1`` docker-compose filename or :file:`yarp` of compose file
function docker_compose_service_names2()
{
  local compose_yarp
  if [ -e "${1}" ]; then
    compose_yarp="$(yarp < "${1}")"
  else
    compose_yarp="${1}"
  fi

  sed -n${sed_flag_rE} 's|^services.([^.]+) =.*|\1|p' <<< "${compose_yarp}"
}

#**
# .. function:: docker_compose_sanitize_project_name
#
# :Arguments:  * ``$1`` - Directory name. Can also be any name really. But directory name is what docker-compose uses to come up with the project name
#              * [``$2``] - Optionally specify a prefix (like a username) to assist in making a (user) specific project name
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   docker_compose_sanitize_project_name 'project/A@1.1_2'
#     projectA112
#
#   docker_compose_sanitize_project_name 'project/A@1.1_2' 'a-user:7'
#     auser7projectA112
#
#   docker_compose_sanitize_project_name '' 'a-user:7'
#     auser7
#
# Make a valid project name
#
# Docker compose will auto generate a project name based off of the directory
# name. A docker compose project name can only have lowercase letters and
# numbers. This function will reproduce that same functionality so that you
# can have that value in ``bash``, with some added benefits (prefix) to truly take
# control of your docker-compose experience.
#**

function docker_compose_sanitize_project_name()
{
  awk '{sub(/\/*$/, "", $0)
        n=split($0,arr, /\//)
        a=tolower("'"${2+${2}}"'" arr[n])
        gsub(/[^a-z0-9]/,"",a)
        print a}' <<< "${1}"
}

#**
# .. function:: docker_cp_image
#
# :Arguments:  * ``[$1]...`` - Same optional arguments as ``docker cp``
#              * ``${n-2}`` Image name
#              * ``${n-1}`` SRC_PATH in image
#              * ``${n}`` DEST_PATH on the host
#
# A helper function to emulate ``docker cp`` from an image instead of from a container.
#
# The ``SRC_PATH`` must be from an image, and the ``DEST_PATH`` must be on the host
#**

function docker_cp_image()
{
  local options=("${@:1:${#}-3}")
  shift "$((${#}-3))"
  local image_name="${1}"
  local src_path="${2}"
  local dest_path="${3}"
  local container_name="$(docker create ${image_name})"

  docker cp ${options[@]+"${options[@]}"} "${container_name}:${src_path}" "${dest_path}"
  docker rm "${container_name}"
}
