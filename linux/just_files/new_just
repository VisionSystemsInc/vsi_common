#!/usr/bin/env bash

# Usage:
#   bash <(curl -L https://visionsystemsinc.github.io/vsi_common/new_just)

temp_file="$(mktemp)"

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"
fi

# Use a command like true, so that when I comment, it still works
# COMMENT NEXT LINE when developing, uncomment before commiting.
cat - << 'true' > "${temp_file}"

#*# just/new_just

#**
# .. default-domain:: bash
#
# ============
# New J.U.S.T.
# ============
#
# .. file:: new_just
#
# Create a new just project
#
# There are many moving pieces to set up a working just project and use
# all the features. Just getting started is hard, without knowing where to
# start. This script will create all the files necessary to have a new
# docker-compose based just project up and running.
#
# .. rubric:: Usage
#
# By default, :file:`new_just` will prompt the user for questions on the initial
# setup parameters. Default values are supplied for all questions, and enter
# can be pressed to accept all the defaults. All of the questions can be set
# using environment variables, making them scriptable.
#
# After :file:`new_just` is called, a few git commands need to be called. This is not
# done for you, in case it will break your existing repository. These
# commands are printed out on stdout, while everything else is printed on
# stderr, making them scriptable.
#
# If any of the files written to exist, they are not overwritten, and a warning
# message is printed out.
#
# .. seealso::
#
#   :env:`new_just new_just PROJECT_DIR`, :env:`new_just new_just PROJECT_NAME`, :env:`new_just new_just PROJECT_PREFIX`
#   :env:`new_just new_just REPO_NAME`, :env:`new_just new_just JUSTFILE`, :env:`new_just new_just SETUPFILE`
#   :env:`new_just new_just VSI_DIR`
#**

# These functions are auto replaced by .circleci/config.yml when uploaded to
# https://visionsystemsinc.github.io/vsi_common/new_just using the pattern
# "function function_name(){ :;}"

if [ -f "${VSI_COMMON_DIR}/linux/ask_question" ]; then
  source "${VSI_COMMON_DIR}/linux/ask_question"
else
  function ask_question(){ :;}
fi

if [ -f "${VSI_COMMON_DIR}/linux/string_tools.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/string_tools.bsh"
else
  function quote_escape(){ :;}
fi

# Use unwrapping echo so that this file is easier to read
if [ -f "${VSI_COMMON_DIR}/linux/uwecho.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
else
  function uwecho(){ :;}
fi

# Use a bash dir_tools.bsh function
if [ -f "${VSI_COMMON_DIR}/linux/dir_tools.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
else
  function normpath(){ :;}
  function relative_path(){ :;}
fi

# Use a bash compat.bsh function
if [ -f "${VSI_COMMON_DIR}/linux/compat.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/compat.bsh"
else
  function load_vsi_compat(){ :;}

  # Call this now, to load flags
  load_vsi_compat
fi

#**
# .. function:: docker_add_quote_escape
#
# Escapes arbitrary filename for ``Dockerfile`` ``ADD ["filename", "dest"]`` syntax, not including outer ``"``
#
# :Arguments: ``$1`` - Filename to be escaped
#**
function docker_add_quote_escape()
{
  # Escape \ => \\
  local foo="${1//\\/\\\\}"
  # Escape [ => \\[
  foo="${foo//[/\\\\[}"
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -le 42 ]; then
    # Escape ' => \\'
    foo="${foo//\'/\\\'}"
  else
    # Escape ' => \\'
    foo="${foo//\'/\\\\\'}"
  fi
  # Escape " => \\\"
  foo="${foo//\"/\\\\\\\"}"
  echo "${foo}"
}

#**
# .. function:: docker_env_quote_escape
#
# Escapes arbitrary value for ``Dockerfile`` ``ENV var="value"`` syntax, not including outer ``"``
#
# :Arguments: ``$1`` - Value to be escaped
#**
function docker_env_quote_escape()
{
  # Escape \ => \\. While not exactly required, protects certain corner cases
  local foo="${1//\\/\\\\}"
  # Escape " => \"
  echo "${foo//\"/\\\"}"
}

# $1 - Var name
# $2 - default
# $3 - Prompt message
# USE_DEFAULTS=1 means use default
# Returns 1 if default used, else 0
function set_default()
{
  if [ -n "${!1:+set}" ]; then
    return 0
  fi
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    if [ -z "${!1:+set}" ]; then
      IFS='' read -r -d '' "${1}" < <(printf '%s' "${2-}")
    fi
    # : ${!1:=${2}} # Only works in bash 4.4 or newer
    return 1
  fi

  if [ -z "${!1+set}" ]; then
    read -r -p "${3} (${2}) " "${1}"
  fi
  # : ${!1="$(read -r -p "${3} (${2}) " x; echo "$x")"} # Only works in bash 4.4 or newer
  if [ "${!1}" == "" ]; then
    IFS='' read -r -d '' "${1}" < <(printf '%s' "${2-}")
    return 1
  fi
  return 0
}

# Check to see if file exists, and makes it exists if it doesn't
# Return 0 if it already exists, else 1
# :Arguments: - ``$1`` - Filename
#             - [``$2``] - Permissions to set to file
# :Return Value: - ``0`` - If file already exists
#                - ``1`` - If file did not exist, and was created
function exists()
{
  if [ -e "${1}" ]; then
    if [ $# -gt 1 ]; then
      chmod "${2}" "${1}"
    fi
    echo "${1} exists, skipping..."
    return 0
  fi

  touch "${1}"
  if [ $# -gt 1 ]; then
    chmod "${2}" "${1}"
  fi
  return 1
}

#################
### setup.env ###
#################
function write_setup_env()
{
  exists "${1}" && return 0

  uwecho "test -f $(quote_escape "${RELATIVE_PATH}/linux/check_shell") && $(quote_escape "${RELATIVE_PATH}/linux/check_shell") bash zsh"'
          export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
          source "$(dirname "${BASH_SOURCE[0]}")/"'"$(quote_escape "${RELATIVE_PATH}/env.bsh")" >> "${1}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=$(quote_escape "${JUSTFILE}")" >> "${1}"
  else
    echo "unset JUSTFILE" >> "${1}"
  fi
}

###################
### project.env ###
###################
function write_project_env()
{
  exists "${1}" && return 0

  uwecho   'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
            JUST_VERSION="'"${JUST_VERSION-new_just}"'"
            if [ -z "${'"${PROJECT_PREFIX}"'_CWD+set}" ]; then
              '"${PROJECT_PREFIX}"'_CWD="$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"
            fi
            '  >> "${1}"

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho ': ${'"${PROJECT_PREFIX}"'_AUTO_ESCAPE='"${PROJECT_PREFIX}"'_.*_DIR_DOCKER}

            : ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

            : ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
            : ${'"${PROJECT_PREFIX}"'_USERNAME=$(id -u -n)}
            : ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
            : ${'"${PROJECT_PREFIX}"'_GIDS=$(id -G)}
            : ${'"${PROJECT_PREFIX}"'_GID=${'"${PROJECT_PREFIX}"'_GIDS%% *}}
            : ${'"${PROJECT_PREFIX}"'_GROUP_NAMES=$(group_names)}

            # This directory is added to the container using the docker-compose file. This mechanism
            # should only be used when the directory is guaranteed to exist
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR=${'"${PROJECT_PREFIX}"'_CWD}}
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER=/src}
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_TYPE=bind}

            if [ -d /tmp/.X11-unix ]; then
              '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
                  ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
            fi

            # Example of a Dynamic Volume, that is created programmatically instead
            # always there. This directory is added to the container using '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES.
            # This mechanism is better when the directory doesn'"'"'t exist, as the directory
            # will be created and owned properly, unlike docker'"'"'s default behavior
            # : ${'"${PROJECT_PREFIX}"'_DATA_DIR=${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/new-data}
            # : ${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER=/data}
            # '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES=(
            #     "${'"${PROJECT_PREFIX}"'_DATA_DIR}:${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER}"
            #     ${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES[@]}"})

            ###############################################################################
            # Non-'"${PROJECT_PREFIX}"' Settings
            ###############################################################################

            # Put variables that do not begin with '"${PROJECT_PREFIX}"' here.

            : ${TZ=/usr/share/zoneinfo/UTC}

            # Use this to add the user name to the docker-compose project name. This is
            # important when multiple users are using this docker-compose project on a
            # single host. This way all of the docker resources are prefixed with a unique
            # name and do not collide
            source "${VSI_COMMON_DIR}/linux/just_files/docker_functions.bsh" # define docker_compose_sanitize_project_name
            : ${COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${'"${PROJECT_PREFIX}"'_CWD}" "${'"${PROJECT_PREFIX}"'_USERNAME}")}
            ' >> "${1}"
  fi
}

#################
### README.md ###
#################
function write_readme_md()
{
  exists "${1}" && return 0

  uwecho   '## Getting started

            ```' >> "${1}"

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo   "source $(quote_escape "${SETUPFILE}")" >> "${1}"
  fi

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho "${just_cmd} sync
            ${just_cmd} run ${APP_NAME}" >> "${1}"
  else
    uwecho "${just_cmd} compile
            ${just_cmd} run" >> "${1}"
  fi
  uwecho   '```

            ## Just usage:

            ```' >> "${1}"

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo   "source $(quote_escape "${SETUPFILE}")" >> "${1}"
  fi

  uwecho   '${just_cmd} help
            ```
            ' >> "${1}"
}

################
### Justfile ###
################
function write_justfile()
{
  exists "${1}" 775 && return 0

  uwecho     '#!/usr/bin/env bash

              source "${VSI_COMMON_DIR}/linux/just_files/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'"$(quote_escape "${PROJECT_NAME}.env")"'
              ' >> "${1}"

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho   '# Plugins
              source "${VSI_COMMON_DIR}/linux/just_files/docker_functions.bsh"
              source "${VSI_COMMON_DIR}/linux/just_files/just_docker_functions.bsh"
              source "${VSI_COMMON_DIR}/linux/just_files/just_git_functions.bsh"

              cd "${'"${PROJECT_PREFIX}"'_CWD}"

              # Main function
              function caseify()
              {
                local just_arg=$1
                shift 1
                case ${just_arg} in
                  build) # Build Docker image
                    if [ "$#" -gt "0" ]; then
                      Docker-compose "${just_arg}" ${@+"${@}"}
              ' >> "${1}"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '        if isin '"${APP_NAME}"' ${@+"${@}"}; then
                        justify docker-compose clean venv
                      fi' >> "${1}"
    fi
    uwecho   '        extra_args=$#
                    else
                      justify build recipes-auto "${'"${PROJECT_PREFIX}"'_CWD}/docker"/*.Dockerfile
                      Docker-compose build
              ' >> "${1}"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '        justify docker-compose clean venv' >> "${1}"
    fi
    uwecho   '      fi
                    ;;' >> "${1}"
    uwecho   '    run_'"${APP_NAME}"') # Run '"${APP_NAME}"' 1
                    Just-docker-compose run --service-ports '"${APP_NAME}"' ${@+"${@}"}
                    extra_args=$#
                    ;;

                  sync) # Synchronize the many aspects of the project when new code changes \
                        # are applied e.g. after "git checkout"
                    if [ ! -e "${'"${PROJECT_PREFIX}"'_CWD}/.just_synced" ]; then
                      # Add any commands here, like initializing a database, etc... that need
                      # to be run the first time sync is run.
                      touch "${'"${PROJECT_PREFIX}"'_CWD}/.just_synced"
                    fi
                    # Add any extra steps run when syncing everytime
                    Docker-compose down
                    justify git_submodule-update # For those users who don'"'"'t remember!
                    justify build
                    ;;
              ' >> "${1}"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '    pipenv) # Run pipenv commands in pipenv container. Useful for \
                          # installing/updating pipenv packages
                    Just-docker-compose run '"${APP_NAME}"'_pipenv pipenv ${@+"${@}"}
                    extra_args=$#
                    ;;
                  clean_all) # Delete all local volumes
                    ask_question "Are you sure? This will remove packages not in Pipfile!" n
                    justify docker-compose clean --all
                    ;;
              ' >> "${1}"
    fi
    uwecho   '    *)
                    defaultify "${just_arg}" ${@+"${@}"}
                    ;;
                esac
              }

              if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' >> "${1}"
  else
    uwecho   'cd "${'"${PROJECT_PREFIX}"'_CWD}"

              function caseify()
              {
                local just_arg=$1
                shift 1
                case ${just_arg} in
                  compile) # Build program
                    g++ hi.cpp -o hi
                    ;;

                  run) # Run program
                    ./hi ${@+"${@}"}
                    extra_args=$#
                    ;;

                  *)
                    defaultify "${just_arg}" ${@+"${@}"}
                    ;;
                esac
              }

              if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' >> "${1}"
  fi
}

###############
### Pipfile ###
###############
function write_pipfile()
{
  exists "${1}" && return 0

  uwecho '[[source]]
          url = "https://pypi.org/simple"
          verify_ssl = true
          name = "pypi"

          [requires]
          # python_version = "*"

          [dev-packages]

          [packages]
          ' >> "${1}"
}

####################
### Pipfile.lock ###
####################
function write_pipfile_lock()
{
  exists "${1}" && return 0

  uwecho '{
              "_meta": {
                  "hash": {
                      "sha256": "415dfdcb118dd9bdfef17671cb7dcd78dbd69b6ae7d4f39e8b44e71d60ca72e7"
                  },
                  "pipfile-spec": 6,
                  "requires": {},
                  "sources": [
                      {
                          "name": "pypi",
                          "url": "https://pypi.org/simple",
                          "verify_ssl": true
                      }
                  ]
              },
              "default": {},
              "develop": {}
          }' >> "${1}"
}

##################
### Dockerfile ###
##################
function write_dockerfile()
{
  exists "${1}" && return 0

  uwecho   'FROM vsiri/recipe:gosu as gosu
            FROM vsiri/recipe:tini as tini
            FROM vsiri/recipe:vsi as vsi' >> "${1}"

  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho 'FROM vsiri/recipe:pipenv as pipenv

            ###############################################################################

            FROM debian:stretch as dep_stage
            SHELL ["/usr/bin/env", "bash", "-euxvc"]

            # Install any runtime dependencies
            RUN apt-get update; \
                DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                  # # Uncomment for GDAL
                  # gdal-bin \
                  python3 tzdata ca-certificates; \
                rm -r /var/lib/apt/lists/*

            ENV \
                # Move all virtualenvs to /venv
                WORKON_HOME=/venv \
                PIPENV_PIPFILE=/src/Pipfile \
                # The pipenv cache is how we avoid recompiling packages at runtime
                # when the build dependencies are no longer available
                PIPENV_CACHE_DIR=/venv/cache \
                # Needed for pipenv shell
                PYENV_SHELL=/bin/bash \
                # pipenv recommends that these env variables be set to en_US.UTF-8.
                # On debian, C.UTF-8 exists by default instead, and seems to work.
                # More detail: https://stackoverflow.com/a/38553499
                # Note: en_US.UTF-8 exists by default in Centos/Fedora base images
                LC_ALL=C.UTF-8 \
                LANG=C.UTF-8

            COPY --from=pipenv /usr/local /usr/local
            RUN for patch in /usr/local/share/just/container_build_patch/*; do "${patch}"; done

            ###############################################################################

            FROM dep_stage as pipenv_cache

            # # Uncomment for GDAL
            # # Install any build dependencies
            # RUN apt-get update; \
            #     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            #       libgdal-dev python3-dev g++ ; \
            #     rm -r /var/lib/apt/lists/*
            #
            #     # GDAL specific hacks
            # ENV CPLUS_INCLUDE_PATH=/usr/include/gdal \
            #     C_INCLUDE_PATH=/usr/include/gdal

            ADD Pipfile Pipfile.lock /src/
            # Simple packages can be added as dependencies to your project by:
            # - Running the container and installing them directly with pipenv; e.g.,
            #     just pipenv install scipy
            #     # installs scipy (Note: all other packages will be updated. Avoiding
            #     # this is difficult; the --keep-outdated flag is currently buggy)
            #     just sync (optionally update docker image)

            # GDAL, for example, is a more complicated example
            # - GDAL has extra build dependencies. The apt-get pattern above will install
            #   these dependencies.
            # - GDAL'"'"'s build script needs some customization. The ENV exports
            #   above accomplish this
            # - GDAL needs numpy installed before it is built, otherwise, numpy
            #   integration will not be compiled
            #
            # To test this out:
            # 1) Uncomment all the "Uncomment for GDAL" sections
            # 2) just sync
            # 3) Remove the existing pipenv install section below
            # 4) Edit your Pipfile and add the following lines (or similar) to the
            #    [packages] section
            #        gdal = "==2.1.0"
            #        numpy = "*"
            #    This will add the latest version of numpy and the version of
            #    gdal compatible with debian:stretch to your pipenv environment.
            #    Note: the version of the pypi package should match (as closely as
            #    possible) to the version of the GDAL-binary dependency (gdal-bin)
            # 5) just pipenv install
            # 6) just sync (optionally update docker image)
            #
            # Steps 4 and 5 can also be done by:
            # - just pipenv install numpy gdal==2.1.0
            # - These can be combined because numpy is already installed at
            #   just sync time, so numpy was already installed before gdal
            # - All other pipenv install arguments can be passed in, such as
            #   --pre, etc...

            # # Uncomment for GDAL
            # RUN \
            #     # Get the version marker of numpy specified in the lock file, else blank
            #     numpy_version="$(python -c "import json; print(json.load(open('"'"'${PIPENV_PIPFILE}.lock'"'"', '"'"'r'"'"'))['"'"'default'"'"']['"'"'numpy'"'"']['"'"'version'"'"'])" 2>/dev/null)" || :; \
            #     # Install numpy first, so that the gdal install works.
            #     pipenv run pip install numpy${numpy_version}; \
            #     # Now install all the packages.
            #     pipenv sync; \
            #     rm -rf /src/* /tmp/pip*

            RUN \
                # Install all packages into the image
                pipenv sync; \
                # Cleanup and make way for the real /src that will be mounted at runtime
                rm -rf /src/* /tmp/pip*

            ###############################################################################

            FROM pipenv_cache as pipenv_run

            COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu
            COPY --from=vsi /vsi /vsi

            ENTRYPOINT ["/usr/bin/env", "bash", "/vsi/linux/just_files/just_entrypoint.sh"]

            CMD ["bash"]

            ###############################################################################

            FROM dep_stage' >> "${1}"
  else
    uwecho '
            ###############################################################################

            FROM debian:stretch
            SHELL ["/usr/bin/env", "bash", "-euxvc"]

            # Install any runtime dependencies
            RUN apt-get update; \
                DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                  tzdata; \
                rm -r /var/lib/apt/lists/*' >> "${1}"
  fi

  uwecho   '
            # Install any additional packages
            RUN apt-get update; \
                DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                  # Example of a package
                  qbs-examples; \
                rm -rf /var/lib/apt/lists/*

            # Another typical example of installing a package
            # RUN build_deps="wget ca-certificates"; \
            #     apt-get update; \
            #     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${build_deps}; \
            #     wget -q https://www.vsi-ri.com/bin/deviceQuery; \
            #     DEBIAN_FRONTEND=noninteractive apt-get purge -y --autoremove ${build_deps}; \
            #     rm -rf /var/lib/apt/lists/*

            COPY --from=tini /usr/local /usr/local

            COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu
            # Allow non-privileged to run gosu (remove this to take root away from user)
            RUN chmod u+s /usr/local/bin/gosu
            ' >> "${1}"

  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho 'COPY --from=pipenv_cache /venv /venv' >> "${1}"
  fi

  uwecho   '
            COPY --from=vsi /vsi /vsi
            ADD ["'"$(docker_add_quote_escape "${PROJECT_NAME}.env")"'", "Pipfile", "Pipfile.lock", "/src/"]
            ADD ["'"$(docker_add_quote_escape docker/"${APP_NAME}.Justfile")"'", "/src/docker/"]

            ENV JUSTFILE="/src/docker/'"$(docker_env_quote_escape "${APP_NAME}.Justfile")"'" \
                JUST_SETTINGS="/src/'"$(docker_env_quote_escape "${PROJECT_NAME}.env")"'"

            ENTRYPOINT ["/usr/local/bin/tini", "--", "/usr/bin/env", "bash", "/vsi/linux/just_files/just_entrypoint.sh"]
            # Does not require execute permissions, unlike:
            # ENTRYPOINT ["/usr/local/bin/tini", "--", "/vsi/linux/just_files/just_entrypoint.sh"]

            CMD ["'"${APP_NAME}"'-cmd"]' >> "${1}"
}

####################
### app.Justfile ###
####################
function write_app_justfile()
{
  exists "${1}" 755 && return 0

  uwecho   '#!/usr/bin/env false bash

            source "${VSI_COMMON_DIR}/linux/just_files/just_default_run_functions.bsh"

            function caseify()
            {
              local cmd="${1}"
              shift 1
              case "${cmd}" in
            ' >> "${1}"

  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '    # default CMD
                '"${APP_NAME}"'-cmd) # Run example shell
                  echo "Run '"${APP_NAME}"' here: ${cmd} ${@+${@}}"
                  pipenv shell
                  ;;

                nopipenv) # Run command without pipenv
                  exec "${@}"
                  ;;

                pipenv) # Run pipenv command
                  exec "${cmd}" ${@+"${@}"}
                  ;;

                *)
                  defaultify "${cmd}" ${@+"${@}"}
                  ;;
              esac
            }' >> "${1}"
  else
    uwecho '    # default CMD
                '"${APP_NAME}"'-cmd) # Run example
                  echo "Run '"${APP_NAME}"' here: ${cmd} ${@+${@}}"
                  bash
                  extra_args=$#
                  ;;

                *)
                  defaultify "${cmd}" ${@+"${@}"}
                  ;;
              esac
            }' >> "${1}"
  fi
}

##########################
### docker-compose.yml ###
##########################
function write_docker_compose_yml()
{
  exists "${1}" && return 0

  uwecho   'version: "2.4"

            services:' >> "${1}"

  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '  '"${APP_NAME}"': &'"${APP_NAME}"'
                build: &'"${APP_NAME}"'_build' >> "${1}"
  else
    uwecho '  '"${APP_NAME}"':
                build:' >> "${1}"
  fi
  uwecho   '      context: .
                  dockerfile: docker/'"${APP_NAME}"'.Dockerfile
                # prevent different users from clobbering each others images
                image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME}
                environment:
                  # Variables for just_entrypoint_functions
                  - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
                  - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
                  - DOCKER_GROUP_NAMES=${'"${PROJECT_PREFIX}"'_GROUP_NAMES}
                  - DOCKER_USERNAME=user

            #       - DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

                  - DISPLAY
                  - JUSTFILE=/src/docker/'"${APP_NAME}"'.Justfile
                  - JUST_SETTINGS=/src/'"${PROJECT_NAME}"'.env
                  - TZ
            #     runtime: nvidia  # Uncomment for nvidia gpu support
            #     cap_add:
            #       - SYS_PTRACE # Useful for gdb
                volumes:
                  - type: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_TYPE}
                    source: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR}
                    target: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}' >> "${1}"
  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '      - type: volume
                    source: venv
                    target: /venv' >> "${1}"
  fi
  uwecho   '#       - type: volume
            #         source: home-volume
            #         target: ${'"${PROJECT_PREFIX}"'_HOME} # home-volume should be overridable' >> "${1}"
  if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '  '"${APP_NAME}"'_pipenv:
                <<: *'"${APP_NAME}"'
                build:
                  <<: *'"${APP_NAME}"'_build
                  target: pipenv_run
                image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_pipenv_${'"${PROJECT_PREFIX}"'_USERNAME}
            volumes:
              venv:
                labels:
                  com.vsi.just.clean_action: ask' >> "${1}"
  else
    echo   '# volumes:' >> "${1}"
  fi
  echo     '#   home-volume:' >> "${1}"
}

#####################
### .dockerignore ###
#####################
function write_dockerignore()
{
  exists "${1}" && return 0

  echo   '*' >> "${1}"
  echo   '!docker' >> "${1}"
  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo '!'"${RELATIVE_PATH}" >> "${1}"
  fi

  echo   '!'"${PROJECT_NAME}.env" >> "${1}"

  if [ "${USE_PIPENV}" = "1" ]; then
    echo '!Pipfile' >> "${1}"
    echo '!Pipfile.lock' >> "${1}"
  fi
}

######################
### .gitattributes ###
######################
function write_gitattributes()
{
  exists "${1}" && return 0
  uwecho '# These file types are being explicitly set to linux line endings for windows.
          # This is to allow windows user to edit and run these files inside a linux docker
          # this list may need additions as time goes on
          *.sh eol=lf
          *.bsh eol=lf
          *.py eol=lf
          *.env eol=lf
          .justplugins eol=lf
          Justfile eol=lf' >> "${1}"
  if [ "${USE_DOCKER}" = "1" ]; then
    echo '*.Justfile eol=lf' >> "${1}"
  fi
}

##############
### hi.cpp ###
##############
function write_hi_cpp()
{
  exists "${1}" && return 0
  uwecho '#include <iostream>
          int main()
          {
            std::cout << "hello world!" << std::endl;
            return 0;
          }' >> "${1}"
}

##################
### .gitignore ###
##################
function write_gitignore()
{
  if ! grep -q local.env "${1}" 2>/dev/null; then
    echo local.env >> "${1}"
  fi
  if ! grep -q local_post.env "${1}" 2>/dev/null; then
    echo local_post.env >> "${1}"
  fi
  if [ "${USE_DOCKER}" = "1" ]; then
    if ! grep -q .just_synced "${1}" 2>/dev/null; then
      echo .just_synced >> "${1}"
    fi
  fi
}

#**
# .. function:: new_just
#
# The main new_just function. The script to be in a function, or else streaming ``curl`` to bash won't work.
#**
function new_just()
{

  # Default values set for you
  if [ "${JUST_FROZEN-}" = "1" ]; then
    : ${USE_VSI_COMMON=n}
  else
    : ${USE_VSI_COMMON=y}
  fi

  : ${SETUPFILE=setup.env}
  : ${JUSTFILE=Justfile}


  while (($#)); do
    arg="$1"
    shift 1
    case $arg in
      --help)
        echo "New Just Wizard usage"
        echo "====================="
        echo "  --help - prints this help"
        echo "  --project-dir DIR - Use dir as the project directory"
        echo "  --project-name NAME - Affects project env filename and defaults"
        echo "  --prefix PREFIX - Set variable prefix to use"
        echo "  --justfile FILE - Set Justfile name"
        echo "  --setupfile FILE - Set setup.env filename"
        echo "  --vsi-dir DIR - VSI common submodule dir"
        echo "  --[no-]vsi - Enable/[disable] using the vsi submodule"
        echo "  --[no-]docker - Enable/[disable] setting up docker"
        echo "  --[no-]pipenv - Enable/[disable] using pipenv in docker"
        echo "  --app APP - Application name for docker-compose service"
        echo "  --repo REPO - Docker repo name for compiled images"
        echo "  --defaults - Use all defaults without prompting"
        echo "  --continue - Set to auto continue summary without prompting"
        echo "  --[no-]git - Run the necessary git command to init repo"
        echo
        exit 0
        ;;
      --defaults)
        USE_DEFAULTS=1
        : ${USE_DOCKER=y}
        : ${USE_PIPENV=y}
        : ${SETUP_GIT=n}
        ;;
      --project-dir)
        PROJECT_DIR="$1"
        shift 1
        ;;
      --project-name)
        PROJECT_NAME="$1"
        shift 1
        ;;
      --prefix)
        PROJECT_PREFIX="$1"
        shift 1
        ;;
      --justfile)
        JUSTFILE="$1"
        shift 1
        ;;
      --setupfile)
        SETUPFILE="$1"
        shift 1
        ;;
      --vsi-dir)
        VSI_DIR="$1"
        shift 1
        ;;
      --vsi)
        USE_VSI_COMMON=y
        ;;
      --no-vsi)
        USE_VSI_COMMON=n
        ;;
      --docker)
        USE_DOCKER=y
        ;;
      --no-docker)
        USE_DOCKER=n
        ;;
      --pipenv)
        USE_PIPENV=y
        ;;
      --no-pipenv)
        USE_PIPENV=n
        ;;
      --app)
        APP_NAME="$1"
        shift 1
        ;;
      --repo)
        REPO_NAME="$1"
        shift 1
        ;;
      --continue)
        CONTINUE=y
        ;;
      --git)
        SETUP_GIT=y
        ;;
      --no-git)
        SETUP_GIT=n
        ;;
      *)
        echo "Unknown argument: $arg"
        exit 1
        ;;
    esac
  done

  echo "Setting up a new project to use J.U.S.T."
  echo

  #**
  # .. env:: PROJECT_DIR
  #
  # The project directory is typically the root directory of the main git
  # repository. This is where all the just files will be stored by default.
  #
  # The value can be customized when prompted by :file:`new_just`. The default value
  # is the current working directory. The question can be skipped by setting
  # the environment variable :env:`PROJECT_DIR` to the desired value.
  #**

  if set_default PROJECT_DIR "${PWD}" "Project directory"; then
    mkdir -p "${PROJECT_DIR}"
    PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
  fi

  #**
  # .. env:: PROJECT_NAME
  #
  # The :env:`PROJECT_NAME` is used to set the project environment file name used by
  # :func:`just_functions.bsh source_environment_files`. Specifically: ``${PROJECT_DIR}/${PROJECT_NAME}.env``
  # :env:`PROJECT_NAME` is also used for for determining other default values.
  #
  # The value can be customized when prompted by :file:`new_just`. The default value
  # is basename of the :env:`PROJECT_DIR`. The question can be skipped by setting the
  # environment variable :env:`PROJECT_NAME` to the desired value.
  #
  # .. seealso::
  #   :func:`just_functions.bsh source_environment_files`
  #**

  set_default PROJECT_NAME "$(basename "${PROJECT_DIR}")" "Project name" || :

  #**
  # .. env:: PROJECT_PREFIX
  #
  # The prefix of environment variables for this project
  #
  # Used to set the value of :envvar:`JUST_PROJECT_PREFIX`. Must contain only valid bash
  # variable-name characters: ``[A-Z0-9_]+``
  #
  # Does not need the trailing _ included, this will always be added when it is
  # used.
  #
  # The value can be customized when prompted by new_just. The default value is
  # uppercase of the :env:`PROJECT_NAME`. The question can be skipped by setting the
  # environment variable :env:`PROJECT_PREFIX` to the desired value.
  #
  # .. seealso::
  #
  #   :envvar:`JUST_PROJECT_PREFIX`
  #**

  if set_default PROJECT_PREFIX \
                 "$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed -${sed_flag_rE} 's|[^A-Z0-9_]+||g')" \
                 "Project variable prefix"; then
    PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed -${sed_flag_rE} 's|[^A-Z0-9_]+||g')
  fi

  #**
  # .. env:: JUSTFILE
  #
  # Name of the justfile used
  #
  # The default just file in just is "Justfile". If this is changed, the only
  # way to inform just of this is by setting it in the :env:`SETUPFILE`. This will be
  # added to the :env:`SETUPFILE` by :file:`new_just` if anything other than the default is
  # used.
  #
  # The value can be customized when prompted by :file:`new_just`. The default value
  # is ``Justfile``. The question can be skipped by setting the environment variable
  # :env:`JUSTFILE` to the desired value.
  #
  # .. seealso::
  #
  #   :env:`SETUPFILE`, just/Justfile
  #**

  if set_default JUSTFILE "Justfile" "Just file name"; then
    JUSTFILE="$(basename "${JUSTFILE}")"
  fi

  #**
  # .. env:: USE_VSI_COMMON
  #
  # Flag to include vsi_common
  #
  # vsi_common can either be included as a submodule, in which case setup.env
  # is needed, or the just executable needs to be installed and vsi_common is
  # not needed.
  #**

  echo "If you do not include vsi_common, then all users will have to have"
  echo "the juste executable installed and on their path to use this project."
  echo "(It also makes updating vsi_common features/bugs harder.)"
  ask_question "Do you want to include the vsi_common submodule?" USE_VSI_COMMON n

  #**
  # .. env:: SETUPFILE
  #
  # Name of the setup file sourced to setup just environment
  #
  # The setup file is used to make the minimal necessary changes to the
  # environment so that just works. This includes adding paths and setting a
  # few environment variables. This is meant to be as unobtrusive as possible.
  #
  # This file needs to be sourced every time a new terminal session is opened.
  # The only time the setup script is not needed is when using :command:`juste`.
  #
  # The value can be customized when prompted by :file:`new_just`. The default value is
  # ``setup.env``. The question can be skipped by setting the environment variable
  # :env:`SETUPFILE` to the desired value.
  #
  # .. seealso::
  #
  #   :command:`juste`
  #**

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    if set_default SETUPFILE "setup.env" "Environment setup script file name"; then
      SETUPFILE="$(basename "${SETUPFILE}")"
    fi
  fi

  #**
  # .. env:: VSI_DIR
  #
  # Location of the vsi_common submodule
  #
  # The vsi_common repository is necessary for virtually all of the just
  # capabilities. The correct way to deal with this is to add vsi_common as a
  # submodule for your main project. This tells just were this submodule is
  # located.
  #
  # The value can be customized when prompted by :file:`new_just`. The default value is
  # external/vsi_common. The question can be skipped by setting the environment
  # variable :env:`VSI_DIR` to the desired value.
  #**

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    if set_default VSI_DIR "${PROJECT_DIR}/external/vsi_common" "VSI common module path"; then
      # Guarantee the path is clean, no .. or . or // in the name
      VSI_DIR="$(cd "${PROJECT_DIR}";
                if [ -e "${VSI_DIR}" ]; then
                  cd "${VSI_DIR}";
                  pwd;
                else
                  mkdir -p "${VSI_DIR}";
                  cd "${VSI_DIR}";
                  pwd;
                  cd "${PROJECT_DIR}";
                  rmdir "${VSI_DIR}";
                fi )"  # <- the space after the fi fixes a VSCode highlighter bug
    fi
  fi

  #**
  # .. rubric:: Docker Stuff
  #
  # .. env:: USE_DOCKER
  #
  # Flag to turn on all the docker features
  #**

  ask_question "Use docker?" USE_DOCKER y

  #**
  # .. env:: USE_PIPENV
  #
  # Flag to turn on setting up pipenv
  #**

  ask_question "Use pipenv?" USE_PIPENV y
  if [ "${USE_DOCKER}" = "1" ]; then

  #**
  # .. env:: APP_NAME
  #
  # The name of the test app generated. Used for the name of the first service populated for you.
  #**
    if set_default APP_NAME \
                   "$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed -${sed_flag_rE} 's|[^a-z0-9_.-]+||g')" \
                   "Name of the example docker-compose app"; then
      APP_NAME=$(echo "${APP_NAME}" | tr '[A-Z]' '[a-z]' | sed -${sed_flag_rE} 's|[^a-z0-9_.-]+||g')
    fi

    APP_NAME_UPPER=$(echo "${APP_NAME}" | tr '[a-z]' '[A-Z]')

  #**
  # .. env:: REPO_NAME
  #
  # When docker images are built, they need to be named, or else the only way to
  # access them is inconveniently though sha256 checksums.
  #
  # The :env:`REPO_NAME` should be an untagged docker repository name. Tag names will
  # be added for each service. Docker image names must match the regex
  # ``[a-zA-Z0-9][a-zA-Z0-9_.-]*`` or else docker will error
  #
  # The value can be customized when prompted by :file:`new_just`. The default value is
  # lowercase of the :env:`PROJECT_NAME`. The question can be skipped by setting the
  # environment variable :env:`REPO_NAME` to the desired value.
  #**
    if set_default REPO_NAME \
                   "$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed -${sed_flag_rE} 's|[^a-z0-9_./-]+||g')" \
                   "Docker Repo for images"; then
      REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed -${sed_flag_rE} 's|[^a-z0-9_./-]+||g')
    fi
  fi

  echo "Summary"
  echo "======="
  printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
  printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
  printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
  printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
  if [ "${USE_VSI_COMMON}" = "1" ]; then
    printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
  fi

  printf "%-40s | %-40s\n" "Use docker" "${USE_DOCKER}"
  printf "%-40s | %-40s\n" "Use pipenv" "${USE_PIPENV}"
  printf "%-40s | %-40s\n" "Include vsi_common" "${USE_VSI_COMMON}"
  if [ "${USE_DOCKER}" = "1" ]; then

    printf "%-40s | %-40s\n" "App Name" "${APP_NAME}"
    printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      printf "%-40s | %-40s\n" "VSI Common Directory" "${VSI_DIR}"
    fi
  fi
  echo
  # Ask y/n question
  ask_question "Continue?" CONTINUE y

  if [ "${CONTINUE}" != "1" ]; then
    exit 1
  fi

  # Setup done, start making the new environment

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    # RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${VSI_DIR}', '${PROJECT_DIR}'))")"
    # RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${VSI_DIR}','${PROJECT_DIR}');")"
    RELATIVE_PATH="$(relative_path "${VSI_DIR}" "${PROJECT_DIR}")"
  fi

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    just_cmd="just"
  else
    just_cmd="juste"
  fi

  # Make project dir
  mkdir -p "${PROJECT_DIR}"
  cd "${PROJECT_DIR}"

  ###################
  # Write out files #
  ###################
  if [ "${USE_VSI_COMMON}" = "1" ]; then
    write_setup_env "${SETUPFILE}"
  fi

  write_project_env "${PROJECT_NAME}.env"
  write_readme_md "README.md"
  write_justfile "${JUSTFILE}" 755

  if [ "${USE_PIPENV}" = "1" ]; then
    write_pipfile Pipfile
    write_pipfile_lock Pipfile.lock
  fi

  if [ "${USE_DOCKER}" = "1" ]; then
    mkdir -p docker

    write_dockerfile "docker/${APP_NAME}.Dockerfile"
    write_app_justfile "docker/${APP_NAME}.Justfile"
    write_docker_compose_yml docker-compose.yml
    write_dockerignore .dockerignore
  else
    write_hi_cpp hi.cpp
  fi

  ###
  # Some final bookkeeping...
  ###

  write_gitattributes .gitattributes
  write_gitignore .gitignore

  # ****************************************************************************
  # ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
  # ****************************************************************************

  cmds=()

  uwecho "Done!


          To complete your git initialization, the following commands must be run:
          ------------------------------------------------------------------------"
  cmds+=("cd $(quote_escape "${PROJECT_DIR}")")
  if [ ! -e .git ]; then
    cmds+=("git init .")
  fi

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    cmds+=("git submodule add https://github.com/visionsystemsinc/vsi_common.git $(quote_escape "${RELATIVE_PATH}")"
          "git submodule update --init --recursive"
          "pushd $(quote_escape "${RELATIVE_PATH}")"
          "git remote set-url origin --push git@github.com:visionsystemsinc/vsi_common.git"
          "popd"
          "git add $(quote_escape "${SETUPFILE}") .gitmodules")
  fi

  cmds+=("git add .gitignore README.md $(quote_escape "${JUSTFILE}") $(quote_escape "${PROJECT_NAME}").env")

  if [ "${USE_DOCKER}" = "1" ]; then
    cmds+=("git add .gitattributes .dockerignore docker-compose.yml docker/${APP_NAME}.Dockerfile docker/${APP_NAME}.Justfile")
  else
    cmds+=("git add hi.cpp")
  fi
  if [ "${USE_PIPENV}" = "1" ]; then
    cmds+=("git add Pipfile Pipfile.lock")
  fi

  cmds+=("git commit -m 'Initial commit'")

  for cmd in "${cmds[@]}"; do
    echo "${cmd}" >&${just_stdout-1}
  done

  echo ""
  ask_question "Do you want these git commands to be executed for you now?" SETUP_GIT n

  if [ "${SETUP_GIT}" = "1" ]; then
    for cmd in "${cmds[@]}"; do
      eval "${cmd}"
    done

    . "${VSI_DIR}/linux/just_files/just_version.bsh"
    local sed_inplace=(sed -i)
    if [[ ${OSTYPE} == darwin* ]]; then
      sed_inplace+=('')
    fi

    "${sed_inplace[@]}" 's|^JUST_VERSION="new_just"$|JUST_VERSION="'"${JUST_VERSION}"'"|' "${PROJECT_NAME}.env"
  fi

  uwecho "


          To use your new just:

          cd $(quote_escape "${PROJECT_DIR}")"

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo "source $(quote_escape "${SETUPFILE}")"
  fi

  uwecho "${just_cmd} help

          Get started with:"

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho "${just_cmd} sync
            ${just_cmd} run ${APP_NAME} bash"
  else
    uwecho "${just_cmd} compile
            ${just_cmd} run"
  fi
}

true

# If statement in case mktemp is commented out for development purposes
if [ -e "${temp_file-}" ]; then
  source "${temp_file}"
fi

function new_just_cleanup()
{
  local rv="$?"

  if [ "${new_just_cleanup_called-}" = "0" ]; then
    return "${rv}"
  fi

  # We want to delete the temp file when we are done executing, so that uwecho
  # can use the file, the entire point of making the file
  if [ -e "${temp_file-}" ]; then
    \rm "${temp_file}"
  fi
  echo

  if [ "${1-}" = "term" ]; then
    new_just_cleanup_called=0
    exit_chain 143
  elif [ "${1-}" = "int" ]; then
    new_just_cleanup_called=0
    exit_chain 130
  fi

  return "${rv}"
}

if [ "${BASH_SOURCE[0]}" = "${0}" ] || [ "$(basename "${BASH_SOURCE[0]}")" = "${0}" ]; then
  set -eu

  # Cleanup
  trap "new_just_cleanup exit" EXIT
  trap "new_just_cleanup int" INT
  trap "new_just_cleanup term" TERM
  # I didn't makes these traps just "exit", becuase I'm not sure that'll work
  # in all OSes and cornercases

  # Redirect stderr to stdout, and stdout to 3; now the only way to write to
  # stdout or stderr is to write to 3
  exec 3>&1 # Copy stdout to 3
  exec 1>&2 # Copy stderr to 1
  just_stdout=3 new_just ${@+"${@}"}

  # # Stop new_just_cleanup from being called twice
  # trap -- EXIT
else
  # uwecho won't work right unless this file is kept around, so if being sourced,
  # then vsi_common_dir is there, and use trap_chain

  source "${VSI_COMMON_DIR}/linux/signal_tools.bsh"

  trap_chain "new_just_cleanup exit" EXIT
  trap_chain "new_just_cleanup int" INT
  trap_chain "new_just_cleanup term" TERM
fi
