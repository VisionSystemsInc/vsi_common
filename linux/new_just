#!/usr/bin/env bash

# Usage:
#   bash <(curl -sL https://raw.githubusercontent.com/VisionSystemsInc/vsi_common/master/linux/new_just)

set -eu

# Redirect stderr to stdout, and stdout to 3; now the only way to write to
# stdout or stderr is to write to 3
exec 3>&1 # Copy stdout to 3
exec 1>&2 # Copy stderr to 1

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
if [ -f "${VSI_COMMON_DIR}/linux/ask_question" ]; then
  source "${VSI_COMMON_DIR}/linux/ask_question"
else
  function ask_question()
  {
    if [ "${!2-}" != "1" ]; then
      read -r -p "${1} (${3}) " "${2}"
    fi

    if [ -z "${!2-unset}" ] || [ "${!2::1}" = "1" ] ||
       [ "${!2::1}" = "y" ] || [ "${!2::1}" = "Y" ]; then
      eval $2=1
    else
      eval $2=0
    fi
  }
fi

# Use unwrapping echo so that this file is easier to read
if [ -f "${VSI_COMMON_DIR}/linux/uwecho.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
else
  function uwecho()
  {
    local line_number="$(caller)"
    local file_name="${line_number#* }"
    line_number="${line_number%% *}"
    local lines="$(echo -n ${@+"${@}"} | wc -l)"
    line_number=$((line_number-lines))
    local source_line="$(sed -n "${line_number}p" "${file_name}")"
    local spaces="$(echo -n "${source_line}" | sed -E 's|^( *uwecho ['"'"'"]?).*|\1|' | wc -c)"
    local args=()
    while (( $# )); do
      args+=("$(sed '2,$s|^ \{'"${spaces}"'\}||' <<< "$1")")
      shift 1
    done
    echo ${args+"${args[@]}"}
  }
fi

# Use a bash relpath function
if [ -f "${VSI_COMMON_DIR}/linux/relpath" ]; then
  source "${VSI_COMMON_DIR}/linux/relpath"
else
  function relpath()
  {
    current="${1:+"$2"}"
    target="${1:-"$2"}"
    if [[ ${target} =~ ^\./*$ ]]; then
      target="/"
    fi
    if [[ ${current} =~ ^\./*$ ]]; then
      current="/"
    fi
    : "${current:="/"}"
    target="/$(sed -E 's|^/*||;s|/*$||' <<< "${target}")" >&2
    current="/$(sed -E 's|^/*||;s|/*$||' <<< "${current}")" >&2
    appendix="${target##/}"
    relative=''
    while appendix="${target#"$current"/}"
      [ "$current" != '/' ] && [ "$appendix" = "$target" ]; do
      if [ "$current" = "$appendix" ]; then
        relative="${relative:-.}"
        echo "${relative#/}"
        return 0
      fi
      current="${current%/*}"
      relative="$relative${relative:+/}.."
    done
    relative="$relative${relative:+${appendix:+/}}${appendix#/}"
    echo "$relative"
  }
fi

#****F* just/new_just
# NAME
#   new_just - Create a new just project
# DESCRIPTION
#   There are many moving pieces to set up a working just project and use
#   all the features. Just getting started is hard, without knowing where to
#   start. This script will create all the files necessary to have a new
#   docker-compose based just project up and running.
# USAGE
#   By default, new_just will prompt the user for questions on the initial
#   setup parameters. Default values are supplied for all questions, and enter
#   can be pressed to accept all the defaults. All of the questions can be set
#   using environment variables, making them scriptable.
#
#   After new_just is called, a few git commands need to be called. This is not
#   done for you, in case it will break your existing repository. These
#   commands are printed out on stdout, while everything else is printed on
#   stderr, making them scriptable.
#
#   If any of the files written to exist, they are not overwritten, and a warning
#   message is printed out.
# SEE ALSO
#   new_just/PROJECT_DIR, new_just/PROJECT_NAME, new_just/PROJECT_PREFIX
#   new_just/REPO_NAME, new_just/JUSTFILE, new_just/WRAPFILE, new_just/SETUPFILE
#   new_just/VSI_DIR
# AUTHOR
#   Andy Neff
#***

echo "Setting up a new project to use J.U.S.T."
echo

#****d* new_just/PROJECT_DIR
# NAME
#   PROJECT_DIR - The main project directory
# DESCRIPTION
#   The project directory is typically the root directory of the main git
#   repository. This is where all the just files will be stored by default.
#
#   The value can be customized when prompted by new_just. The default value
#   is the current working directory. The question can be skipped by setting
#   the environment variable PROJECT_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_DIR="$(read -r -p "Project directory (${PWD}) " x; echo "$x")"}
if [ "${PROJECT_DIR}" == "" ]; then
  PROJECT_DIR="${PWD}"
else
  mkdir -p "${PROJECT_DIR}"
  PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
fi

#****d* new_just/PROJECT_NAME
# NAME
#   PROJECT_NAME - Name of the just project being created
# DESCRIPTION
#   The PROJECT_NAME is used to set the project environment file name used by
#   source_environment_files. Specifically: ${PROJECT_DIR}/${PROJECT_NAME}.env
#   PROJECT_NAME is also used for for determining other default values.
#
#   The value can be customized when prompted by new_just. The default value
#   is basename of the PROJECT_DIR. The question can be skipped by setting the
#   environment variable PROJECT_NAME to the desired value.
# SEE ALSO
#   just/source_environment_files
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_NAME="$(read -r -p "Project name ($(basename "${PROJECT_DIR}")) " x; echo "$x")"}
if [ "${PROJECT_NAME}" == "" ]; then
  PROJECT_NAME="$(basename "${PROJECT_DIR}")"
fi

#****d* new_just/PROJECT_PREFIX
# NAME
#   PROJECT_PREFIX - The prefix of environment variables for this project
# DESCRIPTION
#   Used to set the value of JUST_PROJECT_PREFIX. Must contain only valid bash
#   variable-name characters: [A-Z0-9_]+
#
#   Does not need the trailing _ included, this will always be added when it is
#   used.
#
#   The value can be customized when prompted by new_just. The default value is
#   uppercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable PROJECT_PREFIX to the desired value.
# SEE ALSO
#   just/JUST_PROJECT_PREFIX
# AUTHOR
#   Andy Neff
#***
default=$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed -E 's|[^A-Z0-9_]+||g')
: ${PROJECT_PREFIX="$(read -r -p "Project variable prefix (${default}) " x; echo $x)"}
if [ "${PROJECT_PREFIX}" == "" ]; then
  PROJECT_PREFIX=${default}
else
  PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed -E 's|[^A-Z0-9_]+||g')
fi

#****d* new_just/JUSTFILE
# NAME
#   JUSTFILE - Name of the justfile used
# DESCRIPTION
#   The default just file in just is "Justfile". If this is changed, the only
#   way to inform just of this is by setting it in the SETUPFILE. This will be
#   added to the SETUPFILE by new_just if anything other than the default is
#   used.
#
#   The value can be customized when prompted by new_just. The default value
#   is Justfile. The question can be skipped by setting the environment variable
#   JUSTFILE to the desired value.
# SEE ALSO
#   new_just/SETUPFILE, just/Justfile
# AUTHOR
#   Andy Neff
#***
: ${JUSTFILE="$(read -r -p "Just file name (Justfile) " x; echo "$x")"}
if [ "${JUSTFILE}" == "" ]; then
  JUSTFILE="Justfile"
else
  JUSTFILE="$(basename ${JUSTFILE})"
fi

#****d* new_just/USE_VSI_COMMON
# NAME
#   USE_VSI_COMMON - Flag to include vsi_common
# DESCRIPTION
#   vsi_common can either be included as a submodule, in which case setup.env
#   is needed, or the just executable needs to be installed and vsi_common is
#   not needed.
# AUTHOR
#   Andy Neff
#***
echo "If you do not include vsi_common, then all users till have to have"
echo "the just executable installed and on their path to use this project."
echo "(It also makes updating vsi_common features/bugs harder)"
ask_question "Do you want to include the vsi_common submodule?" USE_VSI_COMMON y

#****d* new_just/SETUPFILE
# NAME
#   SETUPFILE - Name of the setup file sourced to setup just environment
# DESCRIPTION
#   The setup file is used to make the minimal necessary changes to the
#   environment so that just works. This includes adding paths and setting a
#   few environment variables. This is meant to be as unobtrusive as possible.
#
#   This file needs to be sourced every time a new terminal session is opened.
#   The only time the setup script is not needed is when calling the WRAPFILE.
#
#   The value can be customized when prompted by new_just. The default value is
#   setup.env. The question can be skipped by setting the environment variable
#   SETUPFILE to the desired value.
# SEE ALSO
#   new_just/WRAPFILE
# AUTHOR
#   Andy Neff
#***
if [ "${USE_VSI_COMMON}" = "1" ]; then

  : ${SETUPFILE="$(read -r -p "Environment setup script file name (setup.env) " x; echo "$x")"}
  if [ "${SETUPFILE}" == "" ]; then
    SETUPFILE="setup.env"
  else
    SETUPFILE="$(basename ${SETUPFILE})"
  fi

#****d* new_just/WRAPFILE
# NAME
#   WRAPFILE - The wrap filename that runs any command in the just environment
# DESCRIPTION
#   The wrap file can be used to run any command in the full just environment or
#   to enter a bash session in this environment.
#
#   The value can be customized when prompted by new_just. The default value is
#   wrap. The question can be skipped by setting the environment variable
#   WRAPFILE to the desired value.
# SEE ALSO
#   just/just_env
# AUTHOR
#   Andy Neff
#***
  : ${WRAPFILE="$(read -r -p "Wrap script file name (wrap) " x; echo "$x")"}
  if [ "${WRAPFILE}" == "" ]; then
    WRAPFILE="wrap"
  else
    WRAPFILE="$(basename ${WRAPFILE})"
  fi
fi

#****d* new_just/VSI_DIR
# NAME
#   VSI_DIR - Location of the vsi_common submodule
# DESCRIPTION
#   The vsi_common repository is necessary for virtually all of the just
#   capabilities. The correct way to deal with this is to add vsi_common as a
#   submodule for your main project. This tells just were this submodule is
#   located.
#
#   The value can be customized when prompted by new_just. The default value is
#   external/vsi_common. The question can be skipped by setting the environment
#   variable VSI_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
if [ "${USE_VSI_COMMON}" = "1" ]; then
  : ${VSI_DIR="$(read -r -p "VSI common module path (./external/vsi_common) " x; echo "$x")"}
  if [ "${VSI_DIR}" == "" ]; then
    VSI_DIR="${PROJECT_DIR}/external/vsi_common"
  else
    VSI_DIR="$(cd "${PROJECT_DIR}";
               mkdir -p "${VSI_DIR}";
               cd "${VSI_DIR}";
               pwd;
               cd -;
               rmdir "${VSI_DIR}")"
  fi
fi

## Docker Stuff

#****d* new_just/USE_DOCKER
# NAME
#   USE_DOCKER - Flag to turn on all the docker features
# AUTHOR
#   Andy Neff
#***
ask_question "Use docker?" USE_DOCKER y

#****d* new_just/USE_PIPENV
# NAME
#   USE_PIPENV - Flag to turn on setting up pipenv
# AUTHOR
#   Andy Neff
#***
ask_question "Use pipenv?" USE_PIPENV y

if [ "${USE_DOCKER}" = "1" ]; then
  #****d* new_just/APP_NAME
  # NAME
  #   APP_NAME - The name of the test app generated
  # DESCRIPTION
  #   Used for the name of the first service populated for you
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_.-]+||g')
  : ${APP_NAME="$(read -r -p "Name of the example docker-compose app (${default}) " x; echo $x)"}
  if [ "${APP_NAME}" == "" ]; then
    APP_NAME=${default}
  else
    APP_NAME=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_.-]+||g')
  fi

  APP_NAME_UPPER=$(echo "${APP_NAME}" | tr '[a-z]' '[A-Z]')

  #****d* new_just/REPO_NAME
  # NAME
  #   REPO_NAME - Name of docker repository where images are stored
  # DESCRIPTION
  #   When docker images are built, they need to be named, or else the only way to
  #   access them is inconveniently though sha256 checksums.
  #
  #   The REPO_NAME should be an untagged docker repository name. Tag names will
  #   be added for each service. Docker image names must match the regex
  #   [a-zA-Z0-9][a-zA-Z0-9_.-]* or else docker will error
  #
  #   The value can be customized when prompted by new_just. The default value is
  #   lowercase of the PROJECT_NAME. The question can be skipped by setting the
  #   environment variable REPO_NAME to the desired value.
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_./-]+||g')
  : ${REPO_NAME="$(read -r -p "Docker Repo for images (${default}) " x; echo $x)"}
  if [ "${REPO_NAME}" == "" ]; then
    REPO_NAME=${default}
  else
    REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_./-]+||g')
  fi
fi

echo "Summary"
echo "======="
printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
if [ "${USE_VSI_COMMON}" = "1" ]; then
  printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
  printf "%-40s | %-40s\n" "Wrap script" "${WRAPFILE}"
fi

printf "%-40s | %-40s\n" "Use docker" "${USE_DOCKER}"
printf "%-40s | %-40s\n" "Use pipenv" "${USE_PIPENV}"
printf "%-40s | %-40s\n" "Include vsi_common" "${USE_VSI_COMMON}"
if [ "${USE_DOCKER}" = "1" ]; then

  printf "%-40s | %-40s\n" "App Name" "${APP_NAME}"
  printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
  if [ "${USE_VSI_COMMON}" = "1" ]; then
    printf "%-40s | %-40s\n" "VSI Common Directory" "${VSI_DIR}"
  fi
fi
echo
# Ask y/n question
ask_question "Continue?" CONTINUE y

if [ "${CONTINUE}" != "1" ]; then
  exit 1
fi

# Setup done, start making the new environment

if [ "${USE_VSI_COMMON}" = "1" ]; then
  # RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${VSI_DIR}', '${PROJECT_DIR}'))")"
  # RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${VSI_DIR}','${PROJECT_DIR}');")"
  RELATIVE_PATH="$(relpath "${VSI_DIR}" "${PROJECT_DIR}")"
fi

# Make project dir
mkdir -p "${PROJECT_DIR}"
cd "${PROJECT_DIR}"

############
### wrap ###
############

if [ "${USE_VSI_COMMON}" = "1" ]; then
  if [ ! -e "${WRAPFILE}" ]; then
    echo   '#!/usr/bin/env bash' > "${WRAPFILE}"
    if [ "${JUSTFILE}" != "Justfile" ]; then
      echo "export JUSTFILE=${JUSTFILE}" >> "${WRAPFILE}"
    fi
    uwecho ': "$(\dirname "${BASH_SOURCE[0]}")"
            source "${VSI_COMMON_DIR:-"${_}"/'"${RELATIVE_PATH}"'}/linux/just_env" "${_}"/'"${PROJECT_NAME}"'.env ${@+"${@}"}' >> "${WRAPFILE}"

  else
    echo "${WRAPFILE} exists, skipping..."
  fi

  #################
  ### setup.env ###
  #################

  if [ ! -e "${SETUPFILE}" ]; then
    uwecho 'export JUST_SETUP_SCRIPT="$(\basename "${BASH_SOURCE[0]}")"
            unset JUST_VERSION
            source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/'"${RELATIVE_PATH}"'/env.bsh"' > "${SETUPFILE}"
    if [ "${JUSTFILE}" != "Justfile" ]; then
      echo "export JUSTFILE=${JUSTFILE}" >> "${SETUPFILE}"
    else
      echo "unset JUSTFILE" >> "${SETUPFILE}"
    fi
  else
    echo "${SETUPFILE} exists, skipping..."
  fi
fi

###################
### project.env ###
###################

if [ ! -e "${PROJECT_NAME}.env" ]; then

  uwecho   'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
            '"${PROJECT_PREFIX}"'_CWD="${CWD-"$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"}"
            '  > "${PROJECT_NAME}.env"

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho ': ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

            : ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
            : ${'"${PROJECT_PREFIX}"'_USERNAME=$(id -u -n)}
            : ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
            : ${'"${PROJECT_PREFIX}"'_GIDS=$(id -G)}
            : ${'"${PROJECT_PREFIX}"'_GROUP_NAMES=$(group_names)}

            # This directory is setup using docker-compose file. It always exists
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR="${'"${PROJECT_PREFIX}"'_CWD}"}
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER="/src"}

            # This directory is setup using '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES below
            # This is a better mechanism, in case the directory doesn'"'"'t exist. The directory
            # will be created and owned properly
            : ${'"${PROJECT_PREFIX}"'_DATA_DIR="${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/new-data"}
            : ${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER="/data"}

            if [ "${VSI_OS}" = "linux" ]; then
              '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
                  ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
            fi

            '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES=(
                "${'"${PROJECT_PREFIX}"'_DATA_DIR}:${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER}"
                ${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES[@]}"})

            ###############################################################################
            ### Non-'"${PROJECT_PREFIX}"' Setting ###
            ###############################################################################

            # Put variables that do not begin with '"${PROJECT_PREFIX}"' here.

            # Use this to add the user name to the docker-compose project name. This is
            # important when multiple users are using this docker-compose project on a
            # single host. This way all of the docker resources are prefixed with a unique
            # name and do not collide
            source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
            : ${COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${'"${PROJECT_PREFIX}"'_CWD}" "${'"${PROJECT_PREFIX}"'_USERNAME}")}

            ' >> "${PROJECT_NAME}.env"
  fi

else
  echo "${PROJECT_NAME}.env exists, skipping..."
fi

#################
### README.md ###
#################

if [ ! -e "README.md" ]; then
  uwecho '## Getting started

          ```
          source setup.env' > README.md
if [ "${USE_DOCKER}" = "1" ]; then
  uwecho "just setup
          just run ${APP_NAME}" >> README.md
else
  uwecho "just compile
          just run" >> README.md
fi
  uwecho '```

          ## Just usage:

          ```' >> README.md

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo 'source "'"${SETUPFILE}"'"' >> README.md
  fi

  uwecho 'just help
          ```
          ' >> README.md
else
  echo "README.md exists, skipping..."
fi

# Make Just file
if [ ! -e "${JUSTFILE}" ]; then
  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho '#!/usr/bin/env bash

            if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
              set -euE
            fi
            ' > "${JUSTFILE}"
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo 'source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/'"${WRAPFILE}"'"' >> "${JUSTFILE}"
    else
      echo 'source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'"${PROJECT_NAME}"'.env' >> "${JUSTFILE}"
    fi
    uwecho 'cd "${'"${PROJECT_PREFIX}"'_CWD}"

            # Plugins
            source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
            source "${VSI_COMMON_DIR}/linux/just_docker_functions.bsh"
            source "${VSI_COMMON_DIR}/linux/just_git_functions.bsh"

            # Main function
            function caseify()
            {
              local just_arg=$1
              shift 1
              case ${just_arg} in
                build) # Build Docker image
                  if [ "$#" -gt "0" ]; then
                    Docker-compose "${just_arg}" ${@+"${@}"}
                    extra_args+=$#
                  else
                    (justify build_recipes gosu tini vsi)
                    Docker-compose build
                  fi
                  ;;
                run_'"${APP_NAME}"') # Run '"${APP_NAME}"' 1
                  Just-docker-compose run '"${APP_NAME}"' ${@+"${@}"}
                  extra_args+=$#
                  ;;

                setup) # Run any special command to set up the environment for the first \
                  # time after checking out the repo. Usually population of volumes/databases \
                  # go here.
                  (justify _sync)
                  ;;
                sync) # Synchronize the many aspects of the project when new code changes \
                      # are applied e.g. after "git checkout"
                  (justify _sync)
                  # Add any extra steps run when syncing when not installing
                  ;;
                _sync)
                  Docker-compose down
                  (justify git_submodule-update) # For those users who don'"'"'t remember!
                  (justify build)' >> "${JUSTFILE}"
    if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '      (justify clean venv)
                  ;;
                clean_all) # Delete all local volumes
                  ask_question "Are you sure? This will packages not in Pipfile!" n
                  (justify clean venv)
                  ;;
                clean_venv) # Delete the virtual environment volume. The next container \
                            # to use this volume will automatically copy the contents from \
                            # the image.
                  if docker volume inspect "${COMPOSE_PROJECT_NAME}_venv" &> /dev/null; then
                    Docker volume rm "${COMPOSE_PROJECT_NAME}_venv"
                  else
                    echo "${COMPOSE_PROJECT_NAME}_venv already removed"
                  fi' >> "${JUSTFILE}"
    fi
    uwecho '      ;;
                *)
                  defaultify "${just_arg}" ${@+"${@}"}
                  ;;
              esac
            }

            if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' >> "${JUSTFILE}"
  else
    uwecho '#!/usr/bin/env bash

            if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
              set -euE
            fi

            ' > "${JUSTFILE}"
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo 'source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/'"${WRAPFILE}"'"' >> "${JUSTFILE}"
    else
      echo 'source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'"${PROJECT_NAME}"'.env' >> "${JUSTFILE}"
    fi
    uwecho 'cd "${'"${PROJECT_PREFIX}"'_CWD}"

            function caseify()
            {
              local just_arg=$1
              shift 1
              case ${just_arg} in
                compile) # Build program
                  g++ hi.cpp -o hi
                  ;;
                run) # Run program
                  ./hi ${@+"${@}"}
                  extra_args+=$#
                  ;;
                *)
                  defaultify "${just_arg}" ${@+"${@}"}
                  ;;
              esac
            }

            if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' > "${JUSTFILE}"
  fi
else
  echo "${JUSTFILE} exists, skipping..."
fi

if [ "${USE_PIPENV}" = "1" ]; then
  if [ ! -e "Pipfile" ]; then
    touch Pipfile
  fi
  if [ ! -e "Pipfile.lock" ]; then
    touch Pipfile.lock
  fi
fi

if [ "${USE_DOCKER}" = "1" ]; then
  mkdir -p docker

  # Make default dockerfiles
  if [ ! -e "docker/${APP_NAME}.Dockerfile" ]; then
    uwecho 'FROM vsiri/recipe:gosu as gosu
            FROM vsiri/recipe:tini as tini
            FROM vsiri/recipe:vsi as vsi' > docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      echo 'FROM vsiri/recipe:pipenv as pipenv' >> docker/${APP_NAME}.Dockerfile
    fi

    uwecho '
            FROM debian:stretch

            SHELL ["/usr/bin/env", "bash", "-euxvc"]

            # Example of installing packages
            RUN build_deps="wget ca-certificates"; \
                apt-get update; \
                DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${build_deps} python3; \
                wget -q https://www.vsi-ri.com/bin/deviceQuery; \
                DEBIAN_FRONTEND=noninteractive apt-get purge -y --autoremove ${build_deps}; \
                rm -rf /var/lib/apt/lists/*

            COPY --from=tini /usr/local/bin/tini /usr/local/bin/tini

            COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu
            # Allow non-privileged to run gosu (remove this to take root away from user)
            RUN chmod u+s /usr/local/bin/gosu
            ' >> docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'COPY --from=pipenv /tmp/pipenv /tmp/pipenv
              RUN python3 /tmp/pipenv/get-pipenv; rm -r /tmp/pipenv
              ENV WORKON_HOME=/venv \
                  PIPENV_PIPFILE=/src/Pipfile \
                  # Needed for pipenv shell \
                  PYENV_SHELL=/bin/bash \
                  LC_ALL=C.UTF-8 \
                  LANG=C.UTF-8
              ADD Pipfile Pipfile.lock /src/
              # Break apart into multiple steps if it gets too big. Manually pick big packages
              # And install them separate RUN commands
              RUN if [ ! -s Pipfile.lock ]; then \
                    pipenv lock; \
                  fi; \
                  pipenv install; \
                  # Cleanup and make way for the real /src that will be mounted at runtime
                  rm -r /src

              # Packages can be added to your project using either:
              # - "just run '"${APP_NAME}"'" and running "pipenv install {package}" e.g. "pipenv install scipy"
              # - Editing the Pipfile and adding lines to the [packages] section, e.g. "scipy = '"'"'*'"'"'"

              # Here'"'"'s a more complicated example, say GDAL is in your Pipfile
              # Hint: To get GDAL in the Pipfile, add '"'"'gdal = "==2.1.0"'"'"'
              #       to the [packages] section of the Pipfile.
              #       The version of the pypi package should match (as close as possible)
              #       the GDAL binary version installed; then uncomment these lines:
              # RUN build_deps="libgdal-dev python3-dev g++"; \
              #     apt-get update; \
              #     # Install build dependencies and runtime dependencies
              #     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
              #       gdal-bin ${build_deps}; \
              #     cd /src; \
              #     # Gdal specific hacks
              #     export CPLUS_INCLUDE_PATH=/usr/include/gdal; \
              #     export C_INCLUDE_PATH=/usr/include/gdal; \
              #     # Build up venv
              #     # First you must install the version of numpy specified by the Pipfile.lock
              #     if [ ! -s Pipfile.lock ]; then \
              #       pipenv lock; \
              #     fi; \
              #     pipenv install; \
              #     # Cleanup
              #     rm -rv /src/*; \
              #     # Remove build dependencies, you are done with them
              #     apt-get purge -y --auto-remove ${build_deps}; \
              #     rm -r /var/lib/apt/lists/*

              # Another Example
              # RUN if [ ! -s Pipfile.lock ]; then \
              #       pipenv lock; \
              #     fi; \
              #     # Some libraries like scikit-garden==0.1.3 need numpy setup tools installed
              #     # before installing the to compile with.
              #     pipenv install --skip-lock "numpy$(python3 -c "import json; print(json.load(open('"'"'Pipfile.lock'"'"', '"'"'r'"'"'))['"'"'default'"'"']['"'"'numpy'"'"']['"'"'version'"'"'])" 2>/dev/null)"; \
              #     # Install everything else now that numpy is available.
              #     pipenv sync

              ' >> docker/${APP_NAME}.Dockerfile
    fi

    uwecho '
            COPY --from=vsi /vsi /vsi
            ADD docker/'"${APP_NAME}"'_entrypoint.bsh /

            ENTRYPOINT ["/usr/local/bin/tini", "/usr/bin/env", "bash", "/'"${APP_NAME}"'_entrypoint.bsh"]
            # Does not require execute permissions, unlike:
            # ENTRYPOINT ["/usr/local/bin/tini", "/'"${APP_NAME}"'_entrypoint.bsh"]

            CMD ["'"${APP_NAME}"'"]' >> docker/${APP_NAME}.Dockerfile
  else
    echo   "docker/${APP_NAME}.Dockerfile exists, skipping..."
  fi

  if [ ! -e "docker/${APP_NAME}_entrypoint.bsh" ]; then
    uwecho '#!/usr/bin/env bash

            set -eu

            source "${VSI_COMMON_DIR:-/vsi}/linux/just_env" "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/'"${PROJECT_NAME}"'.env"

            if [ "${ALREADY_RUN_ONCE+set}" != "set" ]; then
              # create the user and associated groups and handle nfs symlinks

              # JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS will automatically chown
              # all files in volumes to match the user. If this takes too long
              # and you don'"'"'t need this feature, remove the ONE line, but leave
              # the docker_entrypoint.bsh call
              JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS="${JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES}" \
              /usr/bin/env bash /vsi/linux/docker_entrypoint.bsh

              # Rerun entrypoint as user now, (skipping the root part via ALREADY_RUN_ONCE)
              ALREADY_RUN_ONCE=1 exec gosu ${DOCKER_USERNAME} /usr/bin/env bash $0 ${@+"${@}"}
            fi

            function sudo()
            {
              gosu root ${@+"${@}"}
            }
            export -f sudo

            source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
            # Remove duplicate '"${PROJECT_PREFIX}"'_*_DOCKER variables
            filter_docker_variables

            ' >> "docker/${APP_NAME}_entrypoint.bsh"

    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'if [ "$1" == "'"${APP_NAME}"'" ]; then
                if [ ! -s "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/Pipfile.lock" ]; then
                  pipenv lock
                fi
                pipenv shell
              elif [ "$1" == "nopipenv" ]; then
                shift 1
                exec "${@}"
              else
                if [ ! -s "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/Pipfile.lock" ]; then
                  pipenv lock
                fi
                exec pipenv run "${@}"
              fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    else
      uwecho 'if [ "$1" == "'"${APP_NAME}"'" ]; then
                echo "Run '"${APP_NAME}"' here: ${@+${@}}"
              else
                exec "${@}"
              fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    fi
  else
    echo     "docker/${APP_NAME}_entrypoint.bsh exists, skipping..."
  fi


  # Make default docker-compose.yml
  if [ ! -e "docker-compose.yml" ]; then
    uwecho 'version: "2.3"

            services:
              '"${APP_NAME}"': &'"${APP_NAME}"'_anchor
                build:
                  context: .
                  dockerfile: docker/'"${APP_NAME}"'.Dockerfile
                # prevent different users from clobbering each others images
                image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME}
                environment:
                  # Variables for docker_entrypoint.bsh
                  - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
                  - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
                  - DOCKER_GROUP_NAMES=${'"${PROJECT_PREFIX}"'_GROUP_NAMES}
                  - DOCKER_USERNAME=user

                  #- DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

                  - DISPLAY
                # cap_add:
                #   - SYS_PTRACE # Useful for gdb
                volumes:
                  - type: bind
                    source: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR}
                    target: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}' > "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '      - type: volume
                      source: venv
                      target: /venv' >> "docker-compose.yml"
    fi
    uwecho '      # - type: volume
                  #   source: home-volume
                  #   target: ${'"${PROJECT_PREFIX}"'_HOME} # home-volume should be overridable
              '"${APP_NAME}"'2:
                <<: *'"${APP_NAME}"'_anchor' >> "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'volumes:
                venv:' >> "docker-compose.yml"
    else
      echo   '#   volumes:' >> "docker-compose.yml"
    fi
    echo     '#   home-volume:' >> "docker-compose.yml"
  else
    echo "docker-compose.yml exists, skipping..."
  fi

  if [ ! -e .dockerignore ]; then
    echo '*' > .dockerignore
    echo '!docker' >> .dockerignore
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo '!'"${RELATIVE_PATH}" >> .dockerignore
    fi

    if [ "${USE_PIPENV}" = "1" ]; then
      echo '!Pipfile' >> .dockerignore
      echo '!Pipfile.lock' >> .dockerignore
    fi
  fi


  if [ ! -e ".gitattributes" ]; then
    uwecho '#These file types are being explicitly set to linux line endings for windows.
            #This is to allow windows user to edit and run these files inside a linux docker
            #this list may need additions as time goes on
            *.sh eol=lf
            *.bsh eol=lf
            *.py eol=lf
            *.env eol=lf
            wrap eol=lf
            .justplugins eol=lf' > .gitattributes
  fi
else
  uwecho '#include <iostream>
          int main()
          {
            std::cout << "hello world!" << std::endl;
            return 0;
          }' > hi.cpp
fi

###
# Some final bookkeeping...
###

# Add executable permissions
chmod 755 "${JUSTFILE}"

if [ "${USE_VSI_COMMON}" = "1" ]; then
  chmod 755 "${WRAPFILE}"
fi

# Add .gitignore exceptions
if ! grep -q local.env .gitignore 2>/dev/null; then
  echo local.env >> .gitignore
fi
if ! grep -q local_post.env .gitignore 2>/dev/null; then
  echo local_post.env >> .gitignore
fi

# ****************************************************************************
# ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
# ****************************************************************************
uwecho "Done!


        To complete your git initialization:

        cd '${PROJECT_DIR}'"
if [ ! -e .git ]; then
  echo "git init ." >&3
fi

if [ "${USE_VSI_COMMON}" = "1" ]; then
  uwecho "git submodule add https://github.com/visionsystemsinc/vsi_common.git '${RELATIVE_PATH}'
          git submodule update --init --recursive
          pushd '${RELATIVE_PATH}'
          git remote set-url origin --push git@github.com:visionsystemsinc/vsi_common.git
          popd" >&3
  echo   "git add '${SETUPFILE}' '${WRAPFILE}' .gitmodules" >&3
fi

echo   "git add .gitignore README.md '${JUSTFILE}' '${PROJECT_NAME}.env'" >&3

if [ "${USE_DOCKER}" = "1" ]; then
  echo "git add .gitattributes .dockerignore docker-compose.yml docker/${APP_NAME}.Dockerfile docker/${APP_NAME}_entrypoint.bsh" >&3
else
  echo "git add hi.cpp" >&3
fi
if [ "${USE_PIPENV}" = "1" ]; then
  echo "git add Pipfile Pipfile.lock" >&3
fi

echo "git commit -m 'Initial commit'"  >&3
uwecho "


        To use your new just:

        cd '${PROJECT_DIR}'"

if [ "${USE_VSI_COMMON}" = "1" ]; then
  echo "source '${SETUPFILE}'"
fi

uwecho "just help

        Get started with:"

if [ "${USE_DOCKER}" = "1" ]; then
  uwecho "just setup
          just run ${APP_NAME} bash"
else
  uwecho "just compile
          just run"
fi
