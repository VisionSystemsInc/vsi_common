#!/usr/bin/env bash

if [[ ${-} != *i* ]]; then
  source_once &> /dev/null && return 0
fi

if [ -z "${VSI_COMMON_DIR+set}" ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
fi

source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
source "${VSI_COMMON_DIR}/linux/compat.bsh"
source "${VSI_COMMON_DIR}/linux/aliases.bsh"
source "${VSI_COMMON_DIR}/linux/findin"
source "${VSI_COMMON_DIR}/linux/requirements.bsh"
source "${VSI_COMMON_DIR}/linux/versions.bsh"


#*# linux/git_mirror

GIT_MIRROR_SOURCE="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"/"$(basename "${BASH_SOURCE[0]}")"

#**
# .. default-domain:: bash
#
# =========================================
# Git Mirror
# =========================================
#
# .. file:: git_mirror
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. The subcommands mirror, push and clone in this file, and associated functions, help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Example usage:
#
# #. ``git_mirror mirror https://github.com/visionsystemsinc/vsi_common.git master`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# #. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination
# #. On the destination, create a directory, e.g., vsi_common_prep, and move the archive into it
# #. Extract the archive (the archive will extract directly into this directory)
# #. Write an ``info.env`` file mapping each repository to its mirrored URL:
#
# .. code-block:: bash
#
#    repos[.]=https://git-server.com/foobar/vsi_common.git
#    repos[docker/recipes]=https://git-server.com/foobar/recipes.git
#
# 6. ``git_mirror push ./info.env ./transfer_extracted_dir/`` - Push the mirrored repository and all submodules to a new git server as defined by info.env
# #. ``git_mirror clone ./info.env ./my_project_dir/`` - Clone recursively from the new mirror
#**

#**
# .. function:: next_section
#
# Change the color of the text output to sdtout/stderr
#
# :Arguments: [``${@}``] - An optional string (or list of strings) to harold the next section
# :Output: A temporary file is created which stores the index into the COLORS array
#
# Change the current text color. A temporary file is created to track the current index into the COLORS array; this index is updated with each call to this function. This temporary file will automatically be deleted
#**

# TODO: Move to colors.bsh
# TODO: Switch to colors.bsh:get_color
# REVIEW Set a trap that resets the color on ERR or RETURN
function next_section()
{
  if [ -z "${COLOR_FILE+set}" ]; then
    make_temp_path COLOR_FILE
    export COLOR_FILE
  fi
  local COLORS=($'\e[32m' $'\e[33m' $'\e[34m' $'\e[35m' $'\e[36m' $'\e[0m')
  local -i COLOR_INDEX="$(cat "${COLOR_FILE}" || echo 0)"
  COLOR_INDEX+=1
  if [ "${COLOR_INDEX}" -ge ${#COLORS[@]} ]; then
    COLOR_INDEX=0
  fi
  echo "${COLOR_INDEX}" > "${COLOR_FILE}"
  echo "${COLORS[COLOR_INDEX]}"${@+"${@}"}
}

GIT_VERSION="$(git_version)"

#**
# .. function:: get_config_submodule_names
#
# Get list of initialized submodules, non-recursive
#
# :Output: A newline separated list of submodules for the current git repository
#
# Get a list of submodules of the current git repository. This command is non-recursive, i.e., submodules of submodule, etc. are not returned. An implementation of this feature is provided for older versions of git (<2.6)
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#    $ get_config_submodule_names() # from within ./vsi_common/
#    submodule.docker/recipes
#
# .. note::
#
#   Unlike ``git submodule foreach --quiet 'echo "${name}"'``, this function works for submodules that have been init'd but not updated
#
# .. seealso::
#
#   :func:`just_git_functions.bsh submodule-helper-list` and :func:`just_git_airgap_repo.bsh git_submodule_names`
#**

if meet_requirements "${GIT_VERSION}" ">=2.6"; then
  function get_config_submodule_names()
  {
    "${GIT}" config --name-only --get-regexp '^submodule\..*\.url$' | sed 's|.url$||'
  }
else
  function get_config_submodule_names()
  {
    local names=()
    local line
    # Get null terminated lines
    while IFS= read -r -d '' record; do
      # Get first newline terminated line of that record, it's the name
      IFS= read -r -d $'\n' record <<< "${record}"
      names+=("${record}")
    done < <("${GIT}" config -z --get-regexp '^submodule\..*\.url$')

    for line in ${names[@]+"${names[@]}"}; do
      echo "${line%.url}"
    done
  }
fi

#**
# .. function:: git_mirror_has_lfs
#
# Is git lfs available for the specified implementation of git
#
# :Output: ``0`` - git lfs is available
#          ``1`` - git lfs is not available
#
# :Internal Use: ``__git_mirror_has_lfs`` - A variable to save this state
#**

function git_mirror_has_lfs()
{
  if [ -z "${__git_mirror_has_lfs:+set}" ]; then
    if ! "${GIT}" lfs &> /dev/null; then
      __git_mirror_has_lfs=1 # Does not have lfs
    else
      __git_mirror_has_lfs=0 # Does have lfs
    fi
  fi
  return "${__git_mirror_has_lfs}"
}

#**
# .. function:: clone_submodules
#
# Mirror a submodule and all of its submodules (recursively)
#
# This is a helper function to :func:`git_mirror_main`. Create a mirror of each submodule in a git repository, recursively. Each mirror is stored according to its full relative path in the project repository in a unique temporary directory created in the ``GIT_MIRROR_PREP_DIR``. Submodules of a submodule are processed recursively in a depth-first fashion.
#
# WARNING: ``git submodule foreach`` runs commands via sh because git is weird; however I start bash and source this script for its vars and functions, so it's really bash again.
#
# :Parameters: ``GIT_MIRROR_PREP_DIR`` - The directory in which to mirror the repositories
#              [``base_submodule_path``] - The (relative) path from the project repository to a submodule with, potentially, submodules of its own that need to be mirrored/updated. This must also be the CWD. If unset, mirror the submodules of the parent repository.
#
# :Output: A mirrored submodule located at ``GIT_MIRROR_PREP_DIR/{temp_dir}/base_submodule_path``
#
# .. note::
#
#   This function assumes ``base_submodule_path`` is also the PWD
#**

function clone_submodules()
{
  # Init (any) submodules non-recursively
  "${GIT}" submodule init

  # Submodule names can't contain newlines
  local IFS=$'\n'
  # This does not work for init-only modules
  #   submodule_names=($("${GIT}" submodule foreach --quiet 'echo "${name}"'))
  # This does
  local submodule_names=($(get_config_submodule_names))

  local prepped_submodule_path
  local full_relative_path
  local submodule

  # I am currently in base_submodule_path of the local non-bare repo
  local base_submodule_path="${base_submodule_path-}${base_submodule_path:+/}${prefix-${displaypath-}}"
  # Remove trailing slashes because on some versions of git (1.8.3, 2.17.1)
  # prefix has a trailing slash
  base_submodule_path="${base_submodule_path%/}"

  # Update submodule urls to use GIT_MIRROR_PREP_DIR
  for submodule in ${submodule_names[@]+"${submodule_names[@]}"}; do
    # Calculate full submodule path wrt superproject (not just parent submodule)
    local sm_path="$("${GIT}" config -f .gitmodules ${submodule}.path)"
    full_relative_path="${base_submodule_path}${base_submodule_path:+/}${sm_path}"

    # Get the url of the submodule set by init above
    submodule_url="$("${GIT}" config "${submodule}.url")"

    # Search for existing prepped mirror
    # https://stackoverflow.com/a/52657447/4166604
    prepped_submodule_path="$(shopt -s nullglob; echo "${GIT_MIRROR_PREP_DIR}"/*/"${full_relative_path}/config")"
    # If I already have this submodule, use it
    if [ -f "${prepped_submodule_path}" ]; then
      prepped_submodule_path="$(dirname "${prepped_submodule_path}")"
      # cd into the prepped mirror
      pushd "${prepped_submodule_path}" &> /dev/null
        # Re-establish url in case it changed
        "${GIT}" remote set-url origin "${submodule_url}"
        # Fetch the latest changes
        if meet_requirements "${GIT_VERSION}" ">=2.17"; then
          "${GIT}" fetch -pP origin
        else
          "${GIT}" fetch -p origin
        fi
      popd &> /dev/null
    else
      prepped_submodule_path="$(mktemp_compat "${GIT_MIRROR_PREP_DIR}")/${full_relative_path}"
      next_section "Cloning a fresh copy of ${full_relative_path}"
      "${GIT}" clone --mirror "${submodule_url}" "${prepped_submodule_path}"
    fi

    # Set the local non-bare repo's url to point to the prepped mirror (so that
    # git submodule update pulls from the this local mirror instead of the real
    # URL, as we've just done a mirror clone
    if tar_feature_incremental_backup; then
      # I can't find mention of submodules using hardlinks, but it looks like
      # 'git submodule update' uses 'git clone' to update the submodule after it
      # is init'd:
      #   #. [cmd_update](https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L511)
      #   #. [update_clone](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1220)
      #   #. [update_clone_get_next_task](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1118)
      #   #. [prepare_to_clone_next_submodule](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1008)
      #   #. [module_clone](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L848)
      #   #. [clone_submodule](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L721)
      # which builds a 'git clone' command. From git clone's documentation:
      # "When the repository to clone from is on a local machine...the files
      # under .git/objects/ directory are hardlinked" by default.
      # https://git-scm.com/docs/git-clone#Documentation/git-clone.txt--l
      #
      # A Hardlink affects the change time (ctime) of a file (see stat). Thus,
      # the files in the objects directory will have their ctime updated. This
      # causes tar to include the file in its incremental archive. Unfortunately,
      # there isn't a tar flag to ignore ctime nor a --no-hardlinks flag that
      # can be passed to git submodule update

      local TEMP_DIR
      make_temp_path TEMP_DIR -d
      TEMP_DIR="${TEMP_DIR}"/"$(basename "${prepped_submodule_path}")"
      cp -a "${prepped_submodule_path}" "${TEMP_DIR}"

      "${GIT}" config "${submodule}.url" "${TEMP_DIR}"
    else
      "${GIT}" config "${submodule}.url" "${prepped_submodule_path}"
    fi
  done

  # Checkout submodule
  next_section "Updating submodules for ${prefix-${displaypath-${GIT_MIRROR_MAIN_REPO}}}"
  # The local non-bare repo doesn't need to waste time copying LFS objects
  # Could also add --recommend-shallow (introduced in git 2.10.0)
  # This flag gets translated to the --depth flag, which is ignored for local
  # clones
  # RE Whether this optimization is worth it for a local clone depends on a lot
  # of things, including the filesystem
  GIT_LFS_SKIP_SMUDGE=1 "${GIT}" submodule update
  # Restore the origin urls after update, so that relative URLs work
  "${GIT}" submodule sync

  if git_mirror_has_lfs; then
    next_section "Fetching lfs objects for ${prefix-${displaypath-${GIT_MIRROR_MAIN_REPO}}}"
    # Determine this (sub)modules' prepared path
    if [ -z "${base_submodule_path}" ]; then
      prepped_submodule_path="${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}"
    else
      prepped_submodule_path="$(dirname "$(shopt -s nullglob; \
          echo "${GIT_MIRROR_PREP_DIR}"/*/"${base_submodule_path}/config")")"
    fi

    local lfs_dir="$("${GIT}" rev-parse --git-dir)/lfs"
    # Incase it it doesn't exist
    mkdir -p "${lfs_dir}" "${prepped_submodule_path}/lfs/"

    # In the initial case, the non-bare repo will have an lfs folder, with
    # the current branch's objects in it. Move them to the prepped location
    if [ -n "$(ls -A "${lfs_dir}")" ]; then
      # combine the two
      cp -a "${lfs_dir}"/* "${prepped_submodule_path}/lfs/"
    fi

    if [[ ${OS-} = Windows_NT && -n $(ls -A "${prepped_submodule_path}/lfs") ]]; then
      cp -a "${prepped_submodule_path}"/lfs/* "${lfs_dir}/"
    else
      # Replace with symlink
      rm -rf "${lfs_dir}"
      ln -s "${prepped_submodule_path}/lfs" "${lfs_dir}"
    fi

    "${GIT}" lfs fetch --all

    if [[ ${OS-} = "Windows_NT" && -n $(ls -A "${lfs_dir}") ]]; then
      cp -a "${lfs_dir}"/* "${prepped_submodule_path}/lfs/"
    fi
  fi

  # And the recursion goes on... foreach runs in sh, so I'm forcing bash. I need
  # to pass the prefix/displaypath variables from git into the called function,
  # so export them.
  #
  # NOTE We list submodules two ways in this function: at the beginning with
  # get_config_submodule_names (which uses git config and works with init-only
  # submodules) and, here, with git submodule foreach (which does not).
  # RE With the submodule names we could get the associated submodule paths
  # (via git config) and then recurse through the submodules ourselves like
  # just_git_functions:safe_git_submodule_update (which is called recursively
  # via just_git_functions:_checkout_git_submodule) and
  # just_git_airgap_repo.bsh:git_sync_submodules_recursively.
  # This would avoid the complications involved with exporting the required
  # variables, keeping track of base_submodule_path, re-sourcing this file (and
  # the info.env in update_submodules), etc. needed because git submodule foreach
  # runs in an sh subshell
  # NOTE We could make a similar change in update_submodules
  GIT_MIRROR_PREP_DIR="${GIT_MIRROR_PREP_DIR}" base_submodule_path="${base_submodule_path}" \
      "${GIT}" submodule foreach --quiet \
      "export prefix displaypath; bash -euc 'unset GIT_DIR; source \"${GIT_MIRROR_SOURCE[0]}\"; clone_submodules'"
  # The "unset GIT_DIR" is needed because somewhere between git 2.17 and 2.21,
  # git-submodule-foreach started setting the GIT_DIR; however, the logic here
  # is constantly switching directories into different repositories &
  # submodules, which breaks if GIT_DIR is set
}

#**
# .. function:: update_submodules
#
# Init/update a submodule and any of its submodules (recursively)
#
# This is a helper function to :func:`git_clone_main`. Recursively clone a submodule mirrored with :func:`git_mirror_main`, and fixup the submodules' remote URLs according to the mapping specified by ``$1``.
#
# WARNING: ``git submodule foreach`` runs commands via sh because git is weird; however I start bash and source this script for its vars and functions, so it's really bash again.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository and its mirror URL; see :func:`_git_mirror_load_info`
#              [``base_submodule_path``] - The (relative) path from the project repository to a submodule with, potentially, submodules of its own that need to be cloned/updated. This must also be the CWD. If unset, update the submodules of the parent repository.
#              [``prefix``] - A variable set when calling ``git submodule foreach`` (and, by necessity, re-exported by this function) to the submodule path (sm_path) from the .gitmodules file. After git v1.8.3, ``prefix`` was replaced with ``displaypath``
#              [``displaypath``] - A variable set when calling ``git submodule foreach`` (and, by necessity, re-exported by this function) to the relative path from the current working directory to the submodules root directory
# :Output: The recursively cloned submodule
#
# .. note::
#
#   This function assumes ``base_submodule_path`` is also the PWD
#**

# NOTE This function could be refactored in the same manner as suggested in
# clone_submodules
# RE This would make it easier to support refactoring this into a non-recursive
# submodule sync and recursive submodule update function
function update_submodules()
{
  # Arrays aren't exported, reload
  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls

  # In the root of the project repository (the first pass through this
  # function), base_submodule_path is unset
  local base_submodule_path="${base_submodule_path-}${base_submodule_path:+/}${prefix-${displaypath-}}"
  # Remove trailing slashes because on some versions of git (1.8.3, 2.17.1)
  # prefix has a trailing slash
  base_submodule_path="${base_submodule_path%/}"
  local current_repo="$(_git_mirror_get_url "${base_submodule_path:-.}")"

  "${GIT}" submodule init

  # Sync the submodules to the mirrored repository
  sync_submodules ${base_submodule_path:+"${base_submodule_path}"}

  next_section "Updating ${current_repo}'s submodules"
  "${GIT}" submodule update

  # And the recursion goes on... foreach runs in sh, so I'm forcing bash. I need
  # to pass the prefix/displaypath variables from git into the called function,
  # so export them.
  base_submodule_path="${base_submodule_path-}" \
      "${GIT}" submodule foreach --quiet "export prefix displaypath; bash -euc \
          'unset GIT_DIR; source \"${GIT_MIRROR_SOURCE[0]}\"; update_submodules \"${1}\"'"
}

#**
# .. function:: sync_submodules
#
# Sync the submodules to the mirrored remote (non-recursive)
#
# This is a helper function to :func:`update_submodules`. Sync the submodules' remote URLs (non-recursively), a la ``git submodule sync``, however, instead of referring to the .gitmodules file, use the mapping specified by ``repo_paths`` and ``repo_urls``.
#
# :Arguments: ``$1`` - The (relative) path from the project repository to a submodule with, potentially, submodules of its own that need to be sync'ed. This must also be the CWD. If unset, sync the submodules of the parent repository.
# :Parameters: ``repo_paths`` - The array of (relative) paths from the root of the project repository to each submodule (recursively); see :func:`_git_mirror_load_info`
#              ``repo_urls`` - The corresponding URL of each repo_path
#
# .. note::
#
#   This function assumes ``$1`` is also the PWD
#**

# TODO RE the above .. note:: use just_git_airgap_repo.bsh:git_project_root_dir
# to find the project root and compute base_submodule_path from the PWD
# RE It would be good to refactor those functions into git_functions.bsh,
# otherwise the import would be circular
#
# NOTE Unlike just_git_functions:safe_git_submodule_update, we don't want to
# use a custom remote here because there would be no way to update the default
# remote, and then things like git fetch could stop working
function sync_submodules()
{
  local base_submodule_path="${1-}"

  local IFS=$'\n'
  local submodule_names=($(get_config_submodule_names))

  local submodule_name
  local sm_path
  local full_relative_path
  for submodule_name in ${submodule_names[@]+"${submodule_names[@]}"}; do
    # NOTE Assumes we are in the top-level directory
    sm_path="$("${GIT}" config -f .gitmodules ${submodule_name}.path)"
    full_relative_path="${base_submodule_path}${base_submodule_path:+/}${sm_path}"
    "${GIT}" config "${submodule_name}.url" "$(_git_mirror_get_url "${full_relative_path}")"
  done
}

#**
# .. function:: git_mirror_main
#
# Mirror the main repository and all submodules (recursively)
#
# Downloads a mirror of a git repository and all of its submodules. The normal ``git clone --mirror`` command does not support submodules at all. This at least clones all the submodules available in the specified branch (master by default).
#
# The script creates a directory, referred to as a prep directory (or prep_dir), which will contain all of the mirrored repositories plus a single ``transfer_{date}.tgz`` archive file containing all of these repositories, lfs objects, etc... Only this `tgz` file needs to be transferred to your destination.
#
# Subsequent calls to :func:`git_mirror_main` can use the existing prep directory as cache, updating faster than the first time.
#
# Subsequent calls also create a second ``tgz`` file, ``transfer_{date1}_transfer_{date2}.tgz`` (on supported platforms). This is an incremental archive file. Instead of having to bring in an entire archive, only the incremental file is needed (plus the original full archive).
#
# After you have moved the transfer archive to its destination, you can use :func:`git_push_main` to push these mirrored repositories to a new git server.
#
# :Arguments: - ``$1`` - URL of the main git repository. On subsequent calls to this function, the prep (cache) dir created by this function can be used in lue of the repository's URL
#             - [``$2``] - The git branch from which to identify the submodules. Default: master
# :Parameters: [``GIT_MIRROR_PREP_DIR``] - The output directory in which to mirror the repositories; Default: ``${PWD}/{repo_name}_prep``
# :Output: - A prep directory which will contain all of the repositories plus a single ``transfer_{date}.tgz``
#          - ``GIT_MIRROR_PREP_DIR`` - The path to the mirrored repositories
#          - ``GIT_MIRROR_MAIN_REPO`` - The main repository's name. Based off of ``$1``; e.g., vsi_common if the URL is https://github.com/VisionSystemsInc/vsi_common.git
#
# .. rubric:: Example
#
# Mirror the vsi_common repository and all of its submodules in a directory called ./vsi_common_prep. Then, create an archive file that can be transferred to your destination.
#
# .. code-block:: bash
#
#    git_mirror_main https://github.com/visionsystemsinc/vsi_common.git master
#    # produces ./vsi_common_prep/transfer_2020_03_02_14_16_09.tgz
#
# .. rubric:: Example
#
# Calling ``git_mirror`` again will use the vsi_common_prep dir as a cache, and then create an incremental file.
#
# .. code-block:: bash
#
#    git_mirror_main vsi_common_prep
#    # produces ./vsi_common_prep/transfer_2020_03_02_14_24_12_transfer_2020_03_02_14_16_09.tgz
#
# .. rubric:: Example
#
# Both of these examples result in identical mirrors on your destination:
#
# .. code-block:: bash
#
#    tar zxf transfer_2020_03_02_14_16_09.tgz
#    tar --incremental zxf transfer_2020_03_02_14_24_12_transfer_2020_03_02_14_16_09.tgz
#
# .. code-block:: bash
#
#    tar zxf transfer_2020_03_02_14_24_12.tgz
#
# .. note::
#
#   ``git_mirror_main`` does not mirror all submodules that have ever been part of the repo, only those from a specific branch/SHA/tag you specify (master by default). This is because trying to mirror all submodules from the past could be very lengthy, and is very likely to include URLs that do not exist anymore.
#
# .. rubric:: Bugs
#
# If the first argument is a local path to a git repository (as opposed to a URL or a path to an existing prep dir), it must be an absolute path.
#**

function git_mirror_main()
{
  git_mirror_repos ${@+"${@}"}
  archive_mirrors "${GIT_MIRROR_PREP_DIR}"
}

#**
# .. function:: git_mirror_repos
#
# Mirror the main repository and all submodules (recursively)
#
# Downloads a mirror of a git repository and all of its submodules. The normal ``git clone --mirror`` command does not support submodules at all. This at least clones all the submodules available in the specified branch (master by default).
#
# Creates a directory, referred to as a prep directory (or prep_dir), which will contain all of the mirrored repositories. Subsequent calls to :func:`git_mirror_repos` can use the existing prep directory as cache, updating faster than the first time.
#
# :Arguments: - ``$1`` - URL of the main git repository. On subsequent calls to this function, the prep (cache) directory created by this function can be used in lue of the repository's URL
#             - [``$2``] - The git branch from which to identify the submodules. Default: master
# :Parameters: [``GIT_MIRROR_PREP_DIR``] - The output directory in which to mirror the repositories; Default: ``${PWD}/{repo_name}_prep``
# :Output: - A prep directory which will contain all of the repositories
#          - ``GIT_MIRROR_PREP_DIR`` - The path to the mirrored repositories
#          - ``GIT_MIRROR_MAIN_REPO`` - The main repository's name. Based off of ``$1``; e.g., vsi_common if the URL is https://github.com/VisionSystemsInc/vsi_common.git
#
# .. note::
#
#   :func:`git_mirror_repos` does not mirror all submodules that have ever been part of the repo, only those from a specific branch/SHA/tag you specify (master by default). This is because trying to mirror all submodules from the past could be very lengthy, and is very likely to include URLs that do not exist anymore.
#
# .. rubric:: Bugs
#
# If the first argument is a local path to a git repository (as opposed to a URL or a path to an existing prep dir), it must be an absolute path.
#
# .. seealso::
#
#   :func:`git_mirror_main`
#**

function git_mirror_repos()
{
  if [ "${#}" -eq "0" ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_URL [BRANCH|SHA]" >&2
    echo "${BASH_SOURCE[0]} EXISTING_PREP_DIR [BRANCH|SHA]" >&2
    exit 1
  fi

  # Does the directory look like a PREP_DIR
  if [ -f "${1}/"*"/config" ]; then
    # Don't need nullglob here because the directory exists
    pushd "$(dirname "${1}/"*"/config")" &> /dev/null
      GIT_MIRROR_PREP_DIR="${GIT_MIRROR_PREP_DIR:-"$(dirname "${PWD}")"}"
      GIT_MIRROR_MAIN_REPO="$("${GIT}" config --get remote.origin.url)"
    popd &> /dev/null
  else
    GIT_MIRROR_MAIN_REPO="${1}"
  fi
  local BRANCH="${2-master}"

  local MAIN_DIR="$(basename "${GIT_MIRROR_MAIN_REPO}")"
  MAIN_DIR="${MAIN_DIR%.*}"
  if [ -z "${GIT_MIRROR_PREP_DIR:+x}" ]; then
    GIT_MIRROR_PREP_DIR="${PWD}/${MAIN_DIR}_prep"
  fi

  # Make absolute path
  if [ "${GIT_MIRROR_PREP_DIR:0:1}" != "/" ]; then
    GIT_MIRROR_PREP_DIR="${PWD}/${GIT_MIRROR_PREP_DIR}"
  fi

  # 1. mirror clone (prep_dir)
  # 2. clone repo from /prep to /tmp/clone
  #    (in clone_submodules)
  # 3. git submodule init in /tmp/clone
  # 4. get_config_submodule_names - list submodules in /tmp/clone
  # 5. mirror each submodule into prep_dir
  # 6. change remote of each submodule in /tmp/clone to point to the prep'd mirror
  # 7. git submodule update in /tmp/clone
  # 8. repeat 3-7 for sub submodules
  # 9. profit

  #########################
  # Get the super project #
  #########################
  mkdir -p "${GIT_MIRROR_PREP_DIR}"
  if [ ! -e "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" ]; then
    next_section "Cloning super project ${GIT_MIRROR_MAIN_REPO}..."
    "${GIT}" clone --mirror "${GIT_MIRROR_MAIN_REPO}" "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}"
  else
    next_section "Fetching for super project ${GIT_MIRROR_MAIN_REPO} using last run..."
    pushd "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" &> /dev/null
      # Re-establish url in case it changed
      "${GIT}" remote set-url origin "${GIT_MIRROR_MAIN_REPO}"
      if meet_requirements "${GIT_VERSION}" ">=2.17"; then
        "${GIT}" fetch -pP origin
      else
        "${GIT}" fetch -p origin
      fi
    popd &> /dev/null
  fi

  next_section "Re-cloning locally"
  local TEMP_DIR
  make_temp_path TEMP_DIR -d
  # The local non-bare repo doesn't need to waste time copying LFS objects
  # Could also add --depth 1 --branch "${BRANCH}" --no-recursive
  # RE --depth is ignored for local clones...could add
  # --single-branch --branch "${BRNACH}" --no-recursive
  # RE Whether this optimization is worth it for a local clone depends on a lot
  # of things, including the filesystem
  if tar_feature_incremental_backup; then
    # Clone without hardlinks because they mess up the incremental archive
    # (see clone_submodules)
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" clone --no-hardlinks "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" "${TEMP_DIR}"
  else
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" clone "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" "${TEMP_DIR}"
  fi

  pushd "${TEMP_DIR}" &> /dev/null
    # The local non-bare repo doesn't need to waste time copying LFS objects
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" checkout "${BRANCH}"

    # Restore origin to not point to mirror, so relative submodules work right
    "${GIT}" remote set-url origin "${GIT_MIRROR_MAIN_REPO}"

    # This effectively does git submodule update --recursive --init,
    # but plumbs the submodules to use the "${GIT_MIRROR_PREP_DIR}" instead
    clone_submodules
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: archive_mirrors
#
# Create an in-place archive of a directory
#
# Create a ``transfer_{date}.tgz`` archive file of a directory. This archive is created within the same directory.
#
# Subsequent calls also create a second ``tgz`` file, ``transfer_{date1}_transfer_{date2}.tgz`` (on supported platforms). This is an incremental archive file. Only the incremental file is needed (plus the original full archive).
#
# :Arguments: - ``$1`` - A directory to archive in-place
# :Output: A ``transfer_{date}.tgz`` archive file and, on subsequent calls, an incremental ``transfer_{date1}_transfer_{date2}.tgz``
#**

function archive_mirrors()
{
  local prep_dir="${1}"

  pushd "${prep_dir}" &> /dev/null
    next_section "Creating tar file..."
    local tar_file="transfer_$(date '+%Y_%m_%d_%H_%M_%S')"

    # BSD tar does not handle excluded files well: for some reason, if given
    # a pattern to exclude, any file that matches that pattern in its directory
    # tree is excluded. Even if a specific file is being excluded, if the file
    # is in a toplevel directory being archived, and the path is relative
    # (e.g., ./), any file with that name in its directory tree is excluded.
    # For example, --exclude ./archive.tgz would exclude not only a file
    # in the PWD called archive.tgz, but any file in a subdirectory called
    # archive.tgz.
    # As as workaround, using absolute paths everywhere works on BSD, but then
    # the path components must be stripped off before being archived.
    #
    # Unfortunately, BSD < 3 and GNU < 1.31 (at least) only support the
    # --strip-components flag on extraction. Fortunately, GNU tar, does work as
    # expected when excluding specific files with relative paths in the toplevel
    # directory being archived. Therefore, with GNU tar, using relative paths
    # everywhere works
    local tar_version
    local tar_vendor
    tar_version_info # Sets tar_version and tar_vendor
    local args=()
    local CWD
    if [ "${tar_vendor}" == "BSD" ] && meet_requirements "${tar_version}" ">=3"; then
      CWD="${PWD}"
      # Because the archive is created with absolute paths, count how many path
      # components to strip off when creating the tar; equal to the number of
      # slashes in the current path
      local x="$(tr -d -c '/' <<< "${CWD}/")"
      local ncomponents="${#x}"
      args+=("--strip-components" "${ncomponents}")
      # Prevent bsdtar (on macOS) from including extended attributes (stored in
      # ._* files); https://unix.stackexchange.com/q/282055/#282142
      #if [ "${VSI_OS}" = "darwin" ]; then
      #  args+=("--disable-copyfile")
      #fi
    else # GNU or BUSYBOX or BSD < 3
      # This will work properly on GNU tar, but on older versions of BSD tar,
      # like 2.8.3, this will suffer the problem of excluded file collisions
      # mentioned above. Similarly, this cannot be ''
      # This is ok here because our archives are datetime stamped so a collision
      # is very unlikely
      CWD='.'
    fi

    # Determine what tar files currently exist in the prep_dir
    local OLD_IFS="${IFS}"
    IFS=$'\n'
    local existing_tar_files=($(ls "${CWD}"/{*.tgz,*.snar} 2>/dev/null || :))
    IFS="${OLD_IFS}"
    args+=("--exclude" "${CWD}/${tar_file}.tgz")
    if tar_feature_incremental_backup; then
      args+=("--exclude" "${CWD}/${tar_file}.snar")
    fi
    local existing_tar_file
    for existing_tar_file in ${existing_tar_files[@]+"${existing_tar_files[@]}"}; do
      args+=("--exclude" "${existing_tar_file}")
    done

    # Create a full archive (and associated .snar file if possible)
    local last_tar_file
    # https://stackoverflow.com/a/37993307
    touch "${tar_file}.tgz"
    if tar_feature_incremental_backup; then
      # Get the last one, alphabetically speaking (.l1.snar comes before .snar)
      # per sort's man page:
      # The locale specified by the environment affects sort order. Set LC_ALL=C
      # to get the traditional sort order that uses native byte values.
      # We need it in this order so that base directories come before subdirectories.
      last_tar_file="$(LC_ALL=C ls "${prep_dir}"/transfer_*.snar 2>/dev/null | tail -n1)"
      last_tar_file="$(basename "${last_tar_file%.snar}")"
      ${TAR} czf "${tar_file}.tgz" -g "${tar_file}.snar" "${args[@]}" "${CWD}"
    else
      ${TAR} czf "${tar_file}.tgz" "${args[@]}" "${CWD}"
    fi

    if tar_feature_incremental_backup && [ "${last_tar_file}" != "" ]; then
      next_section "Creating an incremental tar file too, based on ${last_tar_file}"
      args+=("--exclude" "${CWD}/${tar_file}_${last_tar_file}.tgz" \
             "--exclude" "${CWD}/${last_tar_file}.l1.snar")
      # archive.snar-1 is more canonical than l1.snar [1]
      cp "${last_tar_file}.snar" "${last_tar_file}.l1.snar"
      # This snar file isn't actually used for anything because the next
      # incremental backup is created from the previous full backup
      #
      # NOTE tar uses timestamps to decide if a file has changed (this includes
      # the access, modify and change times)
      # [1] https://www.gnu.org/software/tar/manual/html_node/Incremental-Dumps.html
      # https://stackoverflow.com/a/37993307
      touch "${CWD}/${tar_file}_${last_tar_file}.tgz"
      ${TAR} czf "${tar_file}_${last_tar_file}.tgz" -g "${last_tar_file}.l1.snar" "${args[@]}" "${CWD}"
      next_section "Your new tar file is ready:"
      echo "${prep_dir}/${tar_file}.tgz"
      echo "and you have an incremental file:"
      echo "${tar_file}_${last_tar_file}.tgz"
    else
      next_section "Your new tar file is ready:"
      echo "${prep_dir}/${tar_file}.tgz"
    fi
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: _git_mirror_load_info
#
# Load the mapping between each repository and its mirror URL
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository and its mirror URL
# :Output: ``repo_paths`` - The array of (relative) paths from the root of the project repository to each submodule (recursively). (That is, a path as printed by ``echo . && git submodule foreach -q 'echo "${displaypath}"'`` assuming the CWD is the root of the project repository)
#          ``repo_urls`` - The corresponding URL of each repo_path
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#    $ cat info.env
#    repo_paths=(
#      .
#      docker/recipes
#    )
#    repo_urls=(
#      https://git-server.com/foobar/vsi_common.git
#      https://git-server.com/foobar/recipes.git
#    )
#
# Or alternatively, using associative arrays:
#
# .. code-block:: bash
#
#    repos[.]=https://git-server.com/foobar/vsi_common.git
#    repos[docker/recipes]=https://git-server.com/foobar/recipes.git
#**

function _git_mirror_load_info()
{
  if [ "${bash_feature_associative_array}" = "0" ]; then
    local -A repos
    repo_paths=()
    repo_urls=()
  fi
  source "${1}"
  if [ "${bash_feature_associative_array}" = "0" ]; then
    local key
    repo_paths=(${repo_paths[@]+"${repo_paths[@]}"} "${!repos[@]}")
    for key in "${!repos[@]}"; do
      repo_urls=(${repo_urls[@]+"${repo_urls[@]}"} "${repos[${key}]}")
    done
  fi
}

#**
# .. function:: _git_mirror_get_url
#
# Return the URL for a given submodule
#
# :Arguments: ``$1`` - A path that can be found in ``repo_paths``
# :Parameters: ``repo_paths`` - The array of (relative) paths from the root of the project repository to each submodule (recursively); see :func:`_git_mirror_load_info`
#              ``repo_urls`` - The corresponding URL of each repo_path
# :Output: The URL corresponding to ``$1``
#**

function _git_mirror_get_url()
{
  local index="$(findin "${1}" "${repo_paths[@]}")"
  if [ "${index}" -ge 0 ]; then
    echo "${repo_urls[index]}"
    return 0
  else
    echo "Error: no entry found for: ${1}" >&2
    return 1
  fi
}

#**
# .. function:: git_clone_main
#
# Clone recursively from the new mirror
#
# Once the repository has been mirrored to the new git server with :func:`git_push_main`, it can be cloned. However, because the .gitmodules file will point to different URLs than the mirrors, and changing the .gitmodules file will change the repo, which we don't want to do, we need to make a shallow clone of the repository, init the submodules, modify the submodules' URLs, and then finally update the submodules. And all of this has to be done recursively for each submodule. As you can tell, this is very tedious, so this script will do it all for you.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository and its mirror URL; see :func:`_git_mirror_load_info`
#             [``$2``] - The directory in which to clone the repo
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#    git_clone_main init.env ~/
#**

function git_clone_main()
{
  if [ "${#}" -eq "0" ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_MAP_FILE [DIR]" >&2
    exit 1
  fi

  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls
  mkdir -p "${2-.}"
  pushd "${2-.}" &> /dev/null
    if [ ! -d "./.git" ]; then
      "${GIT}" clone "$(_git_mirror_get_url .)" .
    fi
    update_submodules "${1}"
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: git_push_main
#
# Push the mirrored repository and all submodules to a new git server
#
# After transferring the archive file created by :func:`git_mirror_main` to a prep directory on your destination and extracting the archive into it, this function pushes all the mirrored repositories in the extracted archive to your own mirrors on a new git server.
#
# .. note::
#
#   The mirrors must be initialized on the git server.
#
# However, because the URLs for your mirrors will be different from the original repo URLs in .gitmodules, and modifying the URLs will change the git repo, which we do not want to do, you must create a file specifying the mapping between each repository and its mirror URL. The main repo is referred to as ``.`` while the rest of the repos are referred to by the relative path with respect to the main repo (e.g. ``external/vsi_common``). These need to be stored in an associative array called ``repos``.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository and its mirror URL; see :func:`_git_mirror_load_info`
#             ``$2`` - The mirrored repositories (extracted from the archive) created by :func:`git_mirror_main`
# :Parameters: [``GIT_MIRROR_FORCE_PUSH_REFS``] - A flag specifying whether to force push refs, should it be necessary. Default: 1 (force-push refs)
#
# .. rubric:: Example
#
# In this example, the main repo's mirror URL is ``https://git-server.com/foobar/vsi_common.git``, and the submodule stored at ``./docker/recipes`` has the URL ``https://git-server.com/foobar/recipes.git``. This file is also used by :func:`git_clone_main`. (Any valid git URL format can be used.)
#
# .. code-block:: bash
#
#    $ cat info.env
#    repos[.]=https://git-server.com/foobar/vsi_common.git
#    repos[docker/recipes]=https://git-server.com/foobar/recipes.git
#
#    $ git_push_main info.env vsi_common_prep
#**

function git_push_main()
{
  if [ "${#}" -eq "0" ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_MAP_FILE PREP_DIR" >&2
    exit 1
  fi

  # By default, force push all refs
  local GIT_MIRROR_FORCE_PUSH_REFS="${GIT_MIRROR_FORCE_PUSH_REFS-1}"

  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls

  pushd "${2}" &> /dev/null
    local index
    # Loop through the repos
    for index in ${repo_paths[@]+"${!repo_paths[@]}"}; do
      local repo_url="${repo_urls[index]}"
      local repo_path="$(shopt -s nullglob; dirname */"${repo_paths[index]}/config")"
      next_section "Pushing repo '${repo_path}' to '${repo_url}'"
      if [ -d "${repo_path}" ]; then
        pushd "${repo_path}" &> /dev/null
          # Push to the mirror (git push --mirror does a force push, however, it
          # will remove deleted refs)
          #
          # It seems mirrored repositories (vxl, pytorch) can include
          # refs/remotes.
          # These refs are unusual---this is the pattern for the ref of a remote
          # branch in a clone. Setting up a remote-tracking branch, specifying
          # the remote & branch name manually during a git push or creating a
          # push refspec basically all do the same thing: they map local refs
          # (refs/heads) to remote refs (refs/remotes). Therefore, the mirror
          # should not have any remote refs. In any case, these cause an error,
          # "deny updating a hidden ref:", when pushing to a gitlab server. For
          # now, only filter out refs/remotes
          # RE It is possible to get refs/remotes if a bare repo fetches from
          # another (bare) repo, which could then be pushed to, e.g., github

          # I could fetch refs from the remote so I can determine when a (fast-
          # forward) push was not possible; and if a force push was done, what
          # the original ref was. This is more straightforward than using
          # ls-remote.
          # RE This would introduce refs/remotes to the bare repo, which, as
          # noted above, is unusual
          # RE Also, tags are created locally (in refs/tags)
          # RE RE It is possible to fetch refs into a namespace
          #   git fetch --no-tags origin \
          #           '+refs/*:refs/remotes/origin/just_git_mirror/*'
          # will fetch the refs to the namespace, just_git_mirror, in git 1.8.3,
          # and
          #   git fetch --no-tags --refmap='' origin \
          #           '+refs/*:refs/remotes/origin/just_git_mirror/*'
          # will do the same in later versions (probably git 2.1.0; def before
          # 2.17.1). However, git ~1.9 does not support the --refmap flag and
          # seems to not have a way to ignore configured refspecs, which will
          # cause origin:refs/heads to be created in refs/remotes as well
          # (hence the need for --refmap='')
          # https://stackoverflow.com/a/25098004
          # RE Doing this would also modify the transfer dir (although in a
          # predictable way)
          #
          # Alternatively, the SHA returned by ls-remote is the original ref.
          # I could then use git tag --points-at SHA to find the tag that
          # git_tag_main added (if the tags are local, as they are now)
          # RE In case we are working from a new copy of the transfer dir, we
          # should probably use git ls-remote to pull the git_mirror tags like
          # git_tag_main

          # Spaces are not allowed in a refname
          local refs=($("${GIT}" for-each-ref --format='%(refname)' | \
              grep -v -e '^refs/remotes' -e '^refs/stash' || :))
          # xargs tries all args before returning an error code, as desired.
          # It only short-circuits if the command exits with a value 255, which
          # fortunately is not the case if pushing a branch fails. Per xarg's
          # man page:
          # "The xargs utility exits immediately (without processing any
          # further input) if ... an invocation of utility exits with a value
          # of 255".
          #
          # If refs is empty, the echo succeeds but there is nothing to pass
          # through the pipe, so the command short-circuits
          if ! echo ${refs[@]+"${refs[@]}"} | xargs "${GIT}" push "${repo_url}"; then
            # Force push those refs that failed
            for ref in "${refs[@]}"; do
              # If the push was successful, then there is no need to force push
              # (If the ref is not found, git ls-remote returns the empty string)
              if [ "$("${GIT}" ls-remote "${repo_url}" "${ref}" | awk '{print $1}')" != \
                   "$("${GIT}" show-ref --hash "${ref}")" ]; then
                if [ "${GIT_MIRROR_FORCE_PUSH_REFS}" = "1" ]; then
                  # NOTE A tag from git_tag_main's should never have to be
                  # force pushed
                  "${GIT}" push --force "${repo_url}" "${ref}"
                  echo "WARNING Fast-forward merge not possible. Force pushed ${ref} to"
                  echo "    ${repo_url}"
                  # TODO Create a tag at the forced ref pointing to the
                  # original ref that could be used by a git hook to warn the
                  # developer that a force push occurred
                else
                  echo "WARNING Fast-forward merge not possible. ${ref} was not force pushed to"
                  echo "    ${repo_url}"
                  echo "because force pushing is disabled (GIT_MIRROR_FORCE_PUSH_REFS=${GIT_MIRROR_FORCE_PUSH_REFS})"
                fi
              fi
            done
          fi

          if git_mirror_has_lfs; then
            next_section "Pushing lfs objects for ${repo_path}"
            "${GIT}" remote add mirror "${repo_url}" 2>/dev/null || \
                "${GIT}" remote set-url mirror "${repo_url}"
            # Does not work on file systems, only with real lfs servers, unless you set up lfs-filestore
            "${GIT}" lfs push mirror --all || :
          fi
        popd &> /dev/null
      else
        echo "No dir found for submodule ${repo_path}"
      fi
    done
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: git_tag_main
#
# Tag the refs in the mirrored repository and all submodules
#
# Before pushing the mirrored repository and all of its submodules to the new git server with :func:`git_push_main`, tag the refs so that if, during the **next** transfer, they become dereferenced (due to a force push, which is sometimes necessary), they are not lost. For a ref of the form refs/heads/master, this (annotated) tag takes the (long) form of refs/tags/just_git_mirror/{datetime}/heads/master
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository and its mirror URL; see :func:`_git_mirror_load_info`
#             ``$2`` - The mirrored repositories (extracted from the archive) created by :func:`git_mirror_main`
# :Parameters: [``GIT_MIRROR_TAG_REFS_REGEX``] - An extended regular expression specifying which refs to tag. The refs should be matched in their long form, e.g., refs/heads/master or refs/tags/v1.0.0. Default: ^refs/heads/.+
#
# .. seealso::
#
#   :func:`git_push_main`
#
# .. note::
#
#   Because this function creates a tag directory called just_git_mirror/ (note the trailing slash), a user can no longer create a tag called just_git_mirror
#**

function git_tag_main()
{
  if [ "${#}" -eq "0" ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_MAP_FILE PREP_DIR" >&2
    exit 1
  fi

  # By default, only tag refs/heads/*
  local GIT_MIRROR_TAG_REFS_REGEX="${GIT_MIRROR_TAG_REFS_REGEX-^refs/heads/.+}"

  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls

  pushd "${2}" &> /dev/null
    local tag_date="$(date -u '+%Y-%m-%dT%H.%M.%SZ')" # ISO8061; ':' isn't valid

    local index
    # Loop through the repos
    for index in ${repo_paths[@]+"${!repo_paths[@]}"}; do
      local repo_url="${repo_urls[index]}"
      local repo_path="$(shopt -s nullglob; dirname */"${repo_paths[index]}/config")"
      next_section "Tagging refs in '${repo_path}'"
      if [ -d "${repo_path}" ]; then
        pushd "${repo_path}" &> /dev/null
          # refs take their long form to maintain namespacing of the tag;
          # otherwise, refs/heads/4 and refs/pull/4 would both be tagged
          # identically
          #
          # Spaces are not allowed in a refname
          local refs=($("${GIT}" for-each-ref --format='%(refname)' | \
              grep -E "${GIT_MIRROR_TAG_REFS_REGEX}" | \
              grep -v -e '^refs/tags/just_git_mirror/' -e '^refs/remotes' -e '^refs/stash' || :))
          for ref in ${refs+"${refs[@]}"}; do
            # Don't re-tag a ref if we have already tagged it at this SHA.
            # Unfortunately, it doesn't look like there is something like
            # git tag --points-at for ls-remote. Instead, return all of our
            # tags that match our ref and grep for the correct SHA
            #
            # git has two kinds of tags: lightweight and annotated [1].
            # Lightweight tags are like branches that do not move. Annotated
            # tags are commits of their own. We are creating lightweight tags
            #
            # [1] https://git-scm.com/book/en/v2/Git-Basics-Tagging

            # A ref is tagged with just_git_mirror/{date}/{namespaced_ref},
            # where namespaced_ref is the long-form ref (e.g., refs/heads/master)
            # with the refs/ domain stripped off
            local namespaced_ref="${ref/refs\//}"
            local SHA="$("${GIT}" show-ref --hash "${ref}")"
            if ! "${GIT}" ls-remote "${repo_url}" "refs/tags/just_git_mirror/*/${namespaced_ref}" | \
                awk '{print $1}' | grep "^${SHA}$"; then
              local tag="just_git_mirror/${tag_date}/${namespaced_ref}"
              # NOTE It is possible to create a lightweight tag directly on the
              # remote so as not to modify the transfer dir with:
              # git push origin "${ref}":refs/tags/"${tag}"
              "${GIT}" tag "${tag}" "${ref}"
            fi
          done
        popd &> /dev/null
      else
        echo "No dir found for submodule ${repo_path}"
      fi
    done
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

function usage()
{
  echo "Usage: ${BASH_SOURCE[0]} mirror|push|clone [OPTIONS]" >&2
  echo >&2
  echo "  mirror REPO_URL [BRANCH|SHA]" >&2
  echo "                               1) Mirror the git repository and all of its" >&2
  echo "                                  submodules (on BRANCH) to an archive." >&2
  echo "  mirror PREP_DIR [BRANCH|SHA]    Subsequent mirrors can be based of the" >&2
  echo "                                  existing PREP_DIR" >&2
  echo "  push REPO_MAP_FILE PREP_DIR  2) Push the unarchived mirrors to a new git" >&2
  echo "                                  server (with initialized repos) as defined" >&2
  echo "                                  by the REPO_MAP_FILE"
  echo "  clone REPO_MAP_FILE [DIR]    3) Clone recursively from the new mirror" >&2
  echo >&2
  echo "Example REPO_MAP_FILE:" >&2
  echo "  repos[.]='https://git-server.com/foo/superproject.git'">&2
  echo "  repos[external/submodule1]='https://git-server.com/foo/submodule1.git'">&2
  echo "  repos[external/submodule1/submodule2]='https://git-server.com/foo/subsubmodule2.git'">&2
}

if [ "${BASH_SOURCE[0]}" = "${0}" ] || [ "$(basename "${BASH_SOURCE[0]}")" = "${0}" ]; then
  set -eu

  arg="${1-}"
  case "${arg}" in
    mirror)
      shift 1
      git_mirror_main ${@+"${@}"}
      ;;
    push)
      shift 1
      git_push_main ${@+"${@}"}
      ;;
    clone)
      shift 1
      git_clone_main ${@+"${@}"}
      ;;
    *)
      usage
      exit 1
      ;;
  esac
fi
