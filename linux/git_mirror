#!/usr/bin/env bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
fi

source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
source "${VSI_COMMON_DIR}/linux/compat.bsh"
source "${VSI_COMMON_DIR}/linux/aliases.bsh"
source "${VSI_COMMON_DIR}/linux/findin"
source "${VSI_COMMON_DIR}/linux/requirements.bsh"

#*# linux/git_mirror

GIT_MIRROR_SOURCE="$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)"/"$(basename "${BASH_SOURCE[0]}")"

#**
# .. default-domain:: bash
#
# =========================================
# Git Mirror
# =========================================
#
# .. file:: git_mirror
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. The subcommands mirror, push and clone in this file, and associated functions, help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Example usage:
#
# #. ``git_mirror mirror https://github.com/visionsystemsinc/vsi_common.git master`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# #. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination
# #. On the destination, create a directory, e.g., vsi_common_prep, and move the archive into it
# #. Extract the archive (the archive will extract directly into this directory)
# #. Write an ``info.env`` file:
#
# .. code-block:: bash
#
#     repos[.]=https://git-server.com/foobar/vsi_common.git
#     repos[docker/recipes]=https://git-server.com/foobar/recipes.git
#
# 6. ``git_mirror push ./info.env ./transfer_extracted_dir/`` - Push the mirrored repository and all submodules to a new git server as defined by info.env
# #. ``git_mirror clone ./info.env ./my_project_dir/`` - Clone recursively from the new mirror
#**

#**
# .. function:: next_section
#
# Change the color of the text output to sdtout/stderr
#
# :Arguments: [``${@}``] - An optional string (or list of strings) to harold the next section
# :Output: A temporary file is created which stores the index into the COLORS array
#
# Change the current text color. A temporary file is created to track the current index into the COLORS array; this index is updated with each call to this function. This temporary file will automatically be deleted
#
# TODO: Move to colors.bsh
# TODO: Switch to colors.bsh:get_color
# REVIEW Set a trap that resets the color on ERR or RETURN
#**

function next_section()
{
  if [ -z "${COLOR_FILE+set}" ]; then
    make_temp_path COLOR_FILE
    export COLOR_FILE
  fi
  local COLORS=($'\e[32m' $'\e[33m' $'\e[34m' $'\e[35m' $'\e[36m' $'\e[0m')
  local -i COLOR_INDEX="$(cat "${COLOR_FILE}" || echo 0)"
  COLOR_INDEX+=1
  if [ "${COLOR_INDEX}" -ge ${#COLORS[@]} ]; then
    COLOR_INDEX=0
  fi
  echo "${COLOR_INDEX}" > "${COLOR_FILE}"
  echo "${COLORS[$COLOR_INDEX]}"${@+"${@}"}
}

GIT_VERSION="$(git_version)"

#**
# .. function:: get_config_submodule_names
#
# Get list of initialized submodules, non-recursive
#
# :Output: A newline separated list of submodules for the current git repository
#
# Get a list of submodules of the current git repository. This command is non-recursive, i.e., submodules of submodule, etc. are not returned. An implementation of this feature is provided for older versions of git (<2.6)
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   get_config_submodule_names() # from within ./vsi_common/
#   # submodule.docker/recipes
#
# .. note::
#
#   Unlike ``git submodule foreach --quiet 'echo "${name}"'``, this function works for submodules that have been init'd but not updated
#
# .. seealso::
#
#   :func:`just_git_functions.bsh submodule-helper-list` and :func:`just_git_airgap_repo.bsh get_submodule_names`
#**

if meet_requirements "${GIT_VERSION}" ">=2.6"; then
  function get_config_submodule_names()
  {
    "${GIT}" config --name-only --get-regexp '^submodule\..*\.url$' | sed 's|.url$||'
  }
else
  function get_config_submodule_names()
  {
    local names=()
    local line
    # Get null terminated lines
    while IFS= read -r -d '' record; do
      # Get first newline terminated line of that record, it's the name
      IFS= read -r -d $'\n' record <<< "${record}"
      names+=("${record}")
    done < <("${GIT}" config -z --get-regexp '^submodule\..*\.url$')

    for line in ${names[@]+"${names[@]}"}; do
      echo "${line%.url}"
    done
  }
fi

#**
# .. function:: git_mirror_has_lfs
#
# Is git lfs available for the specified implementation of git
#
# :Output: ``0`` - git lfs is available
#          ``1`` - git lfs is not available
#
# :Internal Use: ``__git_mirror_has_lfs`` - A variable to save this state
#**

function git_mirror_has_lfs()
{
  if [ -z "${__git_mirror_has_lfs:+set}" ]; then
    if ! "${GIT}" lfs &> /dev/null; then
      __git_mirror_has_lfs=1 # Does not have lfs
    else
      __git_mirror_has_lfs=0 # Does have lfs
    fi
  fi
  return "${__git_mirror_has_lfs}"
}

#**
# .. function:: clone_submodules
#
# Mirror a submodule and all of its submodules (recursively)
#
# This is a helper function to :func:`git_mirror_main`. Create a mirror of each submodule in a git repository, recursively. Each mirror is stored according to its full relative path in the project repository in a unique temporary directory created in the GIT_MIRROR_PREP_DIR. Submodules of a submodule are processed recursively in a depth-first fashion.
#
# WARNING: ``git submodule foreach`` runs commands via sh because git is weird; however I start bash and source this script for its vars and functions, so it's really bash again.
#
# :Arguments: ``GIT_MIRROR_PREP_DIR`` - The directory in which to mirror the repositories
#             [``base_submodule_path``] - The (relative) path from the project repository to the submodule (i.e., ``git submodule foreach '$displaypath'`` assuming the CWD is the root of the project repository)
#
# :Output: A mirrored submodule located at ``GIT_MIRROR_PREP_DIR/{temp_dir}/base_submodule_path``
#**

function clone_submodules()
{
  # Init (any) submodules non-recursively
  "${GIT}" submodule init

  # Submodule names can't contain newlines
  local IFS=$'\n'
  # This does not work for init-only modules
  #   submodule_names=($("${GIT}" submodule foreach --quiet 'echo "${name}"'))
  # This does
  local submodule_names=($(get_config_submodule_names))

  local prepped_submodule_path
  local full_relative_path
  local submodule

  # I am currently in base_submodule_path of the local non-bare repo
  local base_submodule_path="${base_submodule_path-}${base_submodule_path:+/}${prefix-${displaypath-}}"
  # Remove trailing slashes because on some versions of git (1.8.3, 2.17.1)
  # prefix has a trailing slash
  base_submodule_path="${base_submodule_path%/}"

  # Update submodule urls to use GIT_MIRROR_PREP_DIR
  for submodule in ${submodule_names[@]+"${submodule_names[@]}"}; do
    # Calculate full submodule path wrt superproject (not just parent submodule)
    local sm_path="$("${GIT}" config -f .gitmodules ${submodule}.path)"
    full_relative_path="${base_submodule_path}${base_submodule_path:+/}${sm_path}"

    # Get the url of the submodule set by init above
    submodule_url="$("${GIT}" config "${submodule}.url")"

    # Search for existing prepped mirror
    # https://stackoverflow.com/a/52657447/4166604
    prepped_submodule_path="$(shopt -s nullglob; echo "${GIT_MIRROR_PREP_DIR}"/*/"${full_relative_path}/config")"
    # If I already have this submodule, use it
    if [ -f "${prepped_submodule_path}" ]; then
      prepped_submodule_path="$(dirname "${prepped_submodule_path}")"
      # cd into the prepped mirror
      pushd "${prepped_submodule_path}" &> /dev/null
        # Re-establish url in case it changed
        "${GIT}" remote set-url origin "${submodule_url}"
        # Fetch the latest changes
        if meet_requirements "${GIT_VERSION}" ">=2.17"; then
          "${GIT}" fetch -pP origin
        else
          "${GIT}" fetch -p origin
        fi
      popd &> /dev/null
    else
      prepped_submodule_path="$(mktemp_compat "${GIT_MIRROR_PREP_DIR}")/${full_relative_path}"
      next_section "Cloning a fresh copy of ${full_relative_path}"
      "${GIT}" clone --mirror "${submodule_url}" "${prepped_submodule_path}"
    fi

    # Set the local non-bare repo's url to point to the prepped mirror (so that
    # git submodule update pulls from the this local mirror instead of the real
    # URL, as we've just done a mirror clone
    if tar_feature_incremental_backup; then
      # I can't find mention of submodules using hardlinks, but it looks like
      # 'git submodule update' uses 'git clone' to update the submodule after it
      # is init'd:
      #   #. [cmd_update](https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L511)
      #   #. [update_clone](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1220)
      #   #. [update_clone_get_next_task](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1118)
      #   #. [prepare_to_clone_next_submodule](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L1008)
      #   #. [module_clone](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L848)
      #   #. [clone_submodule](https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L721)
      # which builds a 'git clone' command. From git clone's documentation:
      # "When the repository to clone from is on a local machine...the files
      # under .git/objects/ directory are hardlinked" by default.
      # https://git-scm.com/docs/git-clone#Documentation/git-clone.txt--l
      #
      # A Hardlink affects the change time (ctime) of a file (see stat). Thus,
      # the files in the objects directory will have their ctime updated. This
      # causes tar to include the file in its incremental archive. Unfortunately,
      # there isn't a tar flag to ignore ctime nor a --no-hardlinks flag that
      # can be passed to git submodule update

      local TEMP_DIR
      make_temp_path TEMP_DIR -d
      TEMP_DIR="${TEMP_DIR}"/"$(basename "${prepped_submodule_path}")"
      cp -a "${prepped_submodule_path}" "${TEMP_DIR}"

      "${GIT}" config "${submodule}.url" "${TEMP_DIR}"
    else
      "${GIT}" config "${submodule}.url" "${prepped_submodule_path}"
    fi
  done

  # Checkout submodule
  next_section "Updating submodules for ${prefix-${displaypath-${GIT_MIRROR_MAIN_REPO}}}"
  # The local non-bare repo doesn't need to waste time copying LFS objects
  # Could also add --recommend-shallow (introduced in git 2.10.0)
  # This flag gets translated to the --depth flag, which is ignored for local
  # clones
  # RE This optimization does not seem worth it for a local clone
  GIT_LFS_SKIP_SMUDGE=1 "${GIT}" submodule update
  # Restore the origin urls after update, so that relative URLs work
  "${GIT}" submodule sync

  if git_mirror_has_lfs; then
    next_section "Fetching lfs objects for ${prefix-${displaypath-${GIT_MIRROR_MAIN_REPO}}}"
    # Determine this (sub)modules' prepared path
    if [ -z "${base_submodule_path}" ]; then
      prepped_submodule_path="${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}"
    else
      prepped_submodule_path="$(dirname "$(shopt -s nullglob; echo "${GIT_MIRROR_PREP_DIR}"/*/"${base_submodule_path}/config")")"
    fi

    local lfs_dir="$("${GIT}" rev-parse --git-dir)/lfs"
    # Incase it it doesn't exist
    mkdir -p "${lfs_dir}" "${prepped_submodule_path}/lfs/"

    # In the initial case, the non-bare repo will have an lfs folder, with
    # the current branch's objects in it. Move them to the prepped location
    if [[ -n $(ls -A "${lfs_dir}") ]]; then
      # combine the two
      cp -a "${lfs_dir}"/* "${prepped_submodule_path}/lfs/"
    fi

    if [[ ${OS-} = Windows_NT && -n $(ls -A "${prepped_submodule_path}/lfs") ]]; then
      cp -a "${prepped_submodule_path}"/lfs/* "${lfs_dir}/"
    else
      # Replace with symlink
      rm -rf "${lfs_dir}"
      ln -s "${prepped_submodule_path}/lfs" "${lfs_dir}"
    fi

    "${GIT}" lfs fetch --all

    if [[ ${OS-} = "Windows_NT" && -n $(ls -A "${lfs_dir}") ]]; then
      cp -a "${lfs_dir}"/* "${prepped_submodule_path}/lfs/"
    fi
  fi

  # And the recursion goes on... foreach runs in sh, so I'm forcing bash. I need
  # to pass the prefix/displaypath variables from git into the called function,
  # so export them.
  #
  # NOTE We already have the list of submodule names (via get_submodule_name),
  # and their associated sm_paths (via git config). We could recurse through
  # the submodules ourselves like just_git_functions:safe_git_submodule_update
  # (which is called recursively via just_git_functions:_checkout_git_submodule)
  # and just_git_airgap_repo.bsh:git_sync_submodules_recursively.
  # This would avoid the complications involved with exporting the required
  # variables, keeping track of base_submodule_path, re-sourcing this file (and
  # the info.env in update_submodules), etc. needed because git submodule foreach
  # runs in an sh subshell
  # RE We would first have to do a recursive clone, but we are effectively
  # doing that here anyway, just manually
  # NOTE We list submodules two ways in this function: at the beginning with
  # get_config_submodule_names (which uses git config and works with init-only
  # submodules) and, here, with git submodule foreach (which does not).
  # NOTE We could make a similar change in update_submodules
  GIT_MIRROR_PREP_DIR="${GIT_MIRROR_PREP_DIR}" base_submodule_path="${base_submodule_path}" "${GIT}" submodule foreach --quiet "export prefix displaypath; bash -euc 'unset GIT_DIR; source \"${GIT_MIRROR_SOURCE[0]}\"; clone_submodules'"
  # The "unset GIT_DIR" is needed because somewhere between git 2.17 and 2.21,
  # git-submodule-foreach started setting the GIT_DIR; however, the logic here
  # is constantly switching directories into different repositories &
  # submodules, which breaks if GIT_DIR is set
}

#**
# .. function:: update_submodules
#
# Clone a submodule and any of its submodules (recursively)
#
# This is a helper function to git_clone_main. Recursively clone a submodule mirrored with :func:`git_mirror_main`, and fixup the submodules' remote urls according to the mapping specified by ``$1``.
#
# WARNING: ``git submodule foreach`` runs commands via sh because git is weird; however I start bash and source this script for its vars and functions, so it's really bash again.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository's original url and its mirror url
#             [``base_submodule_path``] - The (relative) path from the project repository to the submodule
# :Output: The recursively cloned submodule
#**

function update_submodules()
{
  # Arrays aren't exported, reload
  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls

  local submodule_name
  local full_relative_path
  local base_submodule_path="${base_submodule_path-}${base_submodule_path:+/}${prefix-${displaypath-}}"
  # Remove trailing slashes because on some versions of git (1.8.3, 2.17.1)
  # prefix has a trailing slash
  base_submodule_path="${base_submodule_path%/}"
  local current_repo="$(_git_mirror_get_url "${base_submodule_path:-.}")"
  next_section "Initializing ${current_repo}'s submodules"

  # This is only done once when initially cloning the repo, so should not need
  # a sync
  "${GIT}" submodule init
  local IFS=$'\n'
  local submodule_names=($(get_config_submodule_names))

  for submodule_name in ${submodule_names[@]+"${submodule_names[@]}"}; do
    full_relative_path="${base_submodule_path}${base_submodule_path:+/}$("${GIT}" config -f .gitmodules ${submodule_name}.path)"
    "${GIT}" config "${submodule_name}.url" "$(_git_mirror_get_url "${full_relative_path}")"
  done
  next_section "Updating ${current_repo}'s submodules"
  "${GIT}" submodule update

  # And the recursion goes on... foreach runs in sh, so I'm forcing bash. I need
  # to pass the prefix/displaypath variables from git into the called function,
  # so export them.
  base_submodule_path="${base_submodule_path-}" \
      "${GIT}" submodule foreach --quiet "export prefix displaypath; bash -euc \
          'unset GIT_DIR; source \"${GIT_MIRROR_SOURCE[0]}\"; update_submodules \"${1}\"'"
}

#**
# .. function:: git_mirror_main
#
# Mirror the main repository and all submodules (recursively)
#
# Downloads a mirror of a git repository and all of its submodules. The normal ``git clone --mirror`` command does not support submodules at all. This at least clones all the submodules available in the specified branch (master by default).
#
# The script creates a directory, referred to as a prep directory (or prep_dir), which will contain all of the mirrored repositories plus a single ``transfer_{date}.tgz`` archive file containing all of these repositories, lfs objects, etc... Only this `tgz` file needs to be transferred to your destination.
#
# Subsequent calls to :func:`git_mirror_main` can use the existing prep directory as cache, updating faster than the first time.
#
# Subsequent calls also create a second ``tgz`` file, ``transfer_{date1}_transfer_{date2}.tgz`` (on supported platforms). This is an incremental archive file. Instead of having to bring in an entire archive, only the incremental file is needed (plus the original full archive).
#
# After you have moved the transfer archive to its destination, you can use :func:`git_push_main` to push these mirrored repositories to a new git server.
#
# :Arguments: - ``$1`` - URL of the main git repository. On subsequent calls to this function, the prep (cache) dir created by this function can be used in lue of the repository's URL
#             - [``$2``] - The git branch from which to identify the submodules. Default: master
# :Parameters: [``GIT_MIRROR_PREP_DIR``] - The output directory in which to mirror the repositories; Default: ``${PWD}/{repo_name}_prep``
# :Output: - A prep directory which will contain all of the repositories plus a single ``transfer_{date}.tgz``
#          - ``GIT_MIRROR_PREP_DIR`` - The path to the mirrored repositories
#          - ``GIT_MIRROR_MAIN_REPO`` - The main repository's name. Based off of ``$1``; e.g., vsi_common if the URL is https://github.com/VisionSystemsInc/vsi_common.git
#
# .. rubric:: Example
#
# Mirror the vsi_common repository and all of its submodules in a directory called ./vsi_common_prep. Then, create an archive file that can be transferred to your destination.
#
# .. code-block:: bash
#
# git_mirror_main https://github.com/visionsystemsinc/vsi_common.git master
# # produces ./vsi_common_prep/transfer_2020_03_02_14_16_09.tgz
#
# .. rubric:: Example
#
# Calling ``git_mirror`` again will use the vsi_common_prep dir as a cache, and then create an incremental file.
#
# .. code-block:: bash
#
# git_mirror_main vsi_common_prep
# # produces ./vsi_common_prep/transfer_2020_03_02_14_24_12_transfer_2020_03_02_14_16_09.tgz
#
# .. rubric:: Example
#
# Both of these examples result in identical mirrors on your destination:
#
# .. code-block:: bash
#
# tar zxf transfer_2020_03_02_14_16_09.tgz
# tar --incremental zxf transfer_2020_03_02_14_24_12_transfer_2020_03_02_14_16_09.tgz
#
# ###
#
# tar zxf transfer_2020_03_02_14_24_12.tgz
#
# .. note::
#
#   ``git_mirror_main`` does not mirror all submodules that have ever been part of the repo, only those from a specific branch/SHA/tag you specify (master by default). This is because trying to mirror all submodules from the past could be very lengthy, and is very likely to include urls that do not exist anymore.
#
# .. rubric:: Bugs
#
# If the first argument is a local path to a git repository (as opposed to a URL or a path to an existing prep dir), it must be an absolute path.
#**

function git_mirror_main()
{
  git_mirror_repos ${@+"${@}"}
  archive_mirrors "${GIT_MIRROR_PREP_DIR}"
}

#**
# .. function:: git_mirror_repos
#
# Mirror the main repository and all submodules (recursively)
#
# Downloads a mirror of a git repository and all of its submodules. The normal ``git clone --mirror`` command does not support submodules at all. This at least clones all the submodules available in the specified branch (master by default).
#
# Creates a directory, referred to as a prep directory (or prep_dir), which will contain all of the mirrored repositories. Subsequent calls to :func:`git_mirror_repos` can use the existing prep directory as cache, updating faster than the first time.
#
# :Arguments: - ``$1`` - URL of the main git repository. On subsequent calls to this function, the prep (cache) directory created by this function can be used in lue of the repository's URL
#             - [``$2``] - The git branch from which to identify the submodules. Default: master
# :Parameters: [``GIT_MIRROR_PREP_DIR``] - The output directory in which to mirror the repositories; Default: ``${PWD}/{repo_name}_prep``
# :Output: - A prep directory which will contain all of the repositories
#          - ``GIT_MIRROR_PREP_DIR`` - The path to the mirrored repositories
#          - ``GIT_MIRROR_MAIN_REPO`` - The main repository's name. Based off of ``$1``; e.g., vsi_common if the URL is https://github.com/VisionSystemsInc/vsi_common.git
#
# .. note::
#
#   :func:`git_mirror_repos` does not mirror all submodules that have ever been part of the repo, only those from a specific branch/SHA/tag you specify (master by default). This is because trying to mirror all submodules from the past could be very lengthy, and is very likely to include urls that do not exist anymore.
#
# .. rubric:: Bugs
#
# If the first argument is a local path to a git repository (as opposed to a URL or a path to an existing prep dir), it must be an absolute path.
#
# .. seealso::
#
#   :func:`git_mirror_main`
#**

function git_mirror_repos()
{
  if [ $# -eq 0 ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_URL [BRANCH|SHA]" >&2
    echo "${BASH_SOURCE[0]} EXISTING_PREP_DIR [BRANCH|SHA]" >&2
    exit 1
  fi

  # Does the directory look like a PREP_DIR
  if [ -f "${1}/"*"/config" ]; then
    # Don't need nullglob here because the directory exists
    pushd "$(dirname "${1}/"*"/config")" &> /dev/null
      GIT_MIRROR_PREP_DIR="${GIT_MIRROR_PREP_DIR:-"$(dirname "${PWD}")"}"
      GIT_MIRROR_MAIN_REPO="$("${GIT}" config --get remote.origin.url)"
    popd &> /dev/null
  else
    GIT_MIRROR_MAIN_REPO="${1}"
  fi
  local BRANCH="${2-master}"

  local MAIN_DIR="$(basename "${GIT_MIRROR_MAIN_REPO}")"
  MAIN_DIR="${MAIN_DIR%.*}"
  if [ -z "${GIT_MIRROR_PREP_DIR:+x}" ]; then
    GIT_MIRROR_PREP_DIR="${PWD}/${MAIN_DIR}_prep"
  fi

  # Make absolute path
  if [ "${GIT_MIRROR_PREP_DIR:0:1}" != "/" ]; then
    GIT_MIRROR_PREP_DIR="${PWD}/${GIT_MIRROR_PREP_DIR}"
  fi

  # 1. mirror clone (prep_dir)
  # 2. clone repo from /prep to /tmp/clone
  #    (in clone_submodules)
  # 3. git submodule init in /tmp/clone
  # 4. get_config_submodule_names - list submodules in /tmp/clone
  # 5. mirror each submodule into prep_dir
  # 6. change remote of each submodule in /tmp/clone to point to the prep'd mirror
  # 7. git submodule update in /tmp/clone
  # 8. repeat 3-7 for sub submodules
  # 9. profit

  #########################
  # Get the super project #
  #########################
  mkdir -p "${GIT_MIRROR_PREP_DIR}"
  if [ ! -e "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" ]; then
    next_section "Cloning super project ${GIT_MIRROR_MAIN_REPO}..."
    "${GIT}" clone --mirror "${GIT_MIRROR_MAIN_REPO}" "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}"
  else
    next_section "Fetching for super project ${GIT_MIRROR_MAIN_REPO} using last run..."
    pushd "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" &> /dev/null
      # Re-establish url in case it changed
      "${GIT}" remote set-url origin "${GIT_MIRROR_MAIN_REPO}"
      if meet_requirements "${GIT_VERSION}" ">=2.17"; then
        "${GIT}" fetch -pP origin
      else
        "${GIT}" fetch -p origin
      fi
    popd &> /dev/null
  fi

  next_section "Re-cloning locally"
  local TEMP_DIR
  make_temp_path TEMP_DIR -d
  # The local non-bare repo doesn't need to waste time copying LFS objects
  # Could also add --depth 1 --branch "${BRANCH}" --no-recursive
  # RE --depth is ignored for local clones...could add
  # --single-branch --branch "${BRNACH}" --no-recursive
  # RE This optimization does not seem worth it for a local clone
  if tar_feature_incremental_backup; then
    # Clone without hardlinks because they mess up the incremental archive
    # (see clone_submodules)
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" clone --no-hardlinks "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" "${TEMP_DIR}"
  else
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" clone "${GIT_MIRROR_PREP_DIR}/${MAIN_DIR}" "${TEMP_DIR}"
  fi

  pushd "${TEMP_DIR}" &> /dev/null
    # The local non-bare repo doesn't need to waste time copying LFS objects
    GIT_LFS_SKIP_SMUDGE=1 "${GIT}" checkout "${BRANCH}"

    # Restore origin to not point to mirror, so relative submodules work right
    "${GIT}" remote set-url origin "${GIT_MIRROR_MAIN_REPO}"

    # This effectively does git submodule update --recursive --init,
    # but plumbs the submodules to use the "${GIT_MIRROR_PREP_DIR}" instead
    clone_submodules
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: archive_mirrors
#
# Create an in-place archive of a directory
#
# Create a ``transfer_{date}.tgz`` archive file of a directory. This archive is created within the same directory.
#
# Subsequent calls also create a second ``tgz`` file, ``transfer_{date1}_transfer_{date2}.tgz`` (on supported platforms). This is an incremental archive file. Only the incremental file is needed (plus the original full archive).
#
# :Arguments: - ``$1`` - A directory to archive in-place
# :Output: A ``transfer_{date}.tgz`` archive file and, on subsequent calls, an incremental ``transfer_{date1}_transfer_{date2}.tgz``
#**

function archive_mirrors()
{
  local prep_dir="${1}"

  pushd "${prep_dir}" &> /dev/null
    next_section "Creating tar file..."
    local tar_file="transfer_$(date '+%Y_%m_%d_%H_%M_%S')"

    # BSD tar does not handle excluded files well: for some reason, if given
    # a pattern to exclude, any file that matches that pattern in its directory
    # tree is excluded. Even if a specific file is being excluded, if the file
    # is in a toplevel directory being archived, and the path is relative
    # (e.g., ./), any file with that name in its directory tree is excluded.
    # For example, --exclude ./archive.tgz would exclude not only a file
    # in the PWD called archive.tgz, but any file in a subdirectory called
    # archive.tgz.
    # As as workaround, using absolute paths everywhere works on BSD, but then
    # the path components must be stripped off before being archived.
    #
    # Unfortunately, BSD < 3 and GNU < 1.31 (at least) only support the
    # --strip-components flag on extraction. Fortunately, GNU tar, does work as
    # expected when excluding specific files with relative paths in the toplevel
    # directory being archived. Therefore, with GNU tar, using relative paths
    # everywhere works
    local tar_version
    local tar_vendor
    tar_version_info # Sets tar_version and tar_vendor
    local args=()
    local CWD
    if [ "${tar_vendor}" == "BSD" ] && meet_requirements "${tar_version}" ">=3"; then
      CWD="${PWD}"
      # Because the archive is created with absolute paths, count how many path
      # components to strip off when creating the tar; equal to the number of
      # slashes in the current path
      local x="$(tr -d -c '/' <<< "${CWD}/")"
      local ncomponents="${#x}"
      args+=("--strip-components" "${ncomponents}")
    else # GNU or BUSYBOX or BSD < 3
      # This will work properly on GNU tar, but on older versions of BSD tar,
      # like 2.8.3, this will suffer the problem of excluded file collisions
      # mentioned above. Similarly, this cannot be ''
      # This is ok here because our archives are datetime stamped so a collision
      # is very unlikely
      CWD='.'
    fi

    # Determine what tar files currently exist in the prep_dir
    local OLD_IFS="${IFS}"
    IFS=$'\n'
    local existing_tar_files=($(ls "${CWD}"/{*.tgz,*.snar} 2>/dev/null || :))
    IFS="${OLD_IFS}"
    args+=("--exclude" "${CWD}/${tar_file}.tgz")
    if tar_feature_incremental_backup; then
      args+=("--exclude" "${CWD}/${tar_file}.snar")
    fi
    local existing_tar_file
    for existing_tar_file in ${existing_tar_files[@]+"${existing_tar_files[@]}"}; do
      args+=("--exclude" "${existing_tar_file}")
    done

    # Create a full archive (and associated .snar file if possible)
    local last_tar_file
    # https://stackoverflow.com/a/37993307
    touch "${tar_file}.tgz"
    if tar_feature_incremental_backup; then
      # Get the last one, alphabetically speaking (.l1.snar comes before .snar)
      # per sort's man page:
      # The locale specified by the environment affects sort order. Set LC_ALL=C
      # to get the traditional sort order that uses native byte values.
      # We need it in this order so that base directories come before subdirectories.
      last_tar_file="$(LC_ALL=C ls "${prep_dir}"/transfer_*.snar 2>/dev/null | tail -n1)"
      last_tar_file="$(basename "${last_tar_file%.snar}")"
      ${TAR} czf "${tar_file}.tgz" -g "${tar_file}.snar" "${args[@]}" "${CWD}"
    else
      ${TAR} czf "${tar_file}.tgz" "${args[@]}" "${CWD}"
    fi

    if tar_feature_incremental_backup && [ "${last_tar_file}" != "" ]; then
      next_section "Creating an incremental tar file too, based on ${last_tar_file}"
      args+=("--exclude" "${CWD}/${tar_file}_${last_tar_file}.tgz" \
             "--exclude" "${CWD}/${last_tar_file}.l1.snar")
      # archive.snar-1 is more canonical than l1.snar [1]
      cp "${last_tar_file}.snar" "${last_tar_file}.l1.snar"
      # This snar file isn't actually used for anything because the next
      # incremental backup is created from the previous full backup
      #
      # NOTE tar uses timestamps to decide if a file has changed (this includes
      # the access, modify and change times)
      # [1] https://www.gnu.org/software/tar/manual/html_node/Incremental-Dumps.html
      # https://stackoverflow.com/a/37993307
      touch "${CWD}/${tar_file}_${last_tar_file}.tgz"
      ${TAR} czf "${tar_file}_${last_tar_file}.tgz" -g "${last_tar_file}.l1.snar" "${args[@]}" "${CWD}"
      next_section "Your new tar file is ready:"
      echo "${prep_dir}/${tar_file}.tgz"
      echo "and you have an incremental file:"
      echo "${tar_file}_${last_tar_file}.tgz"
    else
      next_section "Your new tar file is ready:"
      echo "${prep_dir}/${tar_file}.tgz"
    fi
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

function _git_mirror_load_info()
{
  if [ "${bash_feature_associative_array}" = "0" ]; then
    local -A repos
    repo_paths=()
    repo_urls=()
  fi
  source "${1}"
  if [ "${bash_feature_associative_array}" = "0" ]; then
    local key
    repo_paths=(${repo_paths[@]+"${repo_paths[@]}"} "${!repos[@]}")
    for key in "${!repos[@]}"; do
      repo_urls=(${repo_urls[@]+"${repo_urls[@]}"} "${repos[${key}]}")
    done
  fi
}

function _git_mirror_get_url()
{
  local index="$(findin "${1}" "${repo_paths[@]}")"
  if [ "${index}" -ge 0 ]; then
    echo "${repo_urls[$index]}"
    return 0
  else
    echo "Error: no entry found for: ${1}" >&2
    return 1
  fi
}

#**
# .. function:: git_clone_main
#
# Clone recursively from the new mirror
#
# Once the repository has been mirrored to the new git server with :func:`git_push_main`, it can be cloned. However, because the .gitmodules file will point to different urls than the mirrors, and changing the .gitmodules file will change the repo, which we don't want to do, we need to make a shallow clone of the repository, init the submodules, modify the submodules' urls, and then finally update the submodules. And all of this has to be done recursively for each submodule. As you can tell, this is very tedious, so this script will do it all for you.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository's original url and its mirror url
#             [``$2``] - The directory in which to clone the repo
#
# .. rubric:: Example
#
# .. code-block:: bash
#
# git_clone_main init.env ~/
#**

function git_clone_main()
{
  if [ $# -eq 0 ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_MAP_FILE [DIR]" >&2
    exit 1
  fi

  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls
  mkdir -p "${2-.}"
  pushd "${2-.}" &> /dev/null
    if [ ! -d ./.git ]; then
      "${GIT}" clone "$(_git_mirror_get_url .)" .
    fi
    update_submodules "${1}"
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

#**
# .. function:: git_push_main
#
# Push the mirrored repository and all submodules to a new git server
#
# After transferring the archive file created by :func:`git_mirror_main` to a prep directory on your destination and extracting the archive into it, this function pushes all the mirrored repositories in the extracted archive to your own mirrors on a new git server.
#
# .. note::
#
#   The mirrors must be initialized on the git server.
#
# However, because the urls for your mirrors will be different from the original repo urls in .gitmodules, and modifying the urls will change the git repo, which we do not want to do, you must create a file specifying the mapping between each repository's original url and its mirror url (remote). The main repo is referred to as ``.`` while the rest of the repos are referred to by the relative path with respect to the main repo (e.g. ``external/vsi_common``). These need to be stored in an associative array called ``repos``.
#
# :Arguments: ``$1`` - A file specifying the mapping between each repository's original url and its mirror url
#             ``$2`` - The mirrored repositories (extracted from the archive) created by :func:`git_mirror_main`
#
# .. rubric:: Example
#
# In this example, the main repo's mirror url is ``https://git-server.com/foobar/vsi_common.git``, and the submodule stored at ``./docker/recipes`` has the url ``https://git-server.com/foobar/recipes.git``. This file is also used by :func:`git_clone_main`. (Any valid git URL format can be used.)
#
# .. code-block:: bash
#
# cat info.env
# repos[.]=https://git-server.com/foobar/vsi_common.git
# repos[docker/recipes]=https://git-server.com/foobar/recipes.git
#
# git_push_main info.env vsi_common_prep
#**

function git_push_main()
{
  if [ $# -eq 0 ]; then
    echo "Usage:" >&2
    echo "${BASH_SOURCE[0]} REPO_MAP_FILE PREP_DIR" >&2
    exit 1
  fi

  _git_mirror_load_info "${1}" # Sets repo_paths and repo_urls

  pushd "${2}" &> /dev/null
    local index
    # Loop through the repos
    for index in ${repo_paths[@]+"${!repo_paths[@]}"}; do

      local repo_path
      repo_path="$(shopt -s nullglob; dirname */"${repo_paths[$index]}/config")"
      next_section "Pushing repo '${repo_path}' to '${repo_urls[$index]}'"
      if [ -d "${repo_path}" ]; then
        pushd "${repo_path}" &> /dev/null
          # It seems mirrored repositories (vxl, pytorch) can include refs/remotes/
          # I'm not sure how/why these are created---this is the pattern for the
          # ref of a remote branch in a clone. Setting up a remote-tracking branch,
          # specifying the remote & branch name manually during a git push or
          # creating a push refspec basically all do the same thing: they map local
          # refs (refs/heads) to remote refs (refs/remotes). Therefore, the mirror
          # should not have any remote refs. In any case, these cause an error,
          # "deny updating a hidden ref:", when pushing to a gitlab server. For now,
          # only filter out refs/remotes
          #
          # Push to the mirror (git push --mirror will remove deleted refs)
          # Spaces are not allowed in a refname
          "${GIT}" for-each-ref --format='%(refname)' | grep -v -e '^refs/remotes' -e '^refs/stash' | \
              xargs "${GIT}" push "${repo_urls[$index]}"

          if git_mirror_has_lfs; then
            next_section "Pushing lfs objects for ${repo_path}"
            "${GIT}" remote add mirror "${repo_urls[$index]}" 2>/dev/null || "${GIT}" remote set-url mirror "${repo_urls[$index]}"
            # Does not work on file systems, only with real lfs servers, unless you set up lfs-filestore
            "${GIT}" lfs push mirror --all || :
          fi
        popd &> /dev/null
      else
        echo "No dir found for submodule ${repo_paths[$index]}"
      fi
    done
  popd &> /dev/null

  # Reset the color
  echo -n $'\e[0m'
}

function usage()
{
  echo "Usage: ${BASH_SOURCE[0]} mirror|push|clone [OPTIONS]" >&2
  echo >&2
  echo "  mirror REPO_URL [BRANCH|SHA]" >&2
  echo "                               1) Mirror the git repository and all of its" >&2
  echo "                                  submodules (on BRANCH) to an archive." >&2
  echo "  mirror PREP_DIR [BRANCH|SHA]    Subsequent mirrors can be based of the" >&2
  echo "                                  existing PREP_DIR" >&2
  echo "  push REPO_MAP_FILE PREP_DIR  2) Push the unarchived mirrors to a new git" >&2
  echo "                                  server (with initialized repos) as defined" >&2
  echo "                                  by the REPO_MAP_FILE"
  echo "  clone REPO_MAP_FILE [DIR]    3) Clone recursively from the new mirror" >&2
  echo >&2
  echo "Example REPO_MAP_FILE:" >&2
  echo "  repos[.]='https://git-server.com/foo/superproject.git'">&2
  echo "  repos[external/submodule1]='https://git-server.com/foo/submodule1.git'">&2
  echo "  repos[external/submodule1/submodule2]='https://git-server.com/foo/subsubmodule2.git'">&2
}

if [ "${BASH_SOURCE[0]}" = "${0}" ] || [ "$(basename "${BASH_SOURCE[0]}")" = "${0}" ]; then
  set -eu

  arg="${1-}"
  case "${arg}" in
    mirror)
      shift 1
      git_mirror_main ${@+"${@}"}
      ;;
    push)
      shift 1
      git_push_main ${@+"${@}"}
      ;;
    clone)
      shift 1
      git_clone_main ${@+"${@}"}
      ;;
    *)
      usage
      exit 1
      ;;
  esac
fi
