#!/usr/bin/env false bash

if [[ ${-} != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/time_tools

#**
# ==========
# Time Tools
# ==========
#
# .. default-domain:: bash
#
# .. file:: time_tools.bsh
#
#**

#**
# .. function:: get_time_seconds
#
# Print the epoch time in seconds
#
# :Output: **stdout** - The epoch time, in seconds with nanosecond precision (if available)
#
# Uses the ``date`` command to print nanosecond-accurate epoch time, if your date command supports that feature.
#
# Else, uses ``python3``, ``ruby``, or ``perl`` if available to get microsecond-accurate time. If all else fails, use the ``date`` command, even if it does not support more than second precision.
#**
function get_time_seconds()
{
  local _get_time_decimal='.'
  # local _get_time_nanoseconds_cmd=()
  get_time_nanoseconds
  # _get_time_seconds_cmd=("${_get_time_nanoseconds_cmd[@]}")

  # _get_time_seconds_cmd
}

#**
# .. function:: get_time_nanoseconds
#
# Print the epoch time in nanoseconds. Same as :func:`get_time_seconds`, but in nanoseconds and always an integer
#**
function get_time_nanoseconds()
{
  # If this date doesn't support nanoseconds
  if [[ ! $(date +%N) =~ ^[0-9]+$ ]]; then
    local python_cmd="import time; t = time.time_ns(); print('%i${_get_time_decimal-}%09i' % (int(t/1e9), t % 1e9))"
    if command -v python3 &> /dev/null; then
      eval 'function get_time_nanoseconds(){ python3 -c "'"${python_cmd}"'"; }'
    elif command -v python &> /dev/null && [[ $(python --version) =~ Python\ 3 ]]; then
      eval 'function get_time_nanoseconds(){ python -c "'"${python_cmd}"'"; }'
    elif command -v ruby &> /dev/null; then
      function get_time_nanoseconds()
      {
        ruby -e "t = Time.now; print '%i${_get_time_decimal-}%09i'\"\n\" % [t.tv_sec, t.tv_nsec]"
      }
    elif command -v perl &> /dev/null; then
      # Only microsecond accurate
      function get_time_nanoseconds()
      {
        perl -e 'use warnings;
          my ($s, $us);
          no warnings;
          {
            local *STDOUT;
            eval "use Time::HiRes qw(gettimeofday); (\$s, \$us) = gettimeofday";
            # Using eval here the same way as ualarm does NOT work, unknown why
            # Use https://stackoverflow.com/a/7506859/4166604 workaround
          }
          if ($@){
            printf("%i'"${_get_time_decimal-}"'000000000\n", time)
          } else {
            printf("%i'"${_get_time_decimal-}"'%09i\n", $s, $us*1000)
          }'
      }
    # Add other elif commands here for other common languages
    else # Else, just do seconds; best I can do
      function get_time_nanoseconds()
      {
        date "+%s${_get_time_decimal-}000000000"
      }
    fi
  else
    function get_time_nanoseconds()
    {
      date "+%s${_get_time_decimal-}%N"
    }
  fi

  # This function redefines itself for efficiency on multiple calls. Once here,
  # it's been redefined, so it needs to be called once
  get_time_nanoseconds
}


#**
# .. function:: timeout
#
# :Arguments: * ``$1`` - Timeout in integer seconds
#             * ``$2``... - Command to execute
# :Return Value: ``142`` - On time out
# :Uses: perl
#
# macOS function similar to linux timeout
#
# .. rubric:: Bugs
#
# Since this uses SIGALRM, bash will print out "Alarm clock: 14" to indicate SIGALRM (14) has been raised. This could cause unexpected text in stderr if you are parsing it.
#
# .. seealso::
#
#    https://www.cyberciti.biz/faq/shell-scripting-run-command-under-alarmclock/
#**
if [[ ${OSTYPE-} = darwin* ]]; then
  # https://perldoc.perl.org/functions/alarm.html
  function timeout()
  {
    perl -e 'use warnings;

      no warnings;
      {
        local *STDOUT;
        eval "use Time::HiRes qw(ualarm)";
        # I have no idea what so ever why this works. The eval load of ualarm
        # should not escape this scope, and yet it does
      }

      if ( $@ ) {
        # No Time::HiRes, use alarm
        my $delay = shift;

        if ( ($delay > 0) && ($delay < 1) ) {
          $delay = 1;
        };

        eval {
          local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
          alarm $delay;
          exec @ARGV;
          alarm 0;
        };
        if ($@) {
          die unless $@ eq "alarm\n";   # propagate unexpected errors
        };
      } else {
        # Time::HiRes

        eval {
          local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
          ualarm(1_000_000 * shift);
          exec @ARGV;
          ualarm(0);
        };
        if ($@) {
          die unless $@ eq "alarm\n";   # propagate unexpected errors
        };
      };' "${@}"
  }
fi

#**
# .. function:: tic
#
# Part of a tic/toc functionality to easily take time measurements.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   $ tic
#   $ sleep 1.3
#   $ toc_ms
#   1302 ms
#
# .. seealso::
#  :func:`toc`, :func:`toc_ms`, :func:`toc_ns`
#**
function tic()
{
  _time0="$(get_time_nanoseconds)"
}

#**
# .. function:: toc
#
# Prints the time passed since calling :func:`toc` in seconds (rounded).
#
# Also stores the number of seconds passed in ``toc_time``
#**
function toc()
{
  # Make it round
  toc_time=$(($(get_time_nanoseconds)-_time0+500000000))
  # If less than 1 s, make it 0, or else removing 9 digits doesn't work
  if [ "${toc_time}" -lt "1000000000" ]; then
    toc_time=0
  else
    toc_time="${toc_time::${#toc_time}-9}"
  fi
  echo "${toc_time} s"
}

#**
# .. function:: toc_ms
#
# Prints the time passed since calling :func:`toc` in milliseconds (rounded).
#
# Also stores the number of milliseconds passed in ``toc_time``
#
# .. note::
#
#   Older ``date`` commands that don't support nanoseconds, will not be more accurate than a second.
#**
function toc_ms()
{
  toc_time=$(($(get_time_nanoseconds)-_time0+500000))
  # If less than 1 ms, make it 0, or else removing 6 digits doesn't work
  if [ "${toc_time}" -lt "1000000" ]; then
    toc_time=0
  else
    toc_time="${toc_time::${#toc_time}-6}"
  fi
  echo "${toc_time} ms"
}

#**
# .. function:: toc_ns
#
# Prints the time passed since calling :func:`toc` in nanoseconds.
#
# Also stores the number of nanoseconds passed in ``toc_time``
#
# .. note::
#
#   Older ``date`` commands that don't support nanoseconds, will not be more accurate than a second.
#**
function toc_ns()
{
  toc_time=$(($(get_time_nanoseconds)-_time0))
  echo "${toc_time} ns"
}
