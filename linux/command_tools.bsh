#!/usr/bin/env false

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/string_tools.bsh"
source "${VSI_COMMON_DIR}/linux/elements.bsh"
source "${VSI_COMMON_DIR}/linux/findin"

#*# linux/command_tools

#**
# =============
# Command Tools
# =============
#
# .. default-domain:: bash
#
# .. file:: command_tools.bsh
#
# Set of functions to make using parsing and composing commands easier
#**

#**
#
# :Arguments: ``$1``... - The names of the files being searched for
# :Return Value: file_matches - array containing matches
#
# Find files by searching up the parent tree
#
# Searches for files to use. It starts by checking the current directory, and goes up. Just like git searches for a .git directory
#**

#**
# .. function:: get_array_from_environment
#
# :Arguments: * ``$1`` - Array variable name to store values in
#             * ``$2`` - ``PREFIX`` used
#             * ``$3`` - ``NAME`` used
#             * ``[$4]`` - ``INSTANCE`` used. This argument is optional. If it is not specified, than the two patterns using ``INSTANCE`` are not checked.
#
# The purpose of this function is to gather environment values from various locations that is advantageous in many situations. Get values from array ``{PREFIX}_{NAME}S``, values ``{PREFIX}_{NAME}_1``..., array ``{PREFIX}_{INSTANCE}_{NAME}S``, and values ``{PREFIX}_{INSTANCE}_{NAME}_1``... and stores them in the variable specified by ``$1``.
#
# Since arrays cannot be exported, there are two different methods of getting environment variables.
#**
function get_array_from_environment()
{
  # In case the output variable is called var, list or i, don't define those as
  # local. Since assignement to $1 happens at the end, there is no potential of
  # variable name conflicts
  if [ "${1}" != "var" ]; then
    local var
  fi
  if [ "${1}" != "list" ]; then
    local list
  fi
  if [ "${1}" != "i" ]; then
    local i
  fi

  # Add PREFIX_NAMES if it exists
  var="${2}_${3}S[@]"
  list=(${!var+"${!var}"})

  # Add PREFIX_NAME_1... if it exists
  for (( i=1;; i++ )); do
    var="${2}_${3}_${i}"
    if [ -z "${!var+set}" ]; then
      break
    fi
    list+=("${!var}")
  done

  if [ $# -gt 3 ]; then
    # Add PREFIX_INSTANCE_NAMES if it exists
    var="${2}_${4}_${3}S[@]"
    list+=(${!var+"${!var}"})

    # Add PREFIX_INSTANCE_NAME_1... if it exists
    for (( i=1;; i++ )); do
      var="${2}_${4}_${3}_${i}"
      if [ -z "${!var+set}" ]; then
        break
      fi
      list+=("${!var}")
    done
  fi

  # The only potential name collision is list, in which case you do nothing
  if [ "${1}" != "list" ]; then
    clear_a "${1}"
    dynamic_set_a "${1}" ${list[@]+"${list[@]}"}
  fi
}

#**
# .. function:: parse-generic
#
# :Arguments: ``$1``.. - Arguments to be sent to some command
# :Output: * command_args - Arguments to some command, before the subcommand (run, build, do_something, etc...)
#          * subcommand - The subcommand specified
#          * subcommand_args - Arguments for the specified subcommand
#
# Parse a generic command's arguments and split up information (See OUTPUT). This supports a generic function that goes ``some command`` followed by arguments that start with ``-`` and take no additional arguments (``command_args``). Next an optional subcommand (``subcommand``) and those subcommand's arguments (``subcommand_args``).
#
# This will only work in the simpliest of cases (e.g. ``singularity``). Cases like ``docker`` and other commands that have more complicated ``command_args`` choices, a specific version of this function needs to be written to handle all the argument cases.
#
# Typically, in the calling function, you will define all the output variables as local, so that they are captured by the calling function only.
#
# Original command can be thought of as:
#
# .. code::
#
#     some_command "${command_args[@]}" "${subcommand}" "${subcommand_args[@]}"
#**

function parse-generic()
{
  command_args=()
  subcommand_args=()

  while (( $# )); do
    case "$1" in
      -*)
      # Everything takes zero arguments, so no need to enumerate -d --debug -h --help --nocolor -q --quiet -s --silent -v --verbose --version
        command_args+=("$1")
        shift 1
        ;;
      *)
        subcommand="$1"
        shift 1
        subcommand_args=(${@+"${@}"})
        break
        ;;
    esac
  done
}


#**
# .. function:: compose_arguments
#
# :Arguments: * [``$1``] - Name of array that will be inserted between ``command_args`` and ``subcommand``.
#             * [``$2``] - Name of array that will be inserted between the ``subcommand`` and  command args and.
# :Parameters: * ``cmd`` - The starting array of command arguments, starting with ``0``
#              * ``command_args`` - Arguments to some command, before the subcommand (run, build, do_something, etc...)
#              * ``subcommand`` - The subcommand specified
#              * ``subcommand_args`` - Arguments for the specified subcommand
#
# Appends arguemtns to the array ``cmd``. If ``cmd`` isn't defined at first, it is created an an empty array. If ``cmd`` is a string, it will be converted to a single element array, and then appended to.
#
# .. rubric:: Example
#
# .. code:: bash
#
#    cmd=(${DRYRUN} foobar)
#    CMD_ARGS=(--quiet --config "/tmp/foo bar.xml")
#    MAGIC_ARGS=(-it --rm)
#    subcommand=magic
#    command_args=(--gpu)
#    subcommand_args=(--do=something)
#
#    compose_arguments CMD_ARGS MAGIC_ARGS
#    declare -p cmd
#
#    declare -a cmd=([0]="foobar" [1]="--gpu" [2]="--quiet" [3]="--config"
#                    [4]="/tmp/foo bar.xml" [5]="magic" [6]="-it" [7]="--rm"
#                    [8]="--do=something")
#
# .. note::
#
#    Even if the arguments' variables are a non-array variables, this will work. However they will always appear to be a single argument.
#**
function compose_arguments()
{
  # Add the [@] here, which vastly simplifies the code without risk of name collisions
  _compose_arguments ${1+"${1}[@]"} ${2+"${2}[@]"}
}

function _compose_arguments()
{
  cmd+=(${command_args[@]+"${command_args[@]}"}
        ${1+${!1+"${!1}"}}
        # No quotes here, to handle the no subcommand case. Subcommands shouldn't have spaced anyways
        ${subcommand-}
        ${2+${!2+"${!2}"}}
        ${subcommand_args[@]+"${subcommand_args[@]}"})
}

#**
# .. function:: parse_args
#
# :Arguments: * ``$1`` - Name of variable to store how many arguments were parsed
#             * ``$2`` - Option string, like ``-o`` or ``--output``
#             * ``$3`` - The name of the variable that will store the result of the argument if used. Can be prefixed with ``+`` for an array, and postfixed with a ``:`` for "has an argument
#             * [ ``$4...$N`` ] - Repeat ``$2`` and ``$3``
#             * ``$N+1`` - Must be ``--`` to delineate the actual arguments are being passed in next
#             * [``$N+2...``] - The argument to parse
# :Outputs: * ``$!1`` - Store how many arguments are parsed after the ``--``, in the variable name specified in ``$1``
#           * ``$3,$5,...`` - Stores the values in the corresponding variables/arrays
#
# A simple argument parser, supporting some of the options that getopts supports
#
# #. Only parses until an argument is encountered that does not match an argument. This is useful for subcommand parsing
# #. Can support any arguments option, even if they do not start with ``-``, but that is ill advised
# #. Does not support combining multiple one letter arguments into one argument
# #. Supports the ``:`` postfix notation for "has an argument", add it to the storage name, not the option string
# #. Does not support the ``::`` notation for "maybe has an argument"
# #. Supports a ``+`` prefix notation on the storage variable name meaning the storage is an array, and values are appended to it.
# #. If options do not have an argument, then they are set to 0 if unset, and +1 for each time it is set
#
# .. rubric:: Example
#
# .. code:: bash
#
#    :caption: Here are two examples of using parse_args
#
#    local nit_pick
#    local rebuild_all
#    parse_args extra_args -n nit_pick --nit nit_pick -E rebuild_all --all rebuild_all -- ${@+"${@}"}
#    shift "${extra_args}"
#    if [ "${nit_pick}" != "0" ]; then
#      export SPHINXOPTS="${SPHINXOPTS-} -n"
#    fi
#    if [ "${rebuild_all}" != "0" ]; then
#      export SPHINXOPTS="${SPHINXOPTS-} -E -a"
#    fi
#
#    # Sometimes you just need to add to extra_args because you already used it
#    local compose_files=()
#    local args_parsed
#    parse_args args_parsed -f +compose_files: --file +compose_files: -- ${@+"${@}"}
#    extra_args+="${args_parsed}"
#    shift "${args_parsed}"
#    ### Handle parsed arguments ###
#    if [ "${#compose_files[@]}" != "0" ]; then
#      local "${JUST_PROJECT_PREFIX}_SINGULAR_COMPOSE_FILES"
#      dynamic_set_a "${JUST_PROJECT_PREFIX}_SINGULAR_COMPOSE_FILES" "${compose_files[@]}"
#    fi
#
# .. note:
#
#    Variables are always overwritten, even if not used. A ``0`` for options without arguments, and an empty string for options that take arguments indicates the option was never used. However, arrays are always appeneded to.
#
# .. warning::
#
#    Don't use variable names that start with ``__parse_args``
#**
function parse_args()
{
  local __parse_args_options=()
  local __parse_args_storage=()
  local __parse_args_is_array=()
  local __parse_args_arguments=()
  local __parse_args_index
  local __parse_args_store
  local __parse_args_indirect
  local __parse_args_used_arguments="${1}"
  shift 1

  while [ "${1}" != "--" ]; do
    if [ "${2:0:1}" = "+" ]; then
      __parse_args_store="${2:1}"
      __parse_args_is_array+=(1)
    else
      __parse_args_store="${2}"
      __parse_args_is_array+=(0)
    fi

    if [ "${2: -1}" = ":" ]; then
      __parse_args_arguments+=(1)
      __parse_args_store="${__parse_args_store::${#__parse_args_store}-1}"
    else
      __parse_args_arguments+=(0)
    fi

    __parse_args_options+=("${1}")
    __parse_args_storage+=("${__parse_args_store}")
    shift 2
  done

  shift 1 # For the --
  dynamic_set "${__parse_args_used_arguments}" "${#}"

  for __parse_args_index in "${!__parse_args_storage[@]}"; do
    if [ "${__parse_args_is_array[$__parse_args_index]}" = "0" ]; then
      if [ "${__parse_args_arguments[$__parse_args_index]}" = "0" ]; then
        # It's a variable that with no arguments, set to 0
        dynamic_set "${__parse_args_storage[$__parse_args_index]}" 0
      else
        # It's a variable that with an arguments, set to ""
        dynamic_set "${__parse_args_storage[$__parse_args_index]}" ""
      fi
    else
      # if unset
      __parse_args_indirect="${__parse_args_storage[$__parse_args_index]}[@]"
      if [ -z "${!__parse_args_indirect+set}" ]; then
        # Set to empty array
        dynamic_set_a "${__parse_args_storage[$__parse_args_index]}"
      fi
    fi
  done

  while (( $# )); do
    __parse_args_index="$(findin "${1}" ${__parse_args_options[@]+"${__parse_args_options[@]}"})"
    # If there is no match, then we are done parsing!
    if [ "${__parse_args_index}" = "-1" ]; then
      break
    else
      # Variable
      if [ "${__parse_args_is_array[$__parse_args_index]}" = "0" ]; then
        if [ "${__parse_args_arguments[$__parse_args_index]}" = "1" ]; then
          dynamic_set "${__parse_args_storage[$__parse_args_index]}" "$2"
          shift 1
        else
          __parse_args_indirect=${__parse_args_storage[$__parse_args_index]}
          dynamic_set "${__parse_args_indirect}" $((${!__parse_args_indirect}+1))
        fi
      else # Array
        if [ "${__parse_args_arguments[$__parse_args_index]}" = "1" ]; then
          add_elements_a "${__parse_args_storage[$__parse_args_index]}" "${2}"
          shift 1
        else
          add_elements_a "${__parse_args_storage[$__parse_args_index]}" 1
        fi
      fi
    fi
    shift 1
  done

  dynamic_set "${__parse_args_used_arguments}" $(( ${!__parse_args_used_arguments} - $# ))
}

#**
# .. function:: open_web_browser
#
# Opens a file/link with a web browser
#
# :Arguments: ``$1`` - The filename/link to be opened
#
# On windows, uses the associated web browser. First tried the associated Linux web browser, ``google-chrome``, ``chromium-browser``, ``firefox``, then the associated macos web browser.
#**
function open_web_browser()
{
  if [ "${OS-}" = "Windows_NT" ]; then
    start "" "${1}"
  else
    local found=0
    # "open" is for macos
    browsers=(xdg-open google-chrome chromium-browser firefox open)
    for browser in "${browsers[@]}"; do
      if command -v "${browser}" &> /dev/null; then
        "${browser}" "${1}"
        found=1
        break
      fi
    done
    if [ "${found}" = "0" ]; then
      echo "No webbrowser found. Open:" >&2
      echo "${1}" >&2
    fi
  fi
}